<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="CubeMX使用FreeRTOS编程指南 一、开发前言 CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别)，而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。\n">
<title>CubeMX下的freeRTOS</title>

<link rel='canonical' href='http://localhost:1313/p/cubemx%E4%B8%8B%E7%9A%84freertos/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="CubeMX下的freeRTOS">
<meta property='og:description' content="CubeMX使用FreeRTOS编程指南 一、开发前言 CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别)，而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。\n">
<meta property='og:url' content='http://localhost:1313/p/cubemx%E4%B8%8B%E7%9A%84freertos/'>
<meta property='og:site_name' content='cita的博客__'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='STM32' /><meta property='article:tag' content='cubeMX' /><meta property='article:tag' content='freeRTOS' /><meta property='article:published_time' content='2024-12-18T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2024-12-18T00:00:00&#43;00:00'/><meta property='og:image' content='http://localhost:1313/p/cubemx%E4%B8%8B%E7%9A%84freertos/background.jpg' />
<meta name="twitter:title" content="CubeMX下的freeRTOS">
<meta name="twitter:description" content="CubeMX使用FreeRTOS编程指南 一、开发前言 CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别)，而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='http://localhost:1313/p/cubemx%E4%B8%8B%E7%9A%84freertos/background.jpg' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu4365964393701153492.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🇨🇳</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">cita的博客__</a></h1>
            <h2 class="site-description">hello world!</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/cita-777'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>存档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/en/" >English</option>
                                
                                    <option value="http://localhost:1313/" selected>中文</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#cubemx使用freertos编程指南">CubeMX使用FreeRTOS编程指南</a>
      <ol>
        <li><a href="#一开发前言">一、开发前言</a></li>
        <li><a href="#二配置界面">二、配置界面</a></li>
        <li><a href="#三系统设置">三、系统设置</a>
          <ol>
            <li><a href="#21-调度内核设置">2.1 调度内核设置</a></li>
            <li><a href="#22-内存管理httpseducsdnnetcloudhoujieutm_sourcehighwordspm1001210130017020设置">2.2 <a href="https://edu.csdn.net/cloud/houjie?utm_source=highword&amp;spm=1001.2101.3001.7020">内存管理</a>设置</a></li>
            <li><a href="#23-钩子函数配置">2.3 钩子函数配置</a></li>
            <li><a href="#25-任务运行追踪配置">2.5 任务运行追踪配置</a></li>
            <li><a href="#26-协程配置">2.6 协程配置</a></li>
            <li><a href="#27-软件定时器配置">2.7 软件定时器配置</a></li>
            <li><a href="#28-中断优先级配置">2.8 中断优先级配置</a></li>
          </ol>
        </li>
        <li><a href="#三内核裁剪">三、内核裁剪</a></li>
        <li><a href="#四创建任务与队列">四、创建任务与队列</a>
          <ol>
            <li><a href="#41-cubemx-下任务创建与配置">4.1 CubeMX 下任务创建与配置</a></li>
            <li><a href="#42-cubemx-下队列的创建与配置">4.2 CubeMX 下队列的创建与配置</a></li>
          </ol>
        </li>
        <li><a href="#五创建定时器和信号量">五、创建定时器和信号量</a>
          <ol>
            <li><a href="#51-cubemx下定时器的创建和配置">5.1 CubeMX下定时器的创建和配置</a></li>
            <li><a href="#52-cubemx下信号量的创建和配置">5.2 CubeMX下信号量的创建和配置</a></li>
          </ol>
        </li>
        <li><a href="#六创建互斥量">六、创建互斥量</a>
          <ol>
            <li><a href="#61-cubemx下互斥量的创建和配置">6.1 CubeMX下互斥量的创建和配置</a></li>
          </ol>
        </li>
        <li><a href="#七创建事件标志组">七、创建事件标志组</a>
          <ol>
            <li><a href="#71-cubemx下事件的创建和配置">7.1 CubeMX下事件的创建和配置</a></li>
          </ol>
        </li>
        <li><a href="#八用户常量">八、用户常量</a></li>
        <li><a href="#九任务通知">九、任务通知</a></li>
        <li><a href="#十系统内核配置">十、系统内核配置</a></li>
      </ol>
    </li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/cubemx%E4%B8%8B%E7%9A%84freertos/">
                <img src="/p/cubemx%E4%B8%8B%E7%9A%84freertos/background_hu4784715761958561598.jpg"
                        srcset="/p/cubemx%E4%B8%8B%E7%9A%84freertos/background_hu4784715761958561598.jpg 800w, /p/cubemx%E4%B8%8B%E7%9A%84freertos/background_hu3085507343512068137.jpg 1600w"
                        width="800" 
                        height="566" 
                        loading="lazy"
                        alt="Featured image of post CubeMX下的freeRTOS" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/mcu/" style="background-color: #1e90ff; color: #ffffff;">
                MCU
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/cubemx%E4%B8%8B%E7%9A%84freertos/">CubeMX下的freeRTOS</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-12-18</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 24 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="cubemx使用freertos编程指南"><a href="#cubemx%e4%bd%bf%e7%94%a8freertos%e7%bc%96%e7%a8%8b%e6%8c%87%e5%8d%97" class="header-anchor"></a>CubeMX使用FreeRTOS编程指南
</h2><h3 id="一开发前言"><a href="#%e4%b8%80%e5%bc%80%e5%8f%91%e5%89%8d%e8%a8%80" class="header-anchor"></a>一、开发前言
</h3><p>CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别)，而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。</p>
<p>使用 STM32CubeMX 代码生成，在 STM32Cube 固件中，通过 ARM 提供的通用 CMSIS-OS（ cmsis_os.h 和 cmsis_os.c 文件，这两个文件把给 FreeRTOS 封装了一层，调用这其中的各类函数，和直接调用 FreeRTOS 的函数没有区别 ） 封装层，将 FreeRTOS 用作实时操作系统。也就是说在一套代码里有着两套标准，在阅读源码时需要注意区分。大多数教程讲解 FreeRTOS 的函数，此处说明ARM封装后函数。</p>
<h3 id="二配置界面"><a href="#%e4%ba%8c%e9%85%8d%e7%bd%ae%e7%95%8c%e9%9d%a2" class="header-anchor"></a>二、配置界面
</h3><p>开启 FreeRTOS 之后，可以看到配置项主要分为以下几个部分</p>
<p><img src="/p/cubemx%E4%B8%8B%E7%9A%84freertos/1.png"
	width="1430"
	height="367"
	srcset="/p/cubemx%E4%B8%8B%E7%9A%84freertos/1_hu16001677282823221343.png 480w, /p/cubemx%E4%B8%8B%E7%9A%84freertos/1_hu4623610250808612853.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="389"
		data-flex-basis="935px"
	
></p>
<p>这几个部分的主要功能如下表：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th style="text-align: center">配置项</th>
          <th style="text-align: center">功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td style="text-align: center"><strong>Tasks and Queues</strong></td>
          <td style="text-align: center">任务与队列，用于配置任务体以及消息队列；</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>Timers and Semaphores</strong></td>
          <td style="text-align: center">软件定时器与信号量，用于配置内核对象 （软件定时器和信号量）；</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>Mutexes</strong></td>
          <td style="text-align: center">互斥量，用于配置内核对象（互斥量）</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>Events</strong></td>
          <td style="text-align: center">事件，配置内核对象（事件）</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>FreeRTOS Heap Usage</strong></td>
          <td style="text-align: center">查看用户任务和系统任务的堆占用</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>Config Parameters</strong></td>
          <td style="text-align: center">系统的参数配置</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>Include Parameters</strong></td>
          <td style="text-align: center">系统的功能裁剪</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>Advanced Settings</strong></td>
          <td style="text-align: center">CubeMX 生成代码预配置项</td>
      </tr>
      <tr>
          <td style="text-align: center"><strong>User Constants</strong></td>
          <td style="text-align: center">用户常量定义</td>
      </tr>
  </tbody>
</table></div>
<p>以上各个功能分的很清晰，我们需要配置什么功能就去对应的选项下进行配置，下面根据各个配置项进行详细配置介绍</p>
<h3 id="三系统设置"><a href="#%e4%b8%89%e7%b3%bb%e7%bb%9f%e8%ae%be%e7%bd%ae" class="header-anchor"></a>三、系统设置
</h3><p>首先我们先了解一下 Config Parameters，他的配置参数如下</p>
<p><img src="/p/cubemx%E4%B8%8B%E7%9A%84freertos/2.png"
	width="1931"
	height="795"
	srcset="/p/cubemx%E4%B8%8B%E7%9A%84freertos/2_hu8918527371363193659.png 480w, /p/cubemx%E4%B8%8B%E7%9A%84freertos/2_hu16012955993996952945.png 1024w"
	loading="lazy"
	
	
		class="gallery-image" 
		data-flex-grow="242"
		data-flex-basis="582px"
	
></p>
<p>参数功能表：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><strong>API</strong></td>
          <td>显示 FreeRTOS API 接口版本</td>
      </tr>
      <tr>
          <td><strong>Version</strong></td>
          <td>显示 FreeRTOS 内核版本，CMSIS 版本</td>
      </tr>
      <tr>
          <td><strong>Kernel Setting</strong></td>
          <td>FreeRTOS 调度内核设置</td>
      </tr>
      <tr>
          <td><strong>Memory management setting</strong></td>
          <td>内存管理设置</td>
      </tr>
      <tr>
          <td><strong>Hook function related definitions</strong></td>
          <td>钩子函数有关定义</td>
      </tr>
      <tr>
          <td><strong>Run time and task stats gathering related definitions</strong></td>
          <td>系统运行时的参数收集配置</td>
      </tr>
      <tr>
          <td><strong>Co-routine related definitions</strong></td>
          <td>协程配置</td>
      </tr>
      <tr>
          <td><strong>Software timer definitons</strong></td>
          <td>软件定时器任务配置</td>
      </tr>
      <tr>
          <td><strong>Interrupt nesting behaviour configuration</strong></td>
          <td>中断优先级配置</td>
      </tr>
  </tbody>
</table></div>
<p>API 和 Version 不过多解释，显示版本信息</p>
<h4 id="21-调度内核设置"><a href="#21-%e8%b0%83%e5%ba%a6%e5%86%85%e6%a0%b8%e8%ae%be%e7%bd%ae" class="header-anchor"></a>2.1 调度内核设置
</h4><p>Kernel Setting 是 FreeRTOS 的调度内核配置，展开后有下面的配置项，使用时一般保持默认，也可以根据需要修改</p>
<p>![屏幕截图 2024-12-18 114744](D:\Desktop\各类工程文件\cita-site\content\post\cubeMX下的freeRTOS\屏幕截图 2024-12-18 114744.png)</p>
<ul>
<li><strong>USE_PREEMPTION</strong></li>
</ul>
<p>USE_PREEMPTION 是 <strong>RTOS 的调度方式选择，为 1 时使用抢占式调度器，为 0 时使用协程</strong>，如果使用抢占式调度器的话内核会在每个时钟节拍中断中进行任务切换，当使用协程的话会在如下地方进行任务切换</p>
<ol>
<li>一个任务调用了函数 taskYIELD()。</li>
<li>一个任务调用了可以使任务进入阻塞态的 API 函数。</li>
<li>应用程序明确定义了在中断中执行上下文切换。</li>
</ol>
<ul>
<li><strong>CPU_CLOCK_HZ</strong></li>
</ul>
<p>CPU_CLOCK_HZ 是 <strong>CPU 系统时钟频率</strong>，默认使用的是晶振通过时钟树后获得的时钟频率</p>
<ul>
<li><strong>TICK_RATE_HZ</strong></li>
</ul>
<p>TICK_RATE_HZ 是 <strong>RTOS 的心跳时钟频率</strong>，默认为最大值 1000 ，即心跳时钟 1ms 跳动一次</p>
<ul>
<li><strong>MAX_PRIORITIES</strong></li>
</ul>
<p>MAX_PRIORITIES 是 <strong>RTOS 任务的最高优先级设置</strong>，默认56级，一般来说一个优先级表是32位，这里用了两个，对应64位，<strong>其中8位用于系统任务的优先级处理</strong></p>
<ul>
<li><strong>MINIMAL_STACK_SIZE</strong></li>
</ul>
<p>MINIMAL_STACK_SIZE <strong>设置分配给空闲任务的堆栈大小</strong>，该值是用字（32位）指定的，而不是字节，<strong>默认为128个字，如果修改过空闲任务，则根据实际情况修改</strong></p>
<ul>
<li><strong>MAX_TASK_NAME_LEN</strong></li>
</ul>
<p>MAX_TASK_NAME_LEN 设置<strong>任务名称的最大字符数</strong>，默认16位足够</p>
<ul>
<li><strong>USE_16_BIT_TICKS</strong></li>
</ul>
<p>USE_16_BIT_TICKS <strong>存放 Tick 周期的计数器的数字位宽</strong>，默认为 Disable 即 16 位</p>
<ul>
<li><strong>IDLE_SHOULD_YIELD</strong></li>
</ul>
<p>如果IDLE_SHOULD_YIELD <strong>设置为0，则空闲任务永远不会让位于另一个任务</strong>，只在被抢占时才会离开运行状态。如果 IDLE_SHOULD_YIELD <strong>设置为1，那么当有另一个空闲优先级任务处于Ready状态时，空闲任务将不会执行它定义的功能的不止一次迭代，而不会让位于另一个任务</strong>，这确保当应用程序任务处于空闲状态时，在空闲任务中花费的时间最少，即同在空闲优先级下，空闲任务优先级更高，不会被抢占，不会以时间片运行</p>
<ul>
<li><strong>USE_MUTEXES、USE_RECURSIVE_MUTEXES、USE_COUNTING_SEMAPHORES</strong></li>
</ul>
<p>为 1 则<strong>开启系统构建过程中的互斥量、递归互斥量和信号量</strong>，该值强制为1（ENABLE）</p>
<ul>
<li><strong>QUEUE_REGISTRY_SIZE</strong></li>
</ul>
<p>队列注册表的大小，可以<strong>用于管理队列名称和队列实体，方便运行中进行查看与管理</strong>，默认为8</p>
<ul>
<li><strong>USE_APPLICATION_TASK_TAG</strong></li>
</ul>
<p>使能时会给任务一个 TAG 标签，便于用户进行使用</p>
<ul>
<li><strong>ENABLE_BACKWARD_COMPATIBILITY</strong></li>
</ul>
<p>一个兼容性使能，<strong>使能后， FreeRTOS 8.0.0 之后的版本可以通过宏定义使用 8.0.0 版本之前的函数接口</strong>，默认使能</p>
<ul>
<li><strong>USE_PORT_OPTIMISED_TASK_SELECTION</strong></li>
</ul>
<p><strong>查找下一个任务方式的选择，查找下一个就绪任务就是查找优先级表，对优先级表进行导0算法</strong>，<strong>分为通用切换或者针对性切换</strong>，一般默认不使能，使用通用切换，通用切换使用C编写，执行效率低，兼容性高；针对性切换使用处理器自带的导0指令，使用汇编编写，切换效率高，但兼容性差</p>
<ul>
<li><strong>USE_TICKLESS_IDLE</strong></li>
</ul>
<p>使能后会生成的两个空函数PreSleepProcessing和PostSleepProcessing，用户可以编写代码进入低功耗模式，生成函数如下图</p>
<p>![屏幕截图 2024-12-18 114807](D:\Desktop\各类工程文件\cita-site\content\post\cubeMX下的freeRTOS\屏幕截图 2024-12-18 114807.png)</p>
<ul>
<li><strong>USE_TASK_NOTIFICATIONS</strong></li>
</ul>
<p>任务通知使能，<strong>每个RTOS任务都有一个32位的通知值，RTOS任务通知是一个直接发送给任务的事件，它可以解除接收任务的阻塞，并可选地更新接收任务的通知值</strong>，为1开启，为0关闭，关闭可以为每个任务节省8个字节的内存空间</p>
<ul>
<li><strong>RECORD_STACK_HIGH_ADDRESS</strong></li>
</ul>
<p><strong>记录任务的堆栈入口地址到TCB</strong>，为1使能，为0关闭</p>
<h4 id="22-内存管理httpseducsdnnetcloudhoujieutm_sourcehighwordspm1001210130017020设置"><a href="#22-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86httpseducsdnnetcloudhoujieutm_sourcehighwordspm1001210130017020%e8%ae%be%e7%bd%ae" class="header-anchor"></a>2.2 <a class="link" href="https://edu.csdn.net/cloud/houjie?utm_source=highword&amp;spm=1001.2101.3001.7020"  target="_blank" rel="noopener"
    >内存管理</a>设置
</h4><p>内存管理可以看到3个配置参数</p>
<p>![屏幕截图 2024-12-18 114823](D:\Desktop\各类工程文件\cita-site\content\post\cubeMX下的freeRTOS\屏幕截图 2024-12-18 114823.png)</p>
<ul>
<li><strong>Memory Allocation</strong></li>
</ul>
<p>内存分配方式，此处<strong>默认动态和静态都可以</strong></p>
<ul>
<li><strong>TOTAL_HEAP_SIZE</strong></li>
</ul>
<p><strong>内存堆的分配大小</strong>，堆本质上就是一个数组，此处是设置堆数组的大小，设置时要考虑最小要满足所有任务的使用要求，最大不要超过系统的分配上限</p>
<ul>
<li><strong>Memory Management scheme</strong></li>
</ul>
<p>内存分配方式，有heap_1.c, heap_2.c, heap_3.c, heap_4.c and heap5.c 5种，其中<strong>1、2、4、5都是先建立一个堆数组，从数组中申请，用完再释放，与C语言中molloc和free使用链表的方式不同，该方式在 MCU 中更安全稳定</strong>，此处默认使用的方式4，具体申请释放方式可以在heap4.c中阅读到</p>
<h4 id="23-钩子函数配置"><a href="#23-%e9%92%a9%e5%ad%90%e5%87%bd%e6%95%b0%e9%85%8d%e7%bd%ae" class="header-anchor"></a>2.3 钩子函数配置
</h4><p><strong>钩子函数是一种回调函数，用于在任务执行一次之后或者某些事件发生后执行的函数</strong>，该配置项里面有五个选项，控制5种不同功能的钩子函数开启，当然用户也可以在代码中自己定义</p>
<ul>
<li><strong>USE_IDLE_HOOK</strong></li>
</ul>
<p>使能后，系统生成一个空回调函数，由用户编写函数主体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vApplicationIdleHook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每当空闲任务执行一次，钩子函数都会被执行一次</p>
<ul>
<li><strong>USE_TICK_HOOK</strong></li>
</ul>
<p>使能后，系统生成一个空回调函数，由用户编写函数主体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vApplicationTickHook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>每个TICK周期，钩子函数都会执行一次</p>
<ul>
<li><strong>USE_MALLOC_FAILED_HOOK</strong></li>
</ul>
<p>使能后，系统生成一个空回调函数，由用户编写函数主体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vApplicationMallocFailedHook</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当申请动态内存失败时，钩子函数会执行一次</p>
<ul>
<li><strong>USE_DAEMON_TASK_STARTUP_HOOK</strong></li>
</ul>
<p>使能后，系统生成一个空回调函数，由用户编写函数主体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vApplicationDaemonTaskStartupHook</span><span class="p">(</span><span class="kt">void</span><span class="p">).</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>任务刚启动时，钩子函数会执行一次</p>
<ul>
<li><strong>CHECK_FOR_STACK_OVERFLOW</strong></li>
</ul>
<p>使能后，系统生成一个空回调函数，由用户编写函数主体</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">vApplicationStackOverflowHook</span><span class="p">(</span> <span class="n">xTaskHandle</span> <span class="n">xTask</span><span class="p">,</span> <span class="kt">signed</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pcTaskName</span> <span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>任务栈溢出时，钩子函数会执行一次，传入任务 TCB 和任务名称</strong></p>
<p>当我们在 CubeMX 里面开启对应钩子函数，生成代码之后，在FreeRTOS就可以看到自动生成的钩子函数，我们在里面编写相应的功能就行</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/1e78f3a061420b8ed173622095bd7d32.png"
	
	
	
	loading="lazy"
	
		alt="20211007080910"
	
	
></p>
<h4 id="25-任务运行追踪配置"><a href="#25-%e4%bb%bb%e5%8a%a1%e8%bf%90%e8%a1%8c%e8%bf%bd%e8%b8%aa%e9%85%8d%e7%bd%ae" class="header-anchor"></a>2.5 任务运行追踪配置
</h4><p>功能配置项如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/6cf405c5a10ed591a52f566776112561.png"
	
	
	
	loading="lazy"
	
		alt="20211007081447"
	
	
></p>
<ul>
<li><strong>GENERATE_RUN_TIME_STATS</strong></li>
</ul>
<p>开启时间统计功能，在调用 vTaskGetRunTimeStats() 函数时，<strong>将任务运行时间信息保存到可读列表中</strong></p>
<ul>
<li><strong>USE_TRACE_FACILITY</strong></li>
</ul>
<p>使能后会包含额外的结构成员和函数以帮助执行可视化和跟踪，<strong>默认开启，方便 MDK 软件工具调试使用</strong></p>
<ul>
<li><strong>USE_STATS_FORMATTING_FUNCTIONS</strong></li>
</ul>
<p>使能后会<strong>生成 vTaskList() 和 vTaskGetRunTimeStats() 函数用于获取任务运行状态</strong></p>
<h4 id="26-协程配置"><a href="#26-%e5%8d%8f%e7%a8%8b%e9%85%8d%e7%bd%ae" class="header-anchor"></a>2.6 协程配置
</h4><p>Co-routine related definitions 是协程的配置项，<strong>两个选项用来配置协程是否开启，以及协程的优先级</strong>，开启后，需要用户手动创建协程，在协程几乎很少用到了，是 FreeRTOS目前还没有把协程移除的计划，但 FreeRTOS是不会再更新和维护协程了，因此大家解一下就行</p>
<p>协程特点：</p>
<ol>
<li>堆栈使用<br>
所有的协程使用同一个堆栈(如果是任务的话每个任务都有自己的堆栈)，这样就比使用任务消耗更少的 RAM</li>
<li>调度器和优先级<br>
协程使用合作式的调度器，但是可以在使用抢占式的调度器中使用协程</li>
<li>宏实现<br>
协程是通过宏定义来实现的</li>
<li>使用限制<br>
为了降低对 RAM 的消耗做了很多的限制</li>
</ol>
<p>具体 API 接口和调度原理可以参考这篇文章 : <a class="link" href="https://blog.csdn.net/lushoumin/article/details/88423621"  target="_blank" rel="noopener"
    >FreeRTOS协程</a></p>
<h4 id="27-软件定时器配置"><a href="#27-%e8%bd%af%e4%bb%b6%e5%ae%9a%e6%97%b6%e5%99%a8%e9%85%8d%e7%bd%ae" class="header-anchor"></a>2.7 软件定时器配置
</h4><p>软件定时器配置的一些相关项如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/b11299c8e377959b404b6fd3efcb4e9b.png"
	
	
	
	loading="lazy"
	
		alt="20211007084642"
	
	
></p>
<p>这四个配置项主要与软件定时器处理任务有关，<strong>软件定时器任务属于系统任务（守护线程）</strong>，开启软件定时器后用于维护软件定时器</p>
<ul>
<li><strong>USE_TIMERS</strong></li>
</ul>
<p>默认开启软件定时器任务</p>
<ul>
<li><strong>TIMER_TASK_PRIORITY</strong></li>
</ul>
<p>软件定时器任务优先级</p>
<ul>
<li><strong>TIMER_QUEUE_LENGTH</strong></li>
</ul>
<p>定时器<strong>任务队列长度</strong>，<strong>FreeRTOS 是通过队列来发送控制命令给定时器任务</strong>，叫做定时器命令队列，此处设置队列长度</p>
<ul>
<li><strong>TIMER_TASK_STACK_DEPTH</strong></li>
</ul>
<p>软件定时器<strong>任务堆栈大小</strong></p>
<h4 id="28-中断优先级配置"><a href="#28-%e4%b8%ad%e6%96%ad%e4%bc%98%e5%85%88%e7%ba%a7%e9%85%8d%e7%bd%ae" class="header-anchor"></a>2.8 中断优先级配置
</h4><ul>
<li><strong>LIBRARY_LOWEST_INTERRUPT_PRIORITY</strong></li>
</ul>
<p>此宏是<strong>用来设置最低优先级</strong>，FreeRTOS 使用的4位优先级，对应16位优先级，对应的最低优先级为15</p>
<ul>
<li><strong>LIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY</strong></li>
</ul>
<p>设置FreeRTOS 系统可管理的最大优先级，也就是<strong>设置阈值优先级</strong>，这个大家可以自由设置，<strong>这里设置为5，也就是高于5 的优先级(优先级数小于5)不归 FreeRTOS 管理</strong></p>
<h3 id="三内核裁剪"><a href="#%e4%b8%89%e5%86%85%e6%a0%b8%e8%a3%81%e5%89%aa" class="header-anchor"></a>三、内核裁剪
</h3><p>Include Parameters 下的选项应用于内核裁剪，裁剪不必要的功能，精简系统功能，减少资源占用，主要有以下几个选项：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cd675f22b3a82b26aee0c648dac42299.png"
	
	
	
	loading="lazy"
	
		alt="20211007095602"
	
	
></p>
<p><strong>配置项可裁剪的函数功能如下：</strong></p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>选项</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>vTaskPrioritySet</td>
          <td>改变某个任务的任务优先级。</td>
      </tr>
      <tr>
          <td>uxTaskPriorityGet</td>
          <td>查询某个任务的优先级。</td>
      </tr>
      <tr>
          <td>vTaskDelete</td>
          <td>删除任务</td>
      </tr>
      <tr>
          <td>vTaskCleanUpResources</td>
          <td>回收任务删除后的资源如RAM等等</td>
      </tr>
      <tr>
          <td>vTaskSuspend</td>
          <td>挂起任务</td>
      </tr>
      <tr>
          <td>vTaskDelayUntil</td>
          <td>阻塞延时一段绝对时间（绝对延时去去除程序执行时间，执行更精准）</td>
      </tr>
      <tr>
          <td>vTaskDelay</td>
          <td>阻塞延时一段相对时间</td>
      </tr>
      <tr>
          <td>xTaskGetSchedulerState</td>
          <td>获取任务调度器的状态，开启或未开启</td>
      </tr>
      <tr>
          <td>xTaskResumeFromISR</td>
          <td>在中断服务函数中恢复一个任务的运行</td>
      </tr>
      <tr>
          <td>xQueueGetMutexHolder</td>
          <td>获取信号量的队列拥有者，返回拥有此信号量的队列</td>
      </tr>
      <tr>
          <td>xSemaphoreGetMutexHolder</td>
          <td>查询拥有互斥锁的任务，返回任务控制块</td>
      </tr>
      <tr>
          <td>pcTaskGetTaskName</td>
          <td>获取任务名称</td>
      </tr>
      <tr>
          <td>uxTaskGetStackHighWaterMark</td>
          <td>获取任务的堆栈的历史剩余最小值，FreeRTOS 中叫做“高水位线”</td>
      </tr>
      <tr>
          <td>xTaskGetCurrentTaskHandle</td>
          <td>此函数用于获取当前任务的任务句柄，就是获取当前任务控制块</td>
      </tr>
      <tr>
          <td>eTaskGetState</td>
          <td>此函数用于查询某个任务的运行壮态，比如：运行态、阻塞态、挂起态、就绪态等</td>
      </tr>
      <tr>
          <td>xEventGroupSetBitFromISR</td>
          <td>在中断服务函数中将指定的事件位清零</td>
      </tr>
      <tr>
          <td>xTimerPendFunctionCall</td>
          <td>定时器守护任务的回调函数（定时器守护任务使用到一个命令队列，只要向队列发送信号就可以执行相应代码，可以实现“中断推迟处理”功能）</td>
      </tr>
      <tr>
          <td>xTaskAbortDelay</td>
          <td>中止延时函数，该函数能立即解除任务的阻塞状态，将任务插入就绪列表中</td>
      </tr>
      <tr>
          <td>xTaskGetHandle</td>
          <td>此函数根据任务名字获取的任务句柄（控制块）</td>
      </tr>
  </tbody>
</table></div>
<h3 id="四创建任务与队列"><a href="#%e5%9b%9b%e5%88%9b%e5%bb%ba%e4%bb%bb%e5%8a%a1%e4%b8%8e%e9%98%9f%e5%88%97" class="header-anchor"></a>四、创建任务与队列
</h3><h4 id="41-cubemx-下任务创建与配置"><a href="#41-cubemx-%e4%b8%8b%e4%bb%bb%e5%8a%a1%e5%88%9b%e5%bb%ba%e4%b8%8e%e9%85%8d%e7%bd%ae" class="header-anchor"></a>4.1 CubeMX 下任务创建与配置
</h4><p>任务（线程）是操作系统运行的基本单元，也是资源分配的基本单元， CubeMX 任务的创建基本以图形化进行，配置方式如下</p>
<p>进入Tashs and Queues 配置，点击 Add 添加新任务</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/dd5dcd50ca389448091ebfd17aed4c7e.png"
	
	
	
	loading="lazy"
	
		alt="20211008215753"
	
	
></p>
<p>任务配置参数介绍</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Task Name</td>
          <td>任务名称，保存在 TCB 结构体中，设置时自己起名字</td>
      </tr>
      <tr>
          <td>Priority</td>
          <td>任务优先级，任务的调度等级，根据自己创建任务的紧急程度设定</td>
      </tr>
      <tr>
          <td>比如通信任务不能被打断，可以设计较高优先级</td>
          <td></td>
      </tr>
      <tr>
          <td>Stack Size（Words）</td>
          <td>设定给任务分配的内存大小，单位是字，对于32位单片机来说占4个字节</td>
      </tr>
      <tr>
          <td>Entry Function</td>
          <td>任务实体，即任务的运行函数名</td>
      </tr>
      <tr>
          <td>Code Generation</td>
          <td>代码生成模式</td>
      </tr>
      <tr>
          <td>As weak： 产生一个用 __weak 修饰的弱定义任务函数，用户可自己在进行定义；</td>
          <td></td>
      </tr>
      <tr>
          <td>As external： 产生一个外部引用的任务函数，用户需要自己定义该函数；</td>
          <td></td>
      </tr>
      <tr>
          <td>Default： 产生一个默认格式的任务函数，用户需要在该函数内实现自己的功能</td>
          <td></td>
      </tr>
      <tr>
          <td>Parameter:</td>
          <td>传入的参数，保持默认就行</td>
      </tr>
      <tr>
          <td>Allocation:</td>
          <td>内存分配方式</td>
      </tr>
      <tr>
          <td>Static： 静态方式是直接在RAM占据一个静态空间</td>
          <td></td>
      </tr>
      <tr>
          <td>Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p>设置完成后点击OK，配置就完成了，之后生成代码，使用 MDK 进一步配置任务的具体信息</p>
<p>在生成的代码中，我们打开 freertos.c 文件可以在代码中看到任务的配置信息</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/e6ecac30971bf50da693e1080ab6d626.png"
	
	
	
	loading="lazy"
	
		alt="20211009123942"
	
	
></p>
<p>在 freertos.c 文件的末尾部分，我们可以看到生成的任务实体</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0f6e9b3854b47cee14056d8aace2eefe.png"
	
	
	
	loading="lazy"
	
		alt="20211009124134"
	
	
></p>
<p>任务实体本身就是一个死循环函数，循环执行程序代码，但循环体代码里面必须要有延时函数，释放当前任务对 MCU 的控制权，使其他低优先级可以执行，此外，关于任务，CubeMX 提供了一系列的用户调用接口函数，具体如下</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osThreadNew</td>
          <td>创建新任务</td>
      </tr>
      <tr>
          <td>*osThreadGetName</td>
          <td>获取任务名称</td>
      </tr>
      <tr>
          <td>osThreadGetId</td>
          <td>获取当前任务的控制块（TCB）</td>
      </tr>
      <tr>
          <td>osThreadGetState</td>
          <td>获取当前任务的运行状态</td>
      </tr>
      <tr>
          <td>osThreadGetStackSize</td>
          <td>获取任务的堆栈大小</td>
      </tr>
      <tr>
          <td>osThreadGetStackSpace</td>
          <td>获取任务剩余的堆栈大小</td>
      </tr>
      <tr>
          <td>osThreadSetPriority</td>
          <td>设定任务优先级</td>
      </tr>
      <tr>
          <td>osThreadGetPriority</td>
          <td>获取任务优先级</td>
      </tr>
      <tr>
          <td>osThreadYield</td>
          <td>切换控制权给下一个任务</td>
      </tr>
      <tr>
          <td>osThreadSuspend</td>
          <td>挂起任务</td>
      </tr>
      <tr>
          <td>osThreadResume</td>
          <td>恢复任务（挂起多少次恢复多少次）</td>
      </tr>
      <tr>
          <td>osThreadDetach</td>
          <td>分离任务，方便任务结束进行回收</td>
      </tr>
      <tr>
          <td>osThreadJoin</td>
          <td>等待指定的任务停止</td>
      </tr>
      <tr>
          <td>osThreadExit</td>
          <td>停止当前任务</td>
      </tr>
      <tr>
          <td>osThreadTerminate</td>
          <td>停止指定任务</td>
      </tr>
      <tr>
          <td>osThreadGetCount</td>
          <td>获取激活的任务数量</td>
      </tr>
      <tr>
          <td>osThreadEnumerate</td>
          <td>列举激活的任务</td>
      </tr>
  </tbody>
</table></div>
<h4 id="42-cubemx-下队列的创建与配置"><a href="#42-cubemx-%e4%b8%8b%e9%98%9f%e5%88%97%e7%9a%84%e5%88%9b%e5%bb%ba%e4%b8%8e%e9%85%8d%e7%bd%ae" class="header-anchor"></a>4.2 CubeMX 下队列的创建与配置
</h4><p>队列，又称为消息队列，用于任务间的数据通信，传输数据，在操作系统里面，直接使用全局变量传输数据十分危险，看似正常运行，但不知道啥时候就会因为寄存器或者内存等等原因引起崩溃，所以引入消息，队列的概念，任务发送数据到队列，需要接受消息的任务挂起在队列的挂起列表，等待消息的到来，CubeMX 创建队列的步骤如下：</p>
<p>先点击 Add 添加队列</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/62dc4e476ad69b3d2eb16fc2a5319aad.png"
	
	
	
	loading="lazy"
	
		alt="20211008221618"
	
	
></p>
<p>队列配置参数介绍</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Queue Name</td>
          <td>队列名称（自己设定）</td>
      </tr>
      <tr>
          <td>Queue Size</td>
          <td>消息队列大小</td>
      </tr>
      <tr>
          <td>Item Size</td>
          <td>队列传输类型，保持默认16 位就行</td>
      </tr>
      <tr>
          <td>Allocation</td>
          <td>队列内存的分配方式</td>
      </tr>
      <tr>
          <td>Static： 静态方式是直接在RAM占据一个静态空间</td>
          <td></td>
      </tr>
      <tr>
          <td>Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p>配置需要的参数后，点击OK，然后生成代码</p>
<p>生成代码后，我们可以在 freertos.c 中系统初始话函数中看到队列的初始化</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/505aa92488c07f23b4e40bf4a076f231.png"
	
	
	
	loading="lazy"
	
		alt="20211009130435"
	
	
></p>
<p>初始化函数会在一开始被调用，对 FreeRTOS 系统和内核对象进行初始化，初始化后系统就可以进行调度和使用内核对象，CubeMX 生成的代码自动将创建的内核对象放到初始化函数内，所以我们在任务和中断中直接使用就可以，队列的 FreeRTOS API 接口在CubeMX 内再次进行了封装，使用更加简单，使用方式如下：</p>
<p>我们使用的 CMSIS 2.0 版本，所以在任务文件中包含调用声明头文件</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&#34;cmsis_os2.h&#34;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在队列头文件内我们可以在 600 多行的位置找到有关队列的 API 函数声明：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/df73383642f6c2623a7797acb95b015e.png"
	
	
	
	loading="lazy"
	
		alt="20211009131537"
	
	
></p>
<p>下面介绍一下队列有关接口的函数接口：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osMessageQueueNew</td>
          <td>创建并初始化一个新的队列</td>
      </tr>
      <tr>
          <td>osMessageQueueGetName</td>
          <td>获取队列的名字</td>
      </tr>
      <tr>
          <td>osMessageQueuePut</td>
          <td>发送一条消息到队列</td>
      </tr>
      <tr>
          <td>osMessageQueueGet</td>
          <td>从队列等待一条消息</td>
      </tr>
      <tr>
          <td>osMessageQueueGetCapacity</td>
          <td>获取队列传输消息的峰值</td>
      </tr>
      <tr>
          <td>osMessageQueueGetMsgSize</td>
          <td>获取队列使用内存池的最大峰值</td>
      </tr>
      <tr>
          <td>osMessageQueueGetCount</td>
          <td>获取队列的消息数量</td>
      </tr>
      <tr>
          <td>osMessageQueueGetSpace</td>
          <td>获取队列剩余的可用空槽</td>
      </tr>
      <tr>
          <td>osMessageQueueReset</td>
          <td>清空队列</td>
      </tr>
      <tr>
          <td>osMessageQueueDelete</td>
          <td>删除队列</td>
      </tr>
  </tbody>
</table></div>
<p>以上的API接口有其对应的传入参数，具体使用方式需要在翻源码的注释，这里我选常用的来介绍一下：</p>
<p>消息队列常用的是插入与获取消息，初始化系统已经帮助我们完成，在初始化的时候会获取一个队列的句柄，之后对队列的操作都是围绕这个句柄展开，比如上面的代码中，句柄就是 <code>myQueue01Handle</code> ，我们发送一个消息到这个队列，就是调用发送函数，对句柄进行操作，先看一下发送消息的函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osMessageQueuePut</span> <span class="p">(</span><span class="kt">osMessageQueueId_t</span> <span class="n">mq_id</span><span class="p">,</span> <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg_ptr</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">msg_prio</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数的功能</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>mq_id</td>
          <td>传入队列的句柄</td>
      </tr>
      <tr>
          <td>*msg_ptr</td>
          <td>指向需要发送的消息内容的指针</td>
      </tr>
      <tr>
          <td>msg_prio</td>
          <td>本次发送消息的优先级（目前API未加入功能）</td>
      </tr>
      <tr>
          <td>timeout</td>
          <td>发送消息的超时时间（设置为0代表一直等待发送成功）</td>
      </tr>
      <tr>
          <td>osStatus_t（返回值）</td>
          <td>返回执行结果</td>
      </tr>
  </tbody>
</table></div>
<p>返回值的可能</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>错误</th>
          <th>含义</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osOK</td>
          <td>执行正常</td>
      </tr>
      <tr>
          <td>osError</td>
          <td>系统错误</td>
      </tr>
      <tr>
          <td>osErrorTimeout</td>
          <td>执行超时</td>
      </tr>
      <tr>
          <td>osErrorResource</td>
          <td>资源不可用</td>
      </tr>
      <tr>
          <td>osErrorParameter</td>
          <td>参数无效</td>
      </tr>
      <tr>
          <td>osErrorNoMemory</td>
          <td>内存不足</td>
      </tr>
      <tr>
          <td>osErrorISR</td>
          <td>不允许在中断调用</td>
      </tr>
      <tr>
          <td>osStatusReserved</td>
          <td>防止编译器优化项，不需要管他</td>
      </tr>
  </tbody>
</table></div>
<p>所以我们发送一个消息到队列，函数用法如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartTask02</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartTask02 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">dat</span><span class="p">[]</span><span class="o">=</span><span class="s">&#34;666</span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span><span class="o">=</span> <span class="nf">osMessageQueuePut</span><span class="p">(</span><span class="n">myQueue01Handle</span><span class="p">,</span><span class="n">dat</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//发送成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//发送失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartTask02 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">1234567891011121314151617181920</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发送消息的优先级暂时无用，CubeMX 对 FreeRTOS 的支持还不完善，发送消息里面的优先级未使用到，并且入队方式使用的是发送到队列尾部，没有从头部插入的方式，有需求可以 通过包含 queue.h 文件，调用 FreeRTOS 的官方代码，或者自己修改 生成代码的 API 接口结合优先级使用队列的向前插入和向后插入，丰富系统功能！</p>
<p>除了发送消息到队列，接受队列的消息 API 接口也经常用到，函数原型如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osMessageQueueGet</span> <span class="p">(</span><span class="kt">osMessageQueueId_t</span> <span class="n">mq_id</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">msg_ptr</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">msg_prio</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数的功能</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>mq_id</td>
          <td>接受队列的句柄</td>
      </tr>
      <tr>
          <td>*msg_ptr</td>
          <td>用于接受消息内容的指针</td>
      </tr>
      <tr>
          <td>msg_prio</td>
          <td>存放接受消息的优先级（目前API未加入功能）</td>
      </tr>
      <tr>
          <td>timeout</td>
          <td>接受消息的超时时间（设置为10代表，当前任务挂起在挂起列表，直到接收成功时恢复，或者10个TICK等待周期到达然后任务强行恢复，不再等待，为0则是不等待，等待期间任务挂起在内核对象的挂起队列）</td>
      </tr>
      <tr>
          <td>osStatus_t（返回值）</td>
          <td>返回执行结果</td>
      </tr>
  </tbody>
</table></div>
<p>函数用法</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartTask02</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartTask02 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">dat</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{};</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span><span class="o">=</span> <span class="nf">osMessageQueueGet</span><span class="p">(</span><span class="n">myQueue01Handle</span><span class="p">,</span><span class="n">dat</span><span class="p">,</span><span class="n">pro</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//接受成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//接受失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartTask02 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">123456789101112131415161718192021</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>注意：FreeRTOS 中获取和发送消息的 API 接口函数分为任务中调用和中断中调用，CubeMX 代码接口将两者整合了，调用时自动判断调用环境是在 ISR 还是正常运行环境中</strong></p>
</blockquote>
<h3 id="五创建定时器和信号量"><a href="#%e4%ba%94%e5%88%9b%e5%bb%ba%e5%ae%9a%e6%97%b6%e5%99%a8%e5%92%8c%e4%bf%a1%e5%8f%b7%e9%87%8f" class="header-anchor"></a>五、创建定时器和信号量
</h3><h4 id="51-cubemx下定时器的创建和配置"><a href="#51-cubemx%e4%b8%8b%e5%ae%9a%e6%97%b6%e5%99%a8%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e9%85%8d%e7%bd%ae" class="header-anchor"></a>5.1 CubeMX下定时器的创建和配置
</h4><p>软件定时器本质上就是设置一段时间，当设置的时间到达之后就执行指定的功能函数，调用的这个函数叫做回调函数。回调函数的两次执行间隔叫做定时器的定时周期，简而言之，当定时器的定时周期到了以后就会执行回调函数，下面介绍一下 CubeMX 中开启定时器的方法：</p>
<p>在 CubeMX 里面按下面步骤添加定时器</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/13d8411b14380373c90450df4acb0012.png"
	
	
	
	loading="lazy"
	
		alt="20211009221917"
	
	
></p>
<p>然后配置具体参数，参数的功能如下：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Timer Name</td>
          <td>设置定时器的名称</td>
      </tr>
      <tr>
          <td>Callback</td>
          <td>设定定时器的回调函数体</td>
      </tr>
      <tr>
          <td>Type</td>
          <td>设定定时器的执行类型</td>
      </tr>
      <tr>
          <td>osTimerPeriodic 定时器周期执行回调函数</td>
          <td></td>
      </tr>
      <tr>
          <td>osTimerOnce 定时器只执行一次回调函数</td>
          <td></td>
      </tr>
      <tr>
          <td>Code Generation Option</td>
          <td>代码生成模式</td>
      </tr>
      <tr>
          <td>As weak： 产生一个用 __weak 修饰的弱定义任务函数，用户可自己在进行定义；</td>
          <td></td>
      </tr>
      <tr>
          <td>As external： 产生一个外部引用的任务函数，用户需要自己定义该函数；</td>
          <td></td>
      </tr>
      <tr>
          <td>Default： 产生一个默认格式的任务函数，用户需要在该函数内实现自己的功能</td>
          <td></td>
      </tr>
      <tr>
          <td>Parameter</td>
          <td>传入参数，保持默认NULL就行</td>
      </tr>
      <tr>
          <td>Allocation</td>
          <td>软件定时器内存的分配方式，一般使用动态</td>
      </tr>
      <tr>
          <td>Static： 静态方式是直接在RAM占据一个静态空间</td>
          <td></td>
      </tr>
      <tr>
          <td>Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p>参数配置完成后，生成代码，我们可以在 freertos.c 文件里面看到定时器创建后获得的句柄，以及生成的回调函数：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/0d1c239ca1dbf54e70bfeec6e0140e42.png"
	
	
	
	loading="lazy"
	
		alt="20211010142155"
	
	
></p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5d75eb7a5bcda163a339ad69203dec41.png"
	
	
	
	loading="lazy"
	
		alt="20211010142213"
	
	
></p>
<p>有了句柄，我们就可以调用 cmsis_os2.c 里面的定时器接口函数对定时器进行操作，先看一下 CubeMX 提供的定时器接口函数及其功能</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osTimerNew</td>
          <td>新建定时器，返回定时器控制句柄</td>
      </tr>
      <tr>
          <td>osTimerGetName</td>
          <td>获取定时器名称</td>
      </tr>
      <tr>
          <td>osTimerStart</td>
          <td>设置定时器周期，启动定时器</td>
      </tr>
      <tr>
          <td>osTimerStop</td>
          <td>停止定时器</td>
      </tr>
      <tr>
          <td>osTimerIsRunning</td>
          <td>检测定时器是否在运行</td>
      </tr>
      <tr>
          <td>osTimerDelete</td>
          <td>删除定时器</td>
      </tr>
  </tbody>
</table></div>
<p>其中常用的接口是定时器的启动和停止</p>
<p><strong>定时器启动： <code>osTimerStart</code>，函数原型</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osTimerStart</span> <span class="p">(</span><span class="kt">osTimerId_t</span> <span class="n">timer_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ticks</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>timer_id</td>
          <td>需要启动的定时器句柄</td>
      </tr>
      <tr>
          <td>ticks</td>
          <td>设置定时器的运行周期</td>
      </tr>
  </tbody>
</table></div>
<p>此处的 ticks 设定的数字是定时器两次调用回调函数的周期数目，每个 tick 是一个心跳时钟的长度</p>
<p>使用例程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartTask02</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartTask02 */</span>
</span></span><span class="line"><span class="cl">    <span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="n">dat</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="o">=</span> <span class="nf">osTimerStart</span><span class="p">(</span><span class="n">myTimer01Handle</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//启动成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//启动失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartTask02 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">123456789101112131415161718192021222324</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>按照例程启动定时器，定时器会以 10个tick 的周期，调用回调函数</p>
<blockquote>
<p>回调函数不要放阻塞函数，程序尽可能短</p>
</blockquote>
<p><strong>定时器启动： <code>osTimerStop</code>，函数原型</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osTimerStop</span> <span class="p">(</span><span class="kt">osTimerId_t</span> <span class="n">timer_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数只有一个，就是定时器的控制句柄，传入即可停止定时器，例程如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartTask02</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartTask02 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="n">dat</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">pro</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="o">=</span> <span class="nf">osTimerStop</span><span class="p">(</span><span class="n">myTimer01Handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//停止成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//停止失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartTask02 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">123456789101112131415161718192021</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>软件定时器是由软件定时器维护任务进行维护，检测各个定时器的状态，进行处理，回调回调函数，软件定时器维护任务的参数配置在前面的 Config 就已经提到过</strong></p>
</blockquote>
<h4 id="52-cubemx下信号量的创建和配置"><a href="#52-cubemx%e4%b8%8b%e4%bf%a1%e5%8f%b7%e9%87%8f%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e9%85%8d%e7%bd%ae" class="header-anchor"></a>5.2 CubeMX下信号量的创建和配置
</h4><p>信号量是 RTOS 的一个内核对象，该对象有一个队列表示该信号量拥有的信号数目，任何任务都可以对这个信号数目进行获取和释放，获取时信号-1，释放时信号+1，为0时不能继续获取，此时有任务想要继续获取信号量的话，任务会挂起在该内核对象的挂起列表，等到信号可以获取时进行恢复，根据这个特性，<strong>信号量常用于控制对共享资源的访问和任务同步</strong>，下面介绍一下 CubeMX 下信号量的配置：</p>
<p>点开配置页面，可以看到有两个信号量添加页面，其中 Binary Semaphores 是二值信号量，Counting Semaphores 是计数信号量，二进制信号量，仅有一个队列或者说 token，用于同步一个操作；计数信号量则拥有多个 tokens，可用于同步多个操作，或者管理有限资源</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/f5b5c121e27659737ee3dee5f5e8778c.png"
	
	
	
	loading="lazy"
	
		alt="20211010153231"
	
	
></p>
<p><strong>二值信号量创建：</strong></p>
<p>点击 Add，配置参数</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/cf4eb10549dcde7e1ffd7e3b8ad7078c.png"
	
	
	
	loading="lazy"
	
		alt="20211010163823"
	
	
></p>
<p>参数介绍</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Semaphore Name</td>
          <td>信号量名称</td>
      </tr>
      <tr>
          <td>Allocation</td>
          <td>内存分配方式，一般使用动态</td>
      </tr>
      <tr>
          <td>Static： 静态方式是直接在RAM占据一个静态空间</td>
          <td></td>
      </tr>
      <tr>
          <td>Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p><strong>计数信号量：</strong></p>
<p>点击 Add，配置参数</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c7c6dc536edba5089ff0e2da7e99ba80.png"
	
	
	
	loading="lazy"
	
		alt="20211010163959"
	
	
></p>
<p>参数介绍</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Semaphore Name</td>
          <td>信号量名称</td>
      </tr>
      <tr>
          <td>Count</td>
          <td>计数信号量的最大数目</td>
      </tr>
      <tr>
          <td>Allocation</td>
          <td>内存分配方式，一般使用动态</td>
      </tr>
      <tr>
          <td>Static： 静态方式是直接在RAM占据一个静态空间</td>
          <td></td>
      </tr>
      <tr>
          <td>Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p>配置完成后我们生成代码，在 freertos.c 的初始化代码中可以看到信号量被创建，并且返回了信号量的控制句柄</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/82b2cf49541c6177bef892e5778ed86a.png"
	
	
	
	loading="lazy"
	
		alt="20211010164347"
	
	
></p>
<p>下面介绍一下 CubeMX 提供的信号量操作函数接口：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osSemaphoreNew</td>
          <td>创建新的信号量</td>
      </tr>
      <tr>
          <td>*osSemaphoreGetName</td>
          <td>获取信号量的名称</td>
      </tr>
      <tr>
          <td>osSemaphoreAcquire</td>
          <td>获取信号量</td>
      </tr>
      <tr>
          <td>osSemaphoreRelease</td>
          <td>释放信号量</td>
      </tr>
      <tr>
          <td>osSemaphoreGetCount</td>
          <td>获取当前可用信号量的数目</td>
      </tr>
      <tr>
          <td>osSemaphoreDelete</td>
          <td>删除信号量</td>
      </tr>
  </tbody>
</table></div>
<p>其中常用的函数有获取和释放信号量，下面介绍一下这两个函数的参数和使用方式</p>
<p><strong>获取信号量 osSemaphoreAcquire</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osSemaphoreAcquire</span> <span class="p">(</span><span class="kt">osSemaphoreId_t</span> <span class="n">semaphore_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>semaphore_id</td>
          <td>传入要获取信号量的控制句柄</td>
      </tr>
      <tr>
          <td>timeout</td>
          <td>获取等待时间（等待期间任务挂起在内核对象的挂起队列）</td>
      </tr>
  </tbody>
</table></div>
<p>使用例程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartDefaultTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartDefaultTask */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="nf">osSemaphoreAcquire</span><span class="p">(</span><span class="n">myBinarySem01Handle</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//获取成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//获取失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartDefaultTask */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">123456789101112131415161718192021</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>释放信号量 osSemaphoreRelease</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osSemaphoreRelease</span> <span class="p">(</span><span class="kt">osSemaphoreId_t</span> <span class="n">semaphore_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>semaphore_id</td>
          <td>传入要释放的信号量控制句柄</td>
      </tr>
  </tbody>
</table></div>
<p>使用例程</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartDefaultTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartDefaultTask */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">	
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="nf">osSemaphoreRelease</span><span class="p">(</span><span class="n">myBinarySem01Handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//释放成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//释放失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartDefaultTask */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">123456789101112131415161718192021</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>二值信号量和计数信号量的操作基本一致，没用区别，只是用有的信号队列最大数目不同而已</strong></p>
<p><strong>同时注意信号量在使用过程中会出现优先级反转的Bug，使用时需要注意</strong></p>
</blockquote>
<h3 id="六创建互斥量"><a href="#%e5%85%ad%e5%88%9b%e5%bb%ba%e4%ba%92%e6%96%a5%e9%87%8f" class="header-anchor"></a>六、创建互斥量
</h3><h4 id="61-cubemx下互斥量的创建和配置"><a href="#61-cubemx%e4%b8%8b%e4%ba%92%e6%96%a5%e9%87%8f%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e9%85%8d%e7%bd%ae" class="header-anchor"></a>6.1 CubeMX下互斥量的创建和配置
</h4><p>互斥量其实就是一个拥有优先级继承的二值信号量，互斥信号量适合用于那些需要互斥访问的应用中，在互斥访问中互斥信号量相当于一个钥匙，当任务想要使用资源的时候就必须先获得这个钥匙，当使用完资源以后就必须归还这个钥匙，这样其他的任务就可以拿着这个钥匙去使用资源，与信号量不同的是，互斥量的释放必须由获取他的任务进行释放，如果不释放，可能会造成死锁</p>
<blockquote>
<p><strong>死锁就是两个任务获取对方拥有的锁，各自进入挂起列表，无法释放互斥锁</strong></p>
</blockquote>
<p>下面介绍一下 CubeMX 下互斥量的配置，在配置界面我们可用看到两个互斥量配置界面，上面的是普通互斥量，其获取只能获取一次，重复获取是无效的，而第二个则是递归互斥量，递归互斥信号量可以获取多次，但对应的也要释放多次才能让出使用权，比如我获取3次，任务要释放3次才能释放该互斥量的使用权</p>
<p>使用互斥量，需要点击 Add 然后配置参数</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/18c865980b3defab6043e52b5ff27f30.png"
	
	
	
	loading="lazy"
	
		alt="20211010173127"
	
	
></p>
<p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Mutex Name</td>
          <td>互斥量名称</td>
      </tr>
      <tr>
          <td>Allocation</td>
          <td>内存分配方式，一般使用动态</td>
      </tr>
      <tr>
          <td>Static： 静态方式是直接在RAM占据一个静态空间</td>
          <td></td>
      </tr>
      <tr>
          <td>Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p>递归互斥信号量的配置方式与其相同，包括配置参数也相同，两者只是在用法上有些许区别，添加方式如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/c6f0a5e73f8dcc04adf62d8bdb57a04c.png"
	
	
	
	loading="lazy"
	
		alt="20211010173704"
	
	
></p>
<p>添加配置完成后，点击生成代码，在 freertos.c 文件中我们可以看到互斥量初始化完成，并且生成了对应的控制句柄</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/efee4357f4d68db0727541159149fef4.png"
	
	
	
	loading="lazy"
	
		alt="20211010174350"
	
	
></p>
<p>CubeMX 提供的 API 接口函数如下</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osMutexNew</td>
          <td>创建互斥量</td>
      </tr>
      <tr>
          <td>*osMutexGetName</td>
          <td>获取互斥量名称</td>
      </tr>
      <tr>
          <td>osMutexAcquire</td>
          <td>任务获取互斥量</td>
      </tr>
      <tr>
          <td>osMutexRelease</td>
          <td>任务释放互斥量</td>
      </tr>
      <tr>
          <td>osMutexGetOwner</td>
          <td>获取互斥量的拥有任务的任务 TCB</td>
      </tr>
      <tr>
          <td>osMutexDelete</td>
          <td>删除互斥量</td>
      </tr>
  </tbody>
</table></div>
<p>主要使用到的还是互斥量的获取与释放，下面分析一下这两个函数：</p>
<p><strong>获取互斥量 osMutexAcquire</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osMutexAcquire</span> <span class="p">(</span><span class="kt">osMutexId_t</span> <span class="n">mutex_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>mutex_id</td>
          <td>互斥量控制句柄</td>
      </tr>
      <tr>
          <td>timeout</td>
          <td>获取互斥量时的等待时间（等待期间任务挂起在内核对象的挂起队列）</td>
      </tr>
  </tbody>
</table></div>
<p>使用方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartTask02</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartTask02 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="o">=</span> <span class="nf">osMutexAcquire</span><span class="p">(</span><span class="n">myMutex01Handle</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//获取成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//获取失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartTask02 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">12345678910111213141516171819</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>释放互斥量 osMutexRelease</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">osStatus_t</span> <span class="nf">osMutexRelease</span> <span class="p">(</span><span class="kt">osMutexId_t</span> <span class="n">mutex_id</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>mutex_id</td>
          <td>互斥量控制句柄</td>
      </tr>
  </tbody>
</table></div>
<p>使用方式</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartTask02</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartTask02 */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="n">result</span><span class="o">=</span> <span class="nf">osMutexRelease</span><span class="p">(</span><span class="n">myMutex01Handle</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//释放成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">    <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="c1">//释放失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartTask02 */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">12345678910111213141516171819</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>使用方式和信号量基本相同，因为互斥量本质上就是信号量的一种</strong></p>
</blockquote>
<h3 id="七创建事件标志组"><a href="#%e4%b8%83%e5%88%9b%e5%bb%ba%e4%ba%8b%e4%bb%b6%e6%a0%87%e5%bf%97%e7%bb%84" class="header-anchor"></a>七、创建事件标志组
</h3><h4 id="71-cubemx下事件的创建和配置"><a href="#71-cubemx%e4%b8%8b%e4%ba%8b%e4%bb%b6%e7%9a%84%e5%88%9b%e5%bb%ba%e5%92%8c%e9%85%8d%e7%bd%ae" class="header-anchor"></a>7.1 CubeMX下事件的创建和配置
</h4><p>任务间的同步除了信号量还有时间标志组，信号的同步通常是一对一的同步，有的时候系统需要多对一的同步，比如同时满足5个按键按下时，任务启动，如果使用信号会很占据资源，所以 RTOS 引入了事件标志组来满足这一需求，下面我们看一下 CubeMX 内事件标志组的配置方法：</p>
<p>点击 Add 创建事件标志组</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/628cf7734f3f2de7e692bcc4194f4d71.png"
	
	
	
	loading="lazy"
	
		alt="20211010201501"
	
	
></p>
<p>配置介绍</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Event flags Name</td>
          <td>事件标志组名称</td>
      </tr>
      <tr>
          <td>Allocation</td>
          <td>内存分配方式，一般使用动态</td>
      </tr>
      <tr>
          <td>Static： 静态方式是直接在RAM占据一个静态空间</td>
          <td></td>
      </tr>
      <tr>
          <td>Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间</td>
          <td></td>
      </tr>
  </tbody>
</table></div>
<p>配置完成后，生成代码，在系统初始化内，看有没有生成事件标志组控制句柄，可以看到句柄创建完成</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/379dfd171612fcd7d24d9b5d03d808be.png"
	
	
	
	loading="lazy"
	
		alt="20211010201922"
	
	
></p>
<p>CubeMX 提供的配置事件标志组的接口 API 如下：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osEventFlagsNew</td>
          <td>创建事件标志组</td>
      </tr>
      <tr>
          <td>*osEventFlagsGetName</td>
          <td>获取事件标志组名称</td>
      </tr>
      <tr>
          <td>osEventFlagsSet</td>
          <td>设置事件标志组</td>
      </tr>
      <tr>
          <td>osEventFlagsClear</td>
          <td>清除事件标志组</td>
      </tr>
      <tr>
          <td>osEventFlagsGet</td>
          <td>获取当前事件组标志信息</td>
      </tr>
      <tr>
          <td>osEventFlagsWait</td>
          <td>等待事件标志组触发</td>
      </tr>
      <tr>
          <td>osEventFlagsDelete</td>
          <td>删除事件标志组</td>
      </tr>
  </tbody>
</table></div>
<p>常用的 API 接口是设置事件标志组以及等待事件标志组的触发，下面我们分析一下这两个 API</p>
<p>在了解 API 前我们需要简单了解一下事件的触发原理：首先事件标志组的数据类型为 EventGroupHandle_t，<strong>事件标志组中的所有事件位都存储在一个无符号的 EventBits_t 类型的变量中</strong>，当 configUSE_16_BIT_TICKS 为 1 的时候事件标志组可以存储 8 个事件位，当 configUSE_16_BIT_TICKS 为 0 的时候事件标志组存储 24个事件位，每个事件位其实就是一个0或者1数字，就像下面的24位组成一个事件标志组</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/5cfbdcd0160d44aeb9ba16e0d135affe.png"
	
	
	
	loading="lazy"
	
		alt="20211010203414"
	
	
></p>
<p>我们在使用事件API接口函数前<strong>需要先定义我们需要的触发事件位</strong>，比如添加如下的代码</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define event1 1&lt;&lt;1 	</span><span class="c1">//事件1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="cp">#define event2 1&lt;&lt;2 	</span><span class="c1">//事件2
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="mi">12</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编写好触发事件后，我们在看如何使用 API 接口</p>
<p><strong>设置事件标志 osEventFlagsSet</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">uint32_t</span> <span class="nf">osEventFlagsSet</span> <span class="p">(</span><span class="kt">osEventFlagsId_t</span> <span class="n">ef_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ef_id</td>
          <td>事件标志组控制句柄</td>
      </tr>
      <tr>
          <td>flags</td>
          <td>事件位</td>
      </tr>
  </tbody>
</table></div>
<p>使用方式：设置事件1和事件2</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartDefaultTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartDefaultTask */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="nf">osEventFlagsSet</span><span class="p">(</span><span class="n">myEvent01Handle</span><span class="p">,</span><span class="n">event1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//事件1设置成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//事件1设置失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="nf">osEventFlagsSet</span><span class="p">(</span><span class="n">myEvent01Handle</span><span class="p">,</span><span class="n">event2</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//事件2设置成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//事件2设置失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span> 
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartDefaultTask */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">123456789101112131415161718192021222324252627</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>等待事件标志 osEventFlagsWait</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">uint32_t</span> <span class="nf">osEventFlagsWait</span> <span class="p">(</span><span class="kt">osEventFlagsId_t</span> <span class="n">ef_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">options</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>ef_id</td>
          <td>事件标志组控制句柄</td>
      </tr>
      <tr>
          <td>flags</td>
          <td>等待的事件位</td>
      </tr>
      <tr>
          <td>options</td>
          <td>等待事件位的操作</td>
      </tr>
      <tr>
          <td>osFlagsWaitAny ：等待的事件位有任意一个等到就恢复任务</td>
          <td></td>
      </tr>
      <tr>
          <td>osFlagsWaitAll：等待的事件位全部等到才恢复任务</td>
          <td></td>
      </tr>
      <tr>
          <td>osFlagsNoClear：等待成功后不清楚所等待的标志位（默认清除）</td>
          <td></td>
      </tr>
      <tr>
          <td>timeout</td>
          <td>等待事件组的等待时间（等待期间任务挂起在内核对象的挂起队列）</td>
      </tr>
  </tbody>
</table></div>
<p>使用例子：同时等待事件1和事件2，且等待到不清除</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartDefaultTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartDefaultTask */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="nf">osEventFlagsWait</span><span class="p">(</span><span class="n">myEvent01Handle</span><span class="p">,</span><span class="n">event1</span><span class="o">|</span><span class="n">event2</span><span class="p">,</span><span class="n">osFlagsWaitAll</span><span class="o">|</span><span class="n">osFlagsNoClear</span><span class="p">,</span><span class="mi">10</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//等待成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//等待失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartDefaultTask */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">12345678910111213141516171819</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="八用户常量"><a href="#%e5%85%ab%e7%94%a8%e6%88%b7%e5%b8%b8%e9%87%8f" class="header-anchor"></a>八、用户常量
</h3><p>User Constants 用于添加用户常量，将不变的量转化为常量保存，可以节省 RAM 资源空间，因为常量和变量的保存位置不同，详细了解可以参考这篇文章：<a class="link" href="https://blog.csdn.net/qq_45396672/article/details/119155585"  target="_blank" rel="noopener"
    >C语言：内存四区</a></p>
<h3 id="九任务通知"><a href="#%e4%b9%9d%e4%bb%bb%e5%8a%a1%e9%80%9a%e7%9f%a5" class="header-anchor"></a>九、任务通知
</h3><p>FreeRTOS 的每个任务都<strong>有一个 32 位的通知值</strong>，任务控制块中的成员变量 ulNotifiedValue 就是这个通知值。任务通知是一个事件，假如某个任务通知的接收任务因为等待任务通知而阻塞的话，向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态，CubeMX内没有提供相关的配置项，但在其生成的 FreeRTOS 接口里面有相关函数进行配置，函数位置如下：</p>
<p><img src="https://i-blog.csdnimg.cn/blog_migrate/db70d19d1e96d6e01f7a947a738bee3f.png"
	
	
	
	loading="lazy"
	
		alt="1"
	
	
></p>
<p>接口函数功能：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osThreadFlagsSet</td>
          <td>设置任务的通知标志</td>
      </tr>
      <tr>
          <td>osThreadFlagsClear</td>
          <td>清除任务通知</td>
      </tr>
      <tr>
          <td>osThreadFlagsGet</td>
          <td>获取任务标志</td>
      </tr>
      <tr>
          <td>osThreadFlagsWait</td>
          <td>等待特定的任务标志</td>
      </tr>
  </tbody>
</table></div>
<p>常用的两个 API 就是设置任务通知和等待任务通知函数</p>
<p><strong>设置通知 osThreadFlagsSet</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">uint32_t</span> <span class="nf">osThreadFlagsSet</span> <span class="p">(</span><span class="kt">osThreadId_t</span> <span class="n">thread_id</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>thread_id</td>
          <td>任务控制块</td>
      </tr>
      <tr>
          <td>flags</td>
          <td>设置的标志</td>
      </tr>
  </tbody>
</table></div>
<p>使用方式</p>
<p>先定义一个事件标志</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define  event1 1&lt;&lt;1 	//事件1
</span></span><span class="line"><span class="cl">1
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后调用 API 通知对应任务事件发生</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartDefaultTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartDefaultTask */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="nf">osThreadFlagsSet</span><span class="p">(</span><span class="n">myTask02Handle</span><span class="p">,</span><span class="n">event1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//设置成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//设置失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartDefaultTask */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">1234567891011121314151617181920</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>等待通知 osThreadFlagsWait</strong></p>
<p>函数原型</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">uint32_t</span> <span class="nf">osThreadFlagsWait</span> <span class="p">(</span><span class="kt">uint32_t</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">options</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">timeout</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="mi">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>参数介绍：</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>flags</td>
          <td>设置的标志</td>
      </tr>
      <tr>
          <td>options</td>
          <td>设置功能</td>
      </tr>
      <tr>
          <td>timeout</td>
          <td>超时时间</td>
      </tr>
  </tbody>
</table></div>
<p>options参数</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>参数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osFlagsWaitAny</td>
          <td>等待32位通知值任意一位触发后恢复任务（默认）</td>
      </tr>
      <tr>
          <td>osFlagsWaitAll</td>
          <td>等待指定的任务通知值全部触发后再恢复任务</td>
      </tr>
      <tr>
          <td>osFlagsNoClear</td>
          <td>恢复任务后不清除任务标志（默认清除）</td>
      </tr>
  </tbody>
</table></div>
<p>使用方式</p>
<p>调用 API 等待对应的任务通知就绪，当其他任务设置到对应的通知后，任务恢复运行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">StartDefaultTask</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">argument</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE BEGIN StartDefaultTask */</span>
</span></span><span class="line"><span class="cl">	<span class="kt">osStatus_t</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* Infinite loop */</span>
</span></span><span class="line"><span class="cl">  <span class="k">for</span><span class="p">(;;)</span>
</span></span><span class="line"><span class="cl">  <span class="p">{</span>
</span></span><span class="line"><span class="cl">		
</span></span><span class="line"><span class="cl">		<span class="n">result</span> <span class="o">=</span> <span class="nf">osThreadFlagsWait</span><span class="p">(</span><span class="n">myTask02Handle</span><span class="p">,</span><span class="n">osFlagsWaitAll</span><span class="p">,</span><span class="n">event1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span><span class="p">(</span><span class="n">result</span> <span class="o">==</span> <span class="n">osOK</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//等待成功
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span><span class="k">else</span>
</span></span><span class="line"><span class="cl">		<span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="c1">//等待失败
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">osDelay</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="cl">  <span class="cm">/* USER CODE END StartDefaultTask */</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="mi">1234567891011121314151617181920</span>
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p><strong>任务通知其实个任务事件标志组使用上没有多大的区别，但他们两个的实现原理不同，同时任务通知对资源的占用更少</strong></p>
<p><strong>根据 FreeRTOS 官方的统计，使用任务通知替代二值信号量的时候任务解除阻 塞的时间要快 45%，并且需要的 RAM 也更少</strong></p>
</blockquote>
<h3 id="十系统内核配置"><a href="#%e5%8d%81%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%b8%e9%85%8d%e7%bd%ae" class="header-anchor"></a>十、系统内核配置
</h3><p>CubeMX 生成的代码中封装了一系列内核配置函数，有些函数也经常使用到，比如获取时间戳和调度器管理的函数，这里不做过多解释，简单的介绍一下函数的功能</p>
<div class="table-wrapper"><table>
  <thead>
      <tr>
          <th>函数</th>
          <th>功能</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>osKernelInitialize</td>
          <td>初始化RTOS的内核</td>
      </tr>
      <tr>
          <td>osKernelGetInfo</td>
          <td>获取RTOS的信息</td>
      </tr>
      <tr>
          <td>osKernelGetState</td>
          <td>获取当前内核的运行状态</td>
      </tr>
      <tr>
          <td>osKernelStart</td>
          <td>启动内核调度</td>
      </tr>
      <tr>
          <td>osKernelLock</td>
          <td>锁内核调度器</td>
      </tr>
      <tr>
          <td>osKernelUnlock</td>
          <td>解锁内核调度器</td>
      </tr>
      <tr>
          <td>osKernelRestoreLock</td>
          <td>恢复RTOS内核调度器锁状态</td>
      </tr>
      <tr>
          <td>osKernelSuspend</td>
          <td>挂起任务</td>
      </tr>
      <tr>
          <td>osKernelResume</td>
          <td>恢复任务</td>
      </tr>
      <tr>
          <td>osKernelGetTickCount</td>
          <td>用于获取系统当前运行的时钟节拍数</td>
      </tr>
      <tr>
          <td>osKernelGetTickFreq</td>
          <td>用于获取系统当前运行的时钟节拍的分频频率</td>
      </tr>
      <tr>
          <td>osKernelGetSysTimerCount</td>
          <td>获取系统时钟（SysTick）的计数值</td>
      </tr>
      <tr>
          <td>osKernelGetSysTimerFreq</td>
          <td>获取系统时钟（SysTick）的频率</td>
      </tr>
  </tbody>
</table></div>
<blockquote>
<p>仅供参考，可能有误</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/stm32/">STM32</a>
        
            <a href="/tags/cubemx/">CubeMX</a>
        
            <a href="/tags/freertos/">FreeRTOS</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/pcb%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AB%8B%E5%88%9Beda%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/">
        
        
            <div class="article-image">
                <img src="/p/pcb%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AB%8B%E5%88%9Beda%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post PCB设计与立创EDA使用备忘录"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">PCB设计与立创EDA使用备忘录</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/">
        
        
            <div class="article-image">
                <img src="/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 华为嵌入式C语言代码简明规范"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">华为嵌入式C语言代码简明规范</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E6%B5%85%E6%9E%90pid/">
        
        
            <div class="article-image">
                <img src="/p/%E6%B5%85%E6%9E%90pid/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 浅析PID"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">浅析PID</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">
        
        
            <div class="article-image">
                <img src="/p/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 物联网协议基础"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">物联网协议基础</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2024 - 
        
        2025 cita
    </section>
    
    <section class="powerby">
        
            Hello World <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
