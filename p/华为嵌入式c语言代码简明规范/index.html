<!DOCTYPE html>
<html lang="zh-cn" dir="ltr">
    <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content="规范制订说明 前言 基于华为C语言编程规范 在线wiki文档\n代码总体原则 清晰第一 代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化\n优秀的代码可以自我解释（以我的水平可能做到比较难） 常写注释，并且注释写的清晰 简洁为美 写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。\n">
<title>华为嵌入式C语言代码简明规范</title>

<link rel='canonical' href='http://localhost:1313/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/'>

<link rel="stylesheet" href="/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css"><meta property='og:title' content="华为嵌入式C语言代码简明规范">
<meta property='og:description' content="规范制订说明 前言 基于华为C语言编程规范 在线wiki文档\n代码总体原则 清晰第一 代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化\n优秀的代码可以自我解释（以我的水平可能做到比较难） 常写注释，并且注释写的清晰 简洁为美 写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。\n">
<meta property='og:url' content='http://localhost:1313/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/'>
<meta property='og:site_name' content='cita的博客__'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='嵌入式' /><meta property='article:tag' content='C语言' /><meta property='article:tag' content='代码规范' /><meta property='article:published_time' content='2024-11-23T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2024-11-23T00:00:00&#43;00:00'/><meta property='og:image' content='http://localhost:1313/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/background.jpg' />
<meta name="twitter:title" content="华为嵌入式C语言代码简明规范">
<meta name="twitter:description" content="规范制订说明 前言 基于华为C语言编程规范 在线wiki文档\n代码总体原则 清晰第一 代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化\n优秀的代码可以自我解释（以我的水平可能做到比较难） 常写注释，并且注释写的清晰 简洁为美 写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。\n"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='http://localhost:1313/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/background.jpg' />
    </head>
    <body class="
    article-page
    ">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky ">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="切换菜单">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header>
        
            
            <figure class="site-avatar">
                <a href="/">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu4365964393701153492.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                
                </a>
                
                    <span class="emoji">🇨🇳</span>
                
            </figure>
            
        
        
        <div class="site-meta">
            <h1 class="site-name"><a href="/">cita的博客__</a></h1>
            <h2 class="site-description">hello world!</h2>
        </div>
    </header><ol class="menu-social">
            
                <li>
                    <a 
                        href='https://github.com/cita-777'
                        target="_blank"
                        title="GitHub"
                        rel="me"
                    >
                        
                        
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5" />
</svg>



                        
                    </a>
                </li>
            
        </ol><ol class="menu" id="main-menu">
        
        
        
        <li >
            <a href='/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>主页</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E5%85%B3%E4%BA%8E/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>关于</span>
            </a>
        </li>
        
        
        <li >
            <a href='/archives/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>存档</span>
            </a>
        </li>
        
        
        <li >
            <a href='/search/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>搜索</span>
            </a>
        </li>
        
        
        <li >
            <a href='/%E9%93%BE%E6%8E%A5/' >
                
                
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M10 14a3.5 3.5 0 0 0 5 0l4 -4a3.5 3.5 0 0 0 -5 -5l-.5 .5" />
  <path d="M14 10a3.5 3.5 0 0 0 -5 0l-4 4a3.5 3.5 0 0 0 5 5l.5 -.5" />
</svg>



                
                <span>链接</span>
            </a>
        </li>
        
        <li class="menu-bottom-section">
            <ol class="menu">
                    
                        <li id="i18n-switch">  
                            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-language" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z" fill="none"/>
  <path d="M4 5h7" />
  <path d="M9 3v2c0 4.418 -2.239 8 -5 8" />
  <path d="M5 9c-.003 2.144 2.952 3.908 6.7 4" />
  <path d="M12 20l4 -9l4 9" />
  <path d="M19.1 18h-6.2" />
</svg>



                            <select name="language" title="language" onchange="window.location.href = this.selectedOptions[0].value">
                                
                                    <option value="http://localhost:1313/en/" >English</option>
                                
                                    <option value="http://localhost:1313/" selected>中文</option>
                                
                            </select>
                        </li>
                    
                

                
                    <li id="dark-mode-toggle">
                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                        <span>暗色模式</span>
                    </li>
                
            </ol>
        </li>
    </ol>
</aside>

    <aside class="sidebar right-sidebar sticky">
        
            
                
    <section class="widget archives">
        <div class="widget-icon">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <line x1="5" y1="9" x2="19" y2="9" />
  <line x1="5" y1="15" x2="19" y2="15" />
  <line x1="11" y1="4" x2="7" y2="20" />
  <line x1="17" y1="4" x2="13" y2="20" />
</svg>



        </div>
        <h2 class="widget-title section-title">目录</h2>
        
        <div class="widget--toc">
            <nav id="TableOfContents">
  <ol>
    <li><a href="#规范制订说明">规范制订说明</a>
      <ol>
        <li><a href="#前言">前言</a></li>
        <li><a href="#代码总体原则">代码总体原则</a>
          <ol>
            <li><a href="#清晰第一">清晰第一</a></li>
            <li><a href="#简洁为美">简洁为美</a></li>
          </ol>
        </li>
        <li><a href="#术语">术语</a></li>
      </ol>
    </li>
    <li><a href="#头文件">头文件</a>
      <ol>
        <li><a href="#原则">原则</a>
          <ol>
            <li><a href="#原则11-头文件中适合放置接口的声明不适合放置实现">原则1.1 头文件中适合放置接口的声明，不适合放置实现</a></li>
            <li><a href="#原则12-头文件应当职责单一">原则1.2 头文件应当职责单一。</a></li>
            <li><a href="#原则13-头文件应向稳定的方向包含">原则1.3 头文件应向稳定的方向包含。</a></li>
          </ol>
        </li>
        <li><a href="#规则">规则</a>
          <ol>
            <li><a href="#规则11-每一个c文件应有一个同名h文件用于声明需要对外公开的接口">规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。</a></li>
            <li><a href="#规则12-禁止头文件循环依赖">规则1.2 禁止头文件循环依赖</a></li>
            <li><a href="#规则13-ch文件禁止包含用不到的头文件">规则1.3 .c/.h文件禁止包含用不到的头文件。</a></li>
            <li><a href="#规则14-头文件应当自包含">规则1.4 头文件应当自包含。</a></li>
            <li><a href="#规则15-总是编写内部include保护符define-保护">规则1.5 总是编写内部#include保护符（#define 保护）。</a></li>
            <li><a href="#规则16-禁止在头文件中定义变量">规则1.6 禁止在头文件中定义变量。</a></li>
            <li><a href="#规则17-只能通过包含头文件的方式使用其他c提供的接口禁止在c中通过extern的方式使用外部函数接口变量">规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。</a></li>
            <li><a href="#规则18-禁止在extern-c中包含头文件">规则1.8 禁止在extern “C”中包含头文件。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#函数">函数</a>
      <ol>
        <li><a href="#原则-1">原则</a>
          <ol>
            <li><a href="#原则21-一个函数仅完成一件功能">原则2.1 一个函数仅完成一件功能。</a></li>
            <li><a href="#原则22-重复代码应该尽可能提炼成函数">原则2.2 重复代码应该尽可能提炼成函数</a></li>
          </ol>
        </li>
        <li><a href="#规则-1">规则</a>
          <ol>
            <li><a href="#规则21-避免函数过长新增函数不超过50行非空非注释行">规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。</a></li>
            <li><a href="#规则22-避免函数的代码块嵌套过深新增函数的代码块嵌套不超过4层">规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。</a></li>
            <li><a href="#规则23-可重入函数应避免使用共享变量若需要使用则应通过互斥手段关中断信号量对其加以保护">规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。</a></li>
            <li><a href="#规则24-对参数的合法性检查由调用者负责还是由接口函数负责应在项目组模块内应统一规定缺省由调用者负责">规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。</a></li>
            <li><a href="#规则25-对函数的错误返回码要全面处理">规则2.5 对函数的错误返回码要全面处理。</a></li>
            <li><a href="#规则26-设计高扇入合理扇出小于7的函数">规则2.6 设计高扇入，合理扇出（小于7）的函数。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#标识符命名与定义">标识符命名与定义</a>
      <ol>
        <li><a href="#原则-2">原则</a>
          <ol>
            <li><a href="#原则31标识符的命名要清晰明了有明确含义同时使用完整的单词或大家基本可以理解的缩写避免使人产生误解">原则3.1标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。</a></li>
            <li><a href="#原则32-除了常见的通用缩写以外不使用单词缩写不得使用汉语拼音">原则3.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。</a></li>
          </ol>
        </li>
        <li><a href="#规则-2">规则</a>
          <ol>
            <li><a href="#规则31-产品项目组内部应保持统一的命名风格">规则3.1 产品/项目组内部应保持统一的命名风格。</a></li>
          </ol>
        </li>
        <li><a href="#建议">建议</a>
          <ol>
            <li><a href="#建议32-尽量避免名字中出现数字编号除非逻辑上的确需要编号">建议3.2 尽量避免名字中出现数字编号，除非逻辑上的确需要编号。</a></li>
            <li><a href="#建议33-标识符前不应添加模块项目产品部门的名称作为前缀">建议3.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀。</a></li>
            <li><a href="#建议34-平台驱动等适配代码的标识符命名风格保持和平台驱动一致">建议3.4 平台/驱动等适配代码的标识符命名风格保持和平台/驱动一致。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#文件命名规则">文件命名规则</a>
      <ol>
        <li><a href="#建议-1">建议</a>
          <ol>
            <li><a href="#建议36-文件命名统一采用小写字符">建议3.6 文件命名统一采用小写字符。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#变量命名规则">变量命名规则</a>
      <ol>
        <li><a href="#规则-3">规则</a>
          <ol>
            <li><a href="#规则32-全局变量应增加g_前缀">规则3.2 全局变量应增加“g_”前缀。</a></li>
            <li><a href="#规则33-静态变量应增加s_前缀">规则3.3 静态变量应增加“s_”前缀。</a></li>
            <li><a href="#规则34-禁止使用单字节命名变量但允许定义ijk作为局部循环变量">规则3.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。</a></li>
          </ol>
        </li>
        <li><a href="#建议-2">建议</a>
          <ol>
            <li><a href="#建议37-不建议使用匈牙利命名法">建议3.7 不建议使用匈牙利命名法。</a></li>
            <li><a href="#建议38-使用名词或者形容词名词方式命名变量">建议3.8 使用名词或者形容词＋名词方式命名变量。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#函数命名规则">函数命名规则</a>
      <ol>
        <li><a href="#建议-3">建议</a>
          <ol>
            <li><a href="#建议39-函数命名应以函数要执行的动作命名一般采用动词或者动词名词的结构">建议3.9 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#宏的命名规则">宏的命名规则</a>
      <ol>
        <li><a href="#规则-4">规则</a>
          <ol>
            <li><a href="#规则35对于数值或者字符串等等常量的定义建议采用全大写字母单词之间加下划线_的方式命名枚举同样建议使用此方式定义">规则3.5对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘_’的方式命名（枚举同样建议使用此方式定义）。</a></li>
            <li><a href="#规则36-除了头文件或编译开关等特殊标识定义宏定义不能使用下划线_开头和结尾">规则3.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘_’开头和结尾。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#变量">变量</a>
      <ol>
        <li><a href="#原则-3">原则</a>
          <ol>
            <li><a href="#原则41-一个变量只有一个功能不能把一个变量用作多种用途">原则4.1 一个变量只有一个功能，不能把一个变量用作多种用途。</a></li>
            <li><a href="#原则42-结构功能单一不要设计面面俱到的数据结构">原则4.2 结构功能单一；不要设计面面俱到的数据结构。</a></li>
            <li><a href="#原则43-不用或者少用全局变量">原则4.3 不用或者少用全局变量。</a></li>
          </ol>
        </li>
        <li><a href="#规则-5">规则</a>
          <ol>
            <li><a href="#规则41-防止局部变量与全局变量同名">规则4.1 防止局部变量与全局变量同名。</a></li>
            <li><a href="#规则42-通讯过程中使用的结构必须注意字节序">规则4.2 通讯过程中使用的结构，必须注意字节序。</a></li>
            <li><a href="#规则43-严禁使用未经初始化的变量作为右值">规则4.3 严禁使用未经初始化的变量作为右值。</a></li>
          </ol>
        </li>
        <li><a href="#建议-4">建议</a>
          <ol>
            <li><a href="#建议41-构造仅有一个模块或函数可以修改创建而其余有关模块或函数只访问的全局变量防止多个不同模块或函数都可以修改创建同一全局变量的现象">建议4.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。</a></li>
            <li><a href="#建议42-使用面向接口编程思想通过api访问数据如果本模块的数据需要对外部模块开放应提供接口函数来设置获取同时注意全局数据的访问互斥">建议4.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。</a></li>
            <li><a href="#建议43-在首次使用前初始化变量初始化的地方离使用的地方越近越好建议43-在首次使用前初始化变量初始化的地方离使用的地方越近越好">建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。</a></li>
            <li><a href="#建议44-明确全局变量的初始化顺序避免跨模块的初始化依赖">建议4.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖。</a></li>
            <li><a href="#建议45-尽量减少没有必要的数据类型默认转换与强制转换">建议4.5 尽量减少没有必要的数据类型默认转换与强制转换。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#宏常量">宏、常量</a>
      <ol>
        <li><a href="#规则-6">规则</a>
          <ol>
            <li><a href="#规则51-用宏定义表达式时要使用完备的括号">规则5.1 用宏定义表达式时，要使用完备的括号。</a></li>
            <li><a href="#规则52-将宏所定义的多条表达式放在大括号中">规则5.2 将宏所定义的多条表达式放在大括号中。</a></li>
            <li><a href="#规则53-使用宏时不允许参数发生变化">规则5.3 使用宏时，不允许参数发生变化。</a></li>
            <li><a href="#规则54-不允许直接使用魔鬼数字">规则5.4 不允许直接使用魔鬼数字。</a></li>
          </ol>
        </li>
        <li><a href="#建议-5">建议</a>
          <ol>
            <li><a href="#建议51-除非必要应尽可能使用函数代替宏">建议5.1 除非必要，应尽可能使用函数代替宏。</a></li>
            <li><a href="#建议52-常量建议使用const定义代替宏">建议5.2 常量建议使用const定义代替宏。</a></li>
            <li><a href="#建议53-宏定义中尽量不使用returngotocontinuebreak等改变程序流程的语句">建议5.3 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#质量保证">质量保证</a>
      <ol>
        <li><a href="#原则-4">原则</a>
          <ol>
            <li><a href="#原则61-代码质量保证优先原则性能并没有放在那么靠前的位置有些意外">原则6.1 代码质量保证优先原则（性能并没有放在那么靠前的位置，有些意外！）</a></li>
            <li><a href="#原则62-要时刻注意易混淆的操作符">原则6.2 要时刻注意易混淆的操作符。</a></li>
            <li><a href="#原则63-必须了解编译系统的内存分配方式特别是编译系统对不同类型的变量的内存分配规则如局部变量在何处分配静态变量在何处分配等">原则6.3 必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等。</a></li>
            <li><a href="#原则64-不仅关注接口同样要关注实现">原则6.4 不仅关注接口，同样要关注实现。</a></li>
          </ol>
        </li>
        <li><a href="#规则-7">规则</a>
          <ol>
            <li><a href="#规则61-禁止内存操作越界坚持下列措施可以避免内存越界">规则6.1 禁止内存操作越界。坚持下列措施可以避免内存越界：</a></li>
            <li><a href="#规则62-禁止内存泄漏坚持下列措施可以避免内存泄漏">规则6.2 禁止内存泄漏。坚持下列措施可以避免内存泄漏：</a></li>
            <li><a href="#规则63-禁止引用已经释放的内存空间坚持下列措施可以避免引用已经释放的内存空间">规则6.3 禁止引用已经释放的内存空间。坚持下列措施可以避免引用已经释放的内存空间：</a></li>
            <li><a href="#规则64-编程时要防止差1错误">规则6.4 编程时，要防止差1错误。</a></li>
            <li><a href="#规则65-所有的if--else-if结构应该由else子句结束switch语句必须有default分支">规则6.5 所有的if &hellip; else if结构应该由else子句结束；switch语句必须有default分支。</a></li>
          </ol>
        </li>
        <li><a href="#建议-6">建议</a>
          <ol>
            <li><a href="#建议61-函数中分配的内存在函数退出之前要释放">建议6.1 函数中分配的内存，在函数退出之前要释放。</a></li>
            <li><a href="#建议62-if语句尽量加上else分支对没有else分支的语句要小心对待">建议6.2 if语句尽量加上else分支，对没有else分支的语句要小心对待。</a></li>
            <li><a href="#建议63-不要滥用goto语句">建议6.3 不要滥用goto语句。</a></li>
            <li><a href="#建议64-时刻注意表达式是否会上溢下溢">建议6.4 时刻注意表达式是否会上溢、下溢。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#程序效率">程序效率</a>
      <ol>
        <li><a href="#原则-5">原则</a>
          <ol>
            <li><a href="#原则71-在保证软件系统的正确性简洁可维护性可靠性及可测性的前提下提高代码效率">原则7.1 在保证软件系统的正确性、简洁、可维护性、可靠性及可测性的前提下，提高代码效率。</a></li>
            <li><a href="#原则72-通过对数据结构程序算法的优化来提高效率">原则7.2 通过对数据结构、程序算法的优化来提高效率。</a></li>
          </ol>
        </li>
        <li><a href="#建议-7">建议</a>
          <ol>
            <li><a href="#建议71-将不变条件的计算移到循环体外">建议7.1 将不变条件的计算移到循环体外。</a></li>
            <li><a href="#建议72-对于多维大数组避免来回跳跃式访问数组成员">建议7.2 对于多维大数组，避免来回跳跃式访问数组成员。</a></li>
            <li><a href="#建议73-创建资源库以减少分配对象的开销">建议7.3 创建资源库，以减少分配对象的开销。</a></li>
            <li><a href="#建议74-将多次被调用的-小函数改为inline函数或者宏实现">建议7.4 将多次被调用的 “小函数”改为inline函数或者宏实现。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#8-注释">8 注释</a>
      <ol>
        <li><a href="#原则-6">原则</a>
          <ol>
            <li><a href="#原则81-优秀的代码可以自我解释不通过注释即可轻易读懂">原则8.1 优秀的代码可以自我解释，不通过注释即可轻易读懂。</a></li>
            <li><a href="#原则82-注释的内容要清楚明了含义准确防止注释二义性">原则8.2 注释的内容要清楚、明了，含义准确，防止注释二义性。</a></li>
            <li><a href="#原则83-在代码的功能意图层次上进行注释即注释解释代码难以直接表达的意图而不是重复描述代码">原则8.3 在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码。</a></li>
          </ol>
        </li>
        <li><a href="#规则-8">规则</a>
          <ol>
            <li><a href="#规则81-修改代码时维护代码周边的所有注释以保证注释与代码的一致性不再有用的注释要删除">规则8.1 修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除。</a></li>
            <li><a href="#规则82-文件头部应进行注释注释必须列出版权说明版本号生成日期作者姓名工号内容功能说明与其它文件的关系修改日志等头文件的注释中还应有函数功能简要说明">规则8.2 文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。</a></li>
            <li><a href="#规则83-函数声明处注释描述函数功能性能及用法包括输入和输出参数函数返回值可重入的要求等定义处详细描述函数功能和实现要点如实现的简要步骤实现的理由设计约束等">规则8.3 函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、设计约束等。</a></li>
            <li><a href="#规则84-全局变量要有较详细的注释包括对其功能取值范围以及存取时注意事项等的说明">规则8.4 全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明。</a></li>
            <li><a href="#规则85-注释应放在其代码上方相邻位置或右方不可放在下面如放于上方则需与其上面的代码用空行隔开且与下方代码缩进相同">规则8.5 注释应放在其代码上方相邻位置或右方，不可放在下面。如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同。</a></li>
            <li><a href="#规则86-对于switch语句下的case语句如果因为特殊情况需要处理完一个case后进入下一个case处理必须在该case语句处理完下一个case语句前加上明确的注释">规则8.6 对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。</a></li>
            <li><a href="#规则87-避免在注释中使用缩写除非是业界通用或子系统内标准化的缩写">规则8.7 避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写。</a></li>
            <li><a href="#规则88-同一产品或项目组统一注释风格">规则8.8 同一产品或项目组统一注释风格。</a></li>
          </ol>
        </li>
        <li><a href="#建议-8">建议</a>
          <ol>
            <li><a href="#建议81-避免在一行代码或表达式的中间插入注释">建议8.1 避免在一行代码或表达式的中间插入注释。</a></li>
            <li><a href="#建议82-注释应考虑程序易读及外观排版的因素使用的语言若是中英兼有的建议多使用中文除非能用非常流利准确的英文表达对于有外籍员工的由产品确定注释语言">建议8.2 注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。对于有外籍员工的，由产品确定注释语言。</a></li>
            <li><a href="#建议83-文件头函数头全局常量变量类型定义的注释格式采用工具可识别的格式">建议8.3 文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#9-排版与格式">9 排版与格式</a>
      <ol>
        <li><a href="#规则-9">规则</a>
          <ol>
            <li><a href="#规则91-程序块采用缩进风格编写每级缩进为4个空格">规则9.1 程序块采用缩进风格编写，每级缩进为4个空格。</a></li>
            <li><a href="#规则92-相对独立的程序块之间变量说明之后必须加空行">规则9.2 相对独立的程序块之间、变量说明之后必须加空行。</a></li>
            <li><a href="#规则93-一条语句不能过长如不能拆分需要分行写一行到底多少字符换行比较合适产品可以自行确定换行时有如下建议">规则9.3 一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定。换行时有如下建议：</a></li>
            <li><a href="#规则94-多个短语句包括赋值语句不允许写在同一行内即一行只写一条语句">规则9.4 多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句。</a></li>
            <li><a href="#规则95-iffordowhilecaseswitchdefault等语句独占一行">规则9.5 if、for、do、while、case、switch、default等语句独占一行。</a></li>
            <li><a href="#规则96-在两个以上的关键字变量常量进行对等操作时它们之间的操作符之前之后或者前后要加空格进行非对等操作时如果是关系密切的立即操作符如后不应加空格">规则9.6 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－&gt;），后不应加空格。</a></li>
          </ol>
        </li>
        <li><a href="#建议-9">建议</a>
          <ol>
            <li><a href="#建议91-注释符包括与注释内容之间要用一个空格进行分隔">建议9.1 注释符（包括‘/’‘//’‘/’）与注释内容之间要用一个空格进行分隔。</a></li>
            <li><a href="#建议92-源程序中关系较为紧密的代码应尽可能相邻">建议9.2 源程序中关系较为紧密的代码应尽可能相邻。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#表达式">表达式</a>
      <ol>
        <li><a href="#规则-10">规则</a>
          <ol>
            <li><a href="#规则101-表达式的值在标准所允许的任何运算次序下都应该是相同的">规则10.1 表达式的值在标准所允许的任何运算次序下都应该是相同的。</a></li>
          </ol>
        </li>
        <li><a href="#建议-10">建议</a>
          <ol>
            <li><a href="#建议101-函数调用不要作为另一个函数的参数使用否则对于代码的调试阅读都不利">建议10.1 函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利。</a></li>
            <li><a href="#建议102-赋值语句不要写在if等语句中或者作为函数的参数使用">建议10.2 赋值语句不要写在if等语句中，或者作为函数的参数使用。</a></li>
            <li><a href="#建议103-用括号明确表达式的操作顺序避免过分依赖默认优先级">建议10.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级。</a></li>
            <li><a href="#建议104-赋值操作符不能使用在产生布尔值的表达式上">建议10.4 赋值操作符不能使用在产生布尔值的表达式上。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#11-代码编辑编译">11 代码编辑、编译</a>
      <ol>
        <li><a href="#规则-11">规则</a>
          <ol>
            <li><a href="#规则111-使用编译器的最高告警级别理解所有的告警通过修改代码而不是降低告警级别来消除所有告警">规则11.1 <strong>使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警。</strong></a></li>
            <li><a href="#规则112-在产品软件项目组中要统一编译开关静态检查选项以及相应告警清除策略">规则11.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略。</a></li>
            <li><a href="#规则113-本地构建工具如pc-lint的配置应该和持续集成的一致">规则11.3 本地构建工具（如PC-Lint）的配置应该和持续集成的一致。</a></li>
            <li><a href="#规则114-使用版本控制配置管理系统及时签入通过本地构建的代码确保签入的代码不会影响构建成功">规则11.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功。</a></li>
          </ol>
        </li>
        <li><a href="#建议-11">建议</a>
          <ol>
            <li><a href="#建议111-要小心地使用编辑器提供的块拷贝功能编程">建议11.1 要小心地使用编辑器提供的块拷贝功能编程。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#12-可测性">12 可测性</a>
      <ol>
        <li><a href="#原则-7">原则</a>
          <ol>
            <li><a href="#原则121-模块划分清晰接口明确耦合性小有明确输入和输出否则单元测试实施困难">原则12.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难。</a></li>
          </ol>
        </li>
        <li><a href="#规则-12">规则</a>
          <ol>
            <li><a href="#规则121-在同一项目组或产品组内要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数并且要有详细的说明">规则12.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。</a></li>
            <li><a href="#规则122-在同一项目组或产品组内调测打印的日志要有统一的规定">规则12.2 在同一项目组或产品组内，调测打印的日志要有统一的规定。</a></li>
            <li><a href="#规则123-使用断言记录内部假设">规则12.3 使用断言记录内部假设。</a></li>
            <li><a href="#规则124-不能用断言来检查运行时错误">规则12.4 不能用断言来检查运行时错误。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#13-安全性">13 安全性</a>
      <ol>
        <li><a href="#原则-8">原则</a>
          <ol>
            <li><a href="#原则131-对用户输入进行检查">原则13.1 对用户输入进行检查。</a></li>
          </ol>
        </li>
        <li><a href="#规则-13">规则</a>
          <ol>
            <li><a href="#规则131-确保所有字符串是以null结束">规则13.1 确保所有字符串是以NULL结束。</a></li>
            <li><a href="#规则132-不要将边界不明确的字符串写到固定长度的数组中">规则13.2 不要将边界不明确的字符串写到固定长度的数组中。</a></li>
            <li><a href="#规则133-避免整数溢出">规则13.3 避免整数溢出。</a></li>
            <li><a href="#规则134-避免符号错误">规则13.4 避免符号错误。</a></li>
            <li><a href="#规则135-避免截断错误">规则13.5 避免截断错误。</a></li>
            <li><a href="#规则136-确保格式字符和参数匹配">规则13.6 确保格式字符和参数匹配。</a></li>
            <li><a href="#规则137-避免将用户输入作为格式化字符串的一部分或者全部">规则13.7 避免将用户输入作为格式化字符串的一部分或者全部。</a></li>
            <li><a href="#规则138-避免使用strlen计算二进制数据的长度">规则13.8 避免使用strlen()计算二进制数据的长度。</a></li>
            <li><a href="#规则139-使用int类型变量来接受字符io函数的返回值">规则13.9 使用int类型变量来接受字符I/O函数的返回值。</a></li>
            <li><a href="#规则1310-防止命令注入">规则13.10 防止命令注入。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#14-单元测试">14 单元测试</a>
      <ol>
        <li><a href="#规则-14">规则</a>
          <ol>
            <li><a href="#规则141-在编写代码的同时或者编写代码前编写单元测试用例验证软件设计编码的正确"><strong>规则14.1 在编写代码的同时，或者编写代码前，编写单元测试用例验证软件设计/编码的正确。</strong></a></li>
          </ol>
        </li>
        <li><a href="#建议-12">建议</a>
          <ol>
            <li><a href="#建议141-单元测试关注单元的行为而不是实现避免针对函数的测试">建议14.1 单元测试关注单元的行为而不是实现，避免针对函数的测试。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#15-可移植性">15 可移植性</a>
      <ol>
        <li><a href="#规则-15">规则</a>
          <ol>
            <li><a href="#规则151-不能定义重定义或取消定义标准库平台中保留的标识符宏和函数">规则15.1 不能定义、重定义或取消定义标准库/平台中保留的标识符、宏和函数。</a></li>
          </ol>
        </li>
        <li><a href="#建议-13">建议</a>
          <ol>
            <li><a href="#建议151-不使用与硬件或操作系统关系很大的语句而使用建议的标准语句以提高软件的可移植性和可重用性">建议15.1 不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。</a></li>
            <li><a href="#建议152-除非为了满足特殊需求避免使用嵌入式汇编">建议15.2 除非为了满足特殊需求，避免使用嵌入式汇编。</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#16-业界编程规范">16 业界编程规范</a></li>
  </ol>
</nav>
        </div>
    </section>

            
        
    </aside>


            <main class="main full-width">
    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/">
                <img src="/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/background_hu4784715761958561598.jpg"
                        srcset="/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/background_hu4784715761958561598.jpg 800w, /p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/background_hu3085507343512068137.jpg 1600w"
                        width="800" 
                        height="566" 
                        loading="lazy"
                        alt="Featured image of post 华为嵌入式C语言代码简明规范" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/mcu/" style="background-color: #1e90ff; color: #ffffff;">
                MCU
            </a>
        
    </header>
    

    <div class="article-title-wrapper">
        <h2 class="article-title">
            <a href="/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/">华为嵌入式C语言代码简明规范</a>
        </h2>
    
        
    </div>

    
    
    
    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">2024-11-23</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    阅读时长: 33 分钟
                </time>
            </div>
        
    </footer>
    

    
</div>

</header>

    <section class="article-content">
    
    
    <h2 id="规范制订说明"><a href="#%e8%a7%84%e8%8c%83%e5%88%b6%e8%ae%a2%e8%af%b4%e6%98%8e" class="header-anchor"></a>规范制订说明
</h2><h3 id="前言"><a href="#%e5%89%8d%e8%a8%80" class="header-anchor"></a>前言
</h3><p>基于华为C语言编程规范 <a class="link" href="https://ilcc.gitbooks.io/wiki/content/StyleGuide/Huawei-C/index.html"  target="_blank" rel="noopener"
    >在线wiki文档</a></p>
<h3 id="代码总体原则"><a href="#%e4%bb%a3%e7%a0%81%e6%80%bb%e4%bd%93%e5%8e%9f%e5%88%99" class="header-anchor"></a>代码总体原则
</h3><h4 id="清晰第一"><a href="#%e6%b8%85%e6%99%b0%e7%ac%ac%e4%b8%80" class="header-anchor"></a>清晰第一
</h4><p><strong>代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化</strong></p>
<ul>
<li>优秀的代码可以自我解释（以我的水平可能做到比较难）</li>
<li>常写注释，并且注释写的清晰</li>
</ul>
<h4 id="简洁为美"><a href="#%e7%ae%80%e6%b4%81%e4%b8%ba%e7%be%8e" class="header-anchor"></a>简洁为美
</h4><p><strong>写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。</strong></p>
<p><strong>如果重构/修改其他风格的代码时，比较明智的做法是根据现有代码的现有风格继续编写代码，或者使用格式转换工具进行转换成公司内部风格。</strong></p>
<h3 id="术语"><a href="#%e6%9c%af%e8%af%ad" class="header-anchor"></a>术语
</h3><blockquote>
<p>原则：编程时必须坚持的指导思想。</p>
<p>规则：编程时强制必须遵守的约定。</p>
<p>建议：编程时必须加以考虑的约定。</p>
<p>说明：对此原则/规则/建议进行必要的解释。</p>
<p>示例：对此原则/规则/建议从正、反两个方面给出例子。</p>
<p>延伸阅读材料：建议进一步阅读的参考材料。</p>
</blockquote>
<h2 id="头文件"><a href="#%e5%a4%b4%e6%96%87%e4%bb%b6" class="header-anchor"></a>头文件
</h2><p><strong>不合理的头文件布局是编译时间过长的根因，不合理的头文件实际上不合理的设计。</strong></p>
<p>如果引入了新的依赖，则一旦被依赖的头文件修改，任何直接和间接依赖其头文件的代码都会被重新编译。</p>
<h3 id="原则"><a href="#%e5%8e%9f%e5%88%99" class="header-anchor"></a>原则
</h3><h4 id="原则11-头文件中适合放置接口的声明不适合放置实现"><a href="#%e5%8e%9f%e5%88%9911-%e5%a4%b4%e6%96%87%e4%bb%b6%e4%b8%ad%e9%80%82%e5%90%88%e6%94%be%e7%bd%ae%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%a3%b0%e6%98%8e%e4%b8%8d%e9%80%82%e5%90%88%e6%94%be%e7%bd%ae%e5%ae%9e%e7%8e%b0" class="header-anchor"></a>原则1.1 头文件中适合放置接口的声明，不适合放置实现
</h4><p>头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。</p>
<ul>
<li>内部使用的函数（相当于类的私有方法）声明不应放在头文件中</li>
<li>内部使用的宏、枚举、结构定义不应放入头文件中。</li>
<li>变量定义不应放在头文件中，应放在.c文件中。</li>
</ul>
<p>否则多次依赖会重复定义</p>
<ul>
<li>变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。</li>
</ul>
<h4 id="原则12-头文件应当职责单一"><a href="#%e5%8e%9f%e5%88%9912-%e5%a4%b4%e6%96%87%e4%bb%b6%e5%ba%94%e5%bd%93%e8%81%8c%e8%b4%a3%e5%8d%95%e4%b8%80" class="header-anchor"></a>原则1.2 头文件应当职责单一。
</h4><h4 id="原则13-头文件应向稳定的方向包含"><a href="#%e5%8e%9f%e5%88%9913-%e5%a4%b4%e6%96%87%e4%bb%b6%e5%ba%94%e5%90%91%e7%a8%b3%e5%ae%9a%e7%9a%84%e6%96%b9%e5%90%91%e5%8c%85%e5%90%ab" class="header-anchor"></a>原则1.3 头文件应向稳定的方向包含。
</h4><p>说明：头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。</p>
<h3 id="规则"><a href="#%e8%a7%84%e5%88%99" class="header-anchor"></a>规则
</h3><h4 id="规则11-每一个c文件应有一个同名h文件用于声明需要对外公开的接口"><a href="#%e8%a7%84%e5%88%9911-%e6%af%8f%e4%b8%80%e4%b8%aac%e6%96%87%e4%bb%b6%e5%ba%94%e6%9c%89%e4%b8%80%e4%b8%aa%e5%90%8c%e5%90%8dh%e6%96%87%e4%bb%b6%e7%94%a8%e4%ba%8e%e5%a3%b0%e6%98%8e%e9%9c%80%e8%a6%81%e5%af%b9%e5%a4%96%e5%85%ac%e5%bc%80%e7%9a%84%e6%8e%a5%e5%8f%a3" class="header-anchor"></a>规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。
</h4><p>说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。</p>
<h4 id="规则12-禁止头文件循环依赖"><a href="#%e8%a7%84%e5%88%9912-%e7%a6%81%e6%ad%a2%e5%a4%b4%e6%96%87%e4%bb%b6%e5%be%aa%e7%8e%af%e4%be%9d%e8%b5%96" class="header-anchor"></a>规则1.2 禁止头文件循环依赖
</h4><p>任何一个头文件的改变都会使得循环中的所有头文件重新编译</p>
<h4 id="规则13-ch文件禁止包含用不到的头文件"><a href="#%e8%a7%84%e5%88%9913-ch%e6%96%87%e4%bb%b6%e7%a6%81%e6%ad%a2%e5%8c%85%e5%90%ab%e7%94%a8%e4%b8%8d%e5%88%b0%e7%9a%84%e5%a4%b4%e6%96%87%e4%bb%b6" class="header-anchor"></a>规则1.3 .c/.h文件禁止包含用不到的头文件。
</h4><h4 id="规则14-头文件应当自包含"><a href="#%e8%a7%84%e5%88%9914-%e5%a4%b4%e6%96%87%e4%bb%b6%e5%ba%94%e5%bd%93%e8%87%aa%e5%8c%85%e5%90%ab" class="header-anchor"></a>规则1.4 头文件应当自包含。
</h4><blockquote>
<p>“头文件应当自包含”是指头文件应该包含自身所需的所有内容，而不依赖于其他头文件。这样的头文件通常被称为”自包含头文件”。下面解释一下这个概念的意义：</p>
<ol>
<li><strong>独立性和可移植性</strong>：自包含头文件使得头文件本身更加独立，不依赖于其他头文件。这样做有助于提高代码的可移植性，因为当你在其他项目或环境中使用这个头文件时，不需要担心它依赖的其他头文件是否可用。</li>
<li><strong>简化依赖关系</strong>：自包含头文件可以简化代码的依赖关系。如果一个头文件依赖于另一个头文件，而后者又依赖于其他头文件，这会形成复杂的依赖链。通过自包含头文件，可以减少这种依赖链，提高代码的可维护性。</li>
<li><strong>避免重复包含</strong>：自包含头文件通常会包含预处理器指令来避免重复包含。这样可以确保在包含相同头文件多次时不会导致重复定义的问题。</li>
<li><strong>提高效率</strong>：自包含头文件可以减少预处理器的工作量，因为它们不需要解析其他头文件的内容。这有助于提高编译效率。</li>
</ol>
</blockquote>
<h4 id="规则15-总是编写内部include保护符define-保护"><a href="#%e8%a7%84%e5%88%9915-%e6%80%bb%e6%98%af%e7%bc%96%e5%86%99%e5%86%85%e9%83%a8include%e4%bf%9d%e6%8a%a4%e7%ac%a6define-%e4%bf%9d%e6%8a%a4" class="header-anchor"></a>规则1.5 总是编写内部#include保护符（#define 保护）。
</h4><p>所有头文件都应当使用#define 防止头文件被多重包含，命名格式为<code>FILENAME_H</code>，为了保证唯一性，更好的命名是<code>PROJECTNAME_PATH_FILENAME_H</code>。</p>
<h4 id="规则16-禁止在头文件中定义变量"><a href="#%e8%a7%84%e5%88%9916-%e7%a6%81%e6%ad%a2%e5%9c%a8%e5%a4%b4%e6%96%87%e4%bb%b6%e4%b8%ad%e5%ae%9a%e4%b9%89%e5%8f%98%e9%87%8f" class="header-anchor"></a>规则1.6 禁止在头文件中定义变量。
</h4><p>说明：在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。</p>
<h4 id="规则17-只能通过包含头文件的方式使用其他c提供的接口禁止在c中通过extern的方式使用外部函数接口变量"><a href="#%e8%a7%84%e5%88%9917-%e5%8f%aa%e8%83%bd%e9%80%9a%e8%bf%87%e5%8c%85%e5%90%ab%e5%a4%b4%e6%96%87%e4%bb%b6%e7%9a%84%e6%96%b9%e5%bc%8f%e4%bd%bf%e7%94%a8%e5%85%b6%e4%bb%96c%e6%8f%90%e4%be%9b%e7%9a%84%e6%8e%a5%e5%8f%a3%e7%a6%81%e6%ad%a2%e5%9c%a8c%e4%b8%ad%e9%80%9a%e8%bf%87extern%e7%9a%84%e6%96%b9%e5%bc%8f%e4%bd%bf%e7%94%a8%e5%a4%96%e9%83%a8%e5%87%bd%e6%95%b0%e6%8e%a5%e5%8f%a3%e5%8f%98%e9%87%8f" class="header-anchor"></a>规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。
</h4><h4 id="规则18-禁止在extern-c中包含头文件"><a href="#%e8%a7%84%e5%88%9918-%e7%a6%81%e6%ad%a2%e5%9c%a8extern-c%e4%b8%ad%e5%8c%85%e5%90%ab%e5%a4%b4%e6%96%87%e4%bb%b6" class="header-anchor"></a>规则1.8 禁止在extern “C”中包含头文件。
</h4><blockquote>
<p><code>extern &quot;C&quot;</code> 是用于在 C++ 中声明 C 函数时的一种语法。它告诉编译器这些函数按照 C 语言的约定进行链接。</p>
<p>在 C++ 中，函数名的重载、名称修饰（name mangling）等特性会导致函数名在编译后被修改，这样的函数名在链接时可能无法与 C 代码中的函数名匹配。为了解决这个问题，C++ 提供了 <code>extern &quot;C&quot;</code>，它告诉编译器不要对函数名进行 C++ 风格的名称修饰，而是按照 C 语言的规则进行链接。</p>
</blockquote>
<h2 id="函数"><a href="#%e5%87%bd%e6%95%b0" class="header-anchor"></a>函数
</h2><p>函数设计的精髓：编写整洁函数，同时把代码有效组织起来。</p>
<p>整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。</p>
<p>代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。</p>
<h3 id="原则-1"><a href="#%e5%8e%9f%e5%88%99-1" class="header-anchor"></a>原则
</h3><h4 id="原则21-一个函数仅完成一件功能"><a href="#%e5%8e%9f%e5%88%9921-%e4%b8%80%e4%b8%aa%e5%87%bd%e6%95%b0%e4%bb%85%e5%ae%8c%e6%88%90%e4%b8%80%e4%bb%b6%e5%8a%9f%e8%83%bd" class="header-anchor"></a>原则2.1 一个函数仅完成一件功能。
</h4><p>说明：一个函数实现多个功能给开发、使用、维护都带来很大的困难。</p>
<p>将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。</p>
<h4 id="原则22-重复代码应该尽可能提炼成函数"><a href="#%e5%8e%9f%e5%88%9922-%e9%87%8d%e5%a4%8d%e4%bb%a3%e7%a0%81%e5%ba%94%e8%af%a5%e5%b0%bd%e5%8f%af%e8%83%bd%e6%8f%90%e7%82%bc%e6%88%90%e5%87%bd%e6%95%b0" class="header-anchor"></a>原则2.2 重复代码应该尽可能提炼成函数
</h4><p>说明：重复代码提炼成函数可以带来维护成本的降低。</p>
<p>可以使用代码重复度检查工具</p>
<h3 id="规则-1"><a href="#%e8%a7%84%e5%88%99-1" class="header-anchor"></a>规则
</h3><h4 id="规则21-避免函数过长新增函数不超过50行非空非注释行"><a href="#%e8%a7%84%e5%88%9921-%e9%81%bf%e5%85%8d%e5%87%bd%e6%95%b0%e8%bf%87%e9%95%bf%e6%96%b0%e5%a2%9e%e5%87%bd%e6%95%b0%e4%b8%8d%e8%b6%85%e8%bf%8750%e8%a1%8c%e9%9d%9e%e7%a9%ba%e9%9d%9e%e6%b3%a8%e9%87%8a%e8%a1%8c" class="header-anchor"></a>规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。
</h4><h4 id="规则22-避免函数的代码块嵌套过深新增函数的代码块嵌套不超过4层"><a href="#%e8%a7%84%e5%88%9922-%e9%81%bf%e5%85%8d%e5%87%bd%e6%95%b0%e7%9a%84%e4%bb%a3%e7%a0%81%e5%9d%97%e5%b5%8c%e5%a5%97%e8%bf%87%e6%b7%b1%e6%96%b0%e5%a2%9e%e5%87%bd%e6%95%b0%e7%9a%84%e4%bb%a3%e7%a0%81%e5%9d%97%e5%b5%8c%e5%a5%97%e4%b8%8d%e8%b6%85%e8%bf%874%e5%b1%82" class="header-anchor"></a>规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。
</h4><h5 id="减少代码嵌套层数的方法"><a href="#%e5%87%8f%e5%b0%91%e4%bb%a3%e7%a0%81%e5%b5%8c%e5%a5%97%e5%b1%82%e6%95%b0%e7%9a%84%e6%96%b9%e6%b3%95" class="header-anchor"></a>减少代码嵌套层数的方法
</h5><blockquote>
<ol>
<li><strong>使用函数抽象</strong>：将嵌套的代码块提取成独立的函数，以便于重用和理解。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="n">plaintext</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="n">python复制代码def</span> <span class="n">main_function</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="n">process_items</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="n">handle_condition_not_met</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">process_items</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="n">item_valid</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">           <span class="n">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">           <span class="n">handle_invalid_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">item_valid</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">condition</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理item</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">handle_invalid_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理无效item</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">handle_condition_not_met</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理条件未满足情况</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>使用早期返回</strong>：在函数内部，尽早返回结果，而不是在多层嵌套中处理。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-py" data-lang="py"><span class="line"><span class="cl"><span class="n">python</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">main_function</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="ow">not</span> <span class="n">condition</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="n">handle_condition_not_met</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">       <span class="k">return</span>
</span></span><span class="line"><span class="cl">   
</span></span><span class="line"><span class="cl">   <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="ow">not</span> <span class="n">item_valid</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">           <span class="n">handle_invalid_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">           <span class="k">continue</span>
</span></span><span class="line"><span class="cl">       <span class="n">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">item_valid</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">condition</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理item</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">handle_invalid_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理无效item</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">handle_condition_not_met</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理条件未满足情况</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><strong>使用异常处理</strong>：适用于处理特殊情况或错误的情况。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">python</span>
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">main_function</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">   <span class="k">try</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="k">if</span> <span class="n">condition</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">           <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">               <span class="n">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">       <span class="k">else</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">           <span class="k">raise</span> <span class="n">ConditionNotMetError</span>
</span></span><span class="line"><span class="cl">   <span class="k">except</span> <span class="n">ConditionNotMetError</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">       <span class="n">handle_condition_not_met</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">process_item</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="ow">not</span> <span class="n">item_valid</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">       <span class="k">raise</span> <span class="n">InvalidItemError</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理item</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">item_valid</span><span class="p">(</span><span class="n">item</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">return</span> <span class="n">item</span><span class="o">.</span><span class="n">condition</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">def</span> <span class="nf">handle_condition_not_met</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">   <span class="c1"># 处理条件未满足情况</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">class</span> <span class="nc">ConditionNotMetError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="o">&gt;</span><span class="k">class</span> <span class="nc">InvalidItemError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
</span></span><span class="line"><span class="cl">   <span class="k">pass</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这些方法可以帮助将嵌套降低到合理的水平，使代码更易读、更易维护。</p>
</blockquote>
<h4 id="规则23-可重入函数应避免使用共享变量若需要使用则应通过互斥手段关中断信号量对其加以保护"><a href="#%e8%a7%84%e5%88%9923-%e5%8f%af%e9%87%8d%e5%85%a5%e5%87%bd%e6%95%b0%e5%ba%94%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e5%85%b1%e4%ba%ab%e5%8f%98%e9%87%8f%e8%8b%a5%e9%9c%80%e8%a6%81%e4%bd%bf%e7%94%a8%e5%88%99%e5%ba%94%e9%80%9a%e8%bf%87%e4%ba%92%e6%96%a5%e6%89%8b%e6%ae%b5%e5%85%b3%e4%b8%ad%e6%96%ad%e4%bf%a1%e5%8f%b7%e9%87%8f%e5%af%b9%e5%85%b6%e5%8a%a0%e4%bb%a5%e4%bf%9d%e6%8a%a4" class="header-anchor"></a>规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。
</h4><p>可能用不到。</p>
<p>说明：可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。</p>
<h4 id="规则24-对参数的合法性检查由调用者负责还是由接口函数负责应在项目组模块内应统一规定缺省由调用者负责"><a href="#%e8%a7%84%e5%88%9924-%e5%af%b9%e5%8f%82%e6%95%b0%e7%9a%84%e5%90%88%e6%b3%95%e6%80%a7%e6%a3%80%e6%9f%a5%e7%94%b1%e8%b0%83%e7%94%a8%e8%80%85%e8%b4%9f%e8%b4%a3%e8%bf%98%e6%98%af%e7%94%b1%e6%8e%a5%e5%8f%a3%e5%87%bd%e6%95%b0%e8%b4%9f%e8%b4%a3%e5%ba%94%e5%9c%a8%e9%a1%b9%e7%9b%ae%e7%bb%84%e6%a8%a1%e5%9d%97%e5%86%85%e5%ba%94%e7%bb%9f%e4%b8%80%e8%a7%84%e5%ae%9a%e7%bc%ba%e7%9c%81%e7%94%b1%e8%b0%83%e7%94%a8%e8%80%85%e8%b4%9f%e8%b4%a3" class="header-anchor"></a>规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。
</h4><h4 id="规则25-对函数的错误返回码要全面处理"><a href="#%e8%a7%84%e5%88%9925-%e5%af%b9%e5%87%bd%e6%95%b0%e7%9a%84%e9%94%99%e8%af%af%e8%bf%94%e5%9b%9e%e7%a0%81%e8%a6%81%e5%85%a8%e9%9d%a2%e5%a4%84%e7%90%86" class="header-anchor"></a>规则2.5 对函数的错误返回码要全面处理。
</h4><h4 id="规则26-设计高扇入合理扇出小于7的函数"><a href="#%e8%a7%84%e5%88%9926-%e8%ae%be%e8%ae%a1%e9%ab%98%e6%89%87%e5%85%a5%e5%90%88%e7%90%86%e6%89%87%e5%87%ba%e5%b0%8f%e4%ba%8e7%e7%9a%84%e5%87%bd%e6%95%b0" class="header-anchor"></a>规则2.6 设计高扇入，合理扇出（小于7）的函数。
</h4><p>说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。</p>
<p>建议2.1 函数不变参数使用const。</p>
<p>建议2.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用。</p>
<p>建议2.4 函数的参数个数不超过5个。</p>
<p>建议2.5 除打印类函数外，不要使用可变长参函数。</p>
<h2 id="标识符命名与定义"><a href="#%e6%a0%87%e8%af%86%e7%ac%a6%e5%91%bd%e5%90%8d%e4%b8%8e%e5%ae%9a%e4%b9%89" class="header-anchor"></a>标识符命名与定义
</h2><p><strong>通用命名规则</strong></p>
<ol>
<li>
<p>unix like风格</p>
<p>单词用小写字母，每个单词直接用下划线‘_’分割，例如text_mutex，kernel_text_address。</p>
</li>
<li>
<p>Windows风格</p>
<p>大小写字母混用，单词连在一起，每个单词首字母大写</p>
</li>
<li>
<p>匈牙利命名法</p>
<p>匈牙利命名主要包括三个部分：基本类型、一个或更多的前缀、一个限定词。</p>
</li>
</ol>
<h3 id="原则-2"><a href="#%e5%8e%9f%e5%88%99-2" class="header-anchor"></a>原则
</h3><h4 id="原则31标识符的命名要清晰明了有明确含义同时使用完整的单词或大家基本可以理解的缩写避免使人产生误解"><a href="#%e5%8e%9f%e5%88%9931%e6%a0%87%e8%af%86%e7%ac%a6%e7%9a%84%e5%91%bd%e5%90%8d%e8%a6%81%e6%b8%85%e6%99%b0%e6%98%8e%e4%ba%86%e6%9c%89%e6%98%8e%e7%a1%ae%e5%90%ab%e4%b9%89%e5%90%8c%e6%97%b6%e4%bd%bf%e7%94%a8%e5%ae%8c%e6%95%b4%e7%9a%84%e5%8d%95%e8%af%8d%e6%88%96%e5%a4%a7%e5%ae%b6%e5%9f%ba%e6%9c%ac%e5%8f%af%e4%bb%a5%e7%90%86%e8%a7%a3%e7%9a%84%e7%bc%a9%e5%86%99%e9%81%bf%e5%85%8d%e4%bd%bf%e4%ba%ba%e4%ba%a7%e7%94%9f%e8%af%af%e8%a7%a3" class="header-anchor"></a>原则3.1标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。
</h4><h4 id="原则32-除了常见的通用缩写以外不使用单词缩写不得使用汉语拼音"><a href="#%e5%8e%9f%e5%88%9932-%e9%99%a4%e4%ba%86%e5%b8%b8%e8%a7%81%e7%9a%84%e9%80%9a%e7%94%a8%e7%bc%a9%e5%86%99%e4%bb%a5%e5%a4%96%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%8d%95%e8%af%8d%e7%bc%a9%e5%86%99%e4%b8%8d%e5%be%97%e4%bd%bf%e7%94%a8%e6%b1%89%e8%af%ad%e6%8b%bc%e9%9f%b3" class="header-anchor"></a>原则3.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。
</h4><p>示例：一些常见可以缩写的例子：</p>
<ul>
<li>argument 可缩写为 arg</li>
<li>buffer 可缩写为 buff</li>
<li>clock 可缩写为 clk</li>
<li>command 可缩写为 cmd</li>
<li>compare 可缩写为 cmp</li>
<li>configuration 可缩写为 cfg</li>
<li>device 可缩写为 dev</li>
<li>error 可缩写为 err</li>
<li>hexadecimal 可缩写为 hex</li>
<li>increment 可缩写为 inc</li>
<li>initialize 可缩写为 init</li>
<li>maximum 可缩写为 max</li>
<li>message 可缩写为 msg</li>
<li>minimum 可缩写为 min</li>
<li>parameter 可缩写为 para</li>
<li>previous 可缩写为 prev</li>
<li>register 可缩写为 reg</li>
<li>semaphore 可缩写为 sem</li>
<li>statistic 可缩写为 stat</li>
<li>synchronize 可缩写为 sync</li>
<li>temp 可缩写为 tmp</li>
</ul>
<h3 id="规则-2"><a href="#%e8%a7%84%e5%88%99-2" class="header-anchor"></a>规则
</h3><h4 id="规则31-产品项目组内部应保持统一的命名风格"><a href="#%e8%a7%84%e5%88%9931-%e4%ba%a7%e5%93%81%e9%a1%b9%e7%9b%ae%e7%bb%84%e5%86%85%e9%83%a8%e5%ba%94%e4%bf%9d%e6%8c%81%e7%bb%9f%e4%b8%80%e7%9a%84%e5%91%bd%e5%90%8d%e9%a3%8e%e6%a0%bc" class="header-anchor"></a>规则3.1 产品/项目组内部应保持统一的命名风格。
</h4><blockquote>
<p>示例：</p>
<p>add/remove begin/end create/destroy insert/delete first/last get/release increment/decrement put/get add/delete lock/unlock open/close min/max old/new start/stop next/previous source/target show/hide send/receive source/destination copy/paste up/down</p>
</blockquote>
<h3 id="建议"><a href="#%e5%bb%ba%e8%ae%ae" class="header-anchor"></a>建议
</h3><h4 id="建议32-尽量避免名字中出现数字编号除非逻辑上的确需要编号"><a href="#%e5%bb%ba%e8%ae%ae32-%e5%b0%bd%e9%87%8f%e9%81%bf%e5%85%8d%e5%90%8d%e5%ad%97%e4%b8%ad%e5%87%ba%e7%8e%b0%e6%95%b0%e5%ad%97%e7%bc%96%e5%8f%b7%e9%99%a4%e9%9d%9e%e9%80%bb%e8%be%91%e4%b8%8a%e7%9a%84%e7%a1%ae%e9%9c%80%e8%a6%81%e7%bc%96%e5%8f%b7" class="header-anchor"></a>建议3.2 尽量避免名字中出现数字编号，除非逻辑上的确需要编号。
</h4><h4 id="建议33-标识符前不应添加模块项目产品部门的名称作为前缀"><a href="#%e5%bb%ba%e8%ae%ae33-%e6%a0%87%e8%af%86%e7%ac%a6%e5%89%8d%e4%b8%8d%e5%ba%94%e6%b7%bb%e5%8a%a0%e6%a8%a1%e5%9d%97%e9%a1%b9%e7%9b%ae%e4%ba%a7%e5%93%81%e9%83%a8%e9%97%a8%e7%9a%84%e5%90%8d%e7%a7%b0%e4%bd%9c%e4%b8%ba%e5%89%8d%e7%bc%80" class="header-anchor"></a>建议3.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀。
</h4><h4 id="建议34-平台驱动等适配代码的标识符命名风格保持和平台驱动一致"><a href="#%e5%bb%ba%e8%ae%ae34-%e5%b9%b3%e5%8f%b0%e9%a9%b1%e5%8a%a8%e7%ad%89%e9%80%82%e9%85%8d%e4%bb%a3%e7%a0%81%e7%9a%84%e6%a0%87%e8%af%86%e7%ac%a6%e5%91%bd%e5%90%8d%e9%a3%8e%e6%a0%bc%e4%bf%9d%e6%8c%81%e5%92%8c%e5%b9%b3%e5%8f%b0%e9%a9%b1%e5%8a%a8%e4%b8%80%e8%87%b4" class="header-anchor"></a>建议3.4 平台/驱动等适配代码的标识符命名风格保持和平台/驱动一致。
</h4><h2 id="文件命名规则"><a href="#%e6%96%87%e4%bb%b6%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99" class="header-anchor"></a>文件命名规则
</h2><h3 id="建议-1"><a href="#%e5%bb%ba%e8%ae%ae-1" class="header-anchor"></a>建议
</h3><h4 id="建议36-文件命名统一采用小写字符"><a href="#%e5%bb%ba%e8%ae%ae36-%e6%96%87%e4%bb%b6%e5%91%bd%e5%90%8d%e7%bb%9f%e4%b8%80%e9%87%87%e7%94%a8%e5%b0%8f%e5%86%99%e5%ad%97%e7%ac%a6" class="header-anchor"></a>建议3.6 文件命名统一采用小写字符。
</h4><h2 id="变量命名规则"><a href="#%e5%8f%98%e9%87%8f%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99" class="header-anchor"></a>变量命名规则
</h2><h3 id="规则-3"><a href="#%e8%a7%84%e5%88%99-3" class="header-anchor"></a>规则
</h3><h4 id="规则32-全局变量应增加g_前缀"><a href="#%e8%a7%84%e5%88%9932-%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%ba%94%e5%a2%9e%e5%8a%a0g_%e5%89%8d%e7%bc%80" class="header-anchor"></a>规则3.2 全局变量应增加“g_”前缀。
</h4><h4 id="规则33-静态变量应增加s_前缀"><a href="#%e8%a7%84%e5%88%9933-%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e5%ba%94%e5%a2%9e%e5%8a%a0s_%e5%89%8d%e7%bc%80" class="header-anchor"></a>规则3.3 静态变量应增加“s_”前缀。
</h4><h4 id="规则34-禁止使用单字节命名变量但允许定义ijk作为局部循环变量"><a href="#%e8%a7%84%e5%88%9934-%e7%a6%81%e6%ad%a2%e4%bd%bf%e7%94%a8%e5%8d%95%e5%ad%97%e8%8a%82%e5%91%bd%e5%90%8d%e5%8f%98%e9%87%8f%e4%bd%86%e5%85%81%e8%ae%b8%e5%ae%9a%e4%b9%89ijk%e4%bd%9c%e4%b8%ba%e5%b1%80%e9%83%a8%e5%be%aa%e7%8e%af%e5%8f%98%e9%87%8f" class="header-anchor"></a>规则3.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。
</h4><h3 id="建议-2"><a href="#%e5%bb%ba%e8%ae%ae-2" class="header-anchor"></a>建议
</h3><h4 id="建议37-不建议使用匈牙利命名法"><a href="#%e5%bb%ba%e8%ae%ae37-%e4%b8%8d%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a8%e5%8c%88%e7%89%99%e5%88%a9%e5%91%bd%e5%90%8d%e6%b3%95" class="header-anchor"></a>建议3.7 不建议使用匈牙利命名法。
</h4><h4 id="建议38-使用名词或者形容词名词方式命名变量"><a href="#%e5%bb%ba%e8%ae%ae38-%e4%bd%bf%e7%94%a8%e5%90%8d%e8%af%8d%e6%88%96%e8%80%85%e5%bd%a2%e5%ae%b9%e8%af%8d%e5%90%8d%e8%af%8d%e6%96%b9%e5%bc%8f%e5%91%bd%e5%90%8d%e5%8f%98%e9%87%8f" class="header-anchor"></a>建议3.8 使用名词或者形容词＋名词方式命名变量。
</h4><h2 id="函数命名规则"><a href="#%e5%87%bd%e6%95%b0%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99" class="header-anchor"></a>函数命名规则
</h2><h3 id="建议-3"><a href="#%e5%bb%ba%e8%ae%ae-3" class="header-anchor"></a>建议
</h3><h4 id="建议39-函数命名应以函数要执行的动作命名一般采用动词或者动词名词的结构"><a href="#%e5%bb%ba%e8%ae%ae39-%e5%87%bd%e6%95%b0%e5%91%bd%e5%90%8d%e5%ba%94%e4%bb%a5%e5%87%bd%e6%95%b0%e8%a6%81%e6%89%a7%e8%a1%8c%e7%9a%84%e5%8a%a8%e4%bd%9c%e5%91%bd%e5%90%8d%e4%b8%80%e8%88%ac%e9%87%87%e7%94%a8%e5%8a%a8%e8%af%8d%e6%88%96%e8%80%85%e5%8a%a8%e8%af%8d%e5%90%8d%e8%af%8d%e7%9a%84%e7%bb%93%e6%9e%84" class="header-anchor"></a>建议3.9 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。
</h4><h2 id="宏的命名规则"><a href="#%e5%ae%8f%e7%9a%84%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99" class="header-anchor"></a>宏的命名规则
</h2><h3 id="规则-4"><a href="#%e8%a7%84%e5%88%99-4" class="header-anchor"></a>规则
</h3><h4 id="规则35对于数值或者字符串等等常量的定义建议采用全大写字母单词之间加下划线_的方式命名枚举同样建议使用此方式定义"><a href="#%e8%a7%84%e5%88%9935%e5%af%b9%e4%ba%8e%e6%95%b0%e5%80%bc%e6%88%96%e8%80%85%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%ad%89%e7%ad%89%e5%b8%b8%e9%87%8f%e7%9a%84%e5%ae%9a%e4%b9%89%e5%bb%ba%e8%ae%ae%e9%87%87%e7%94%a8%e5%85%a8%e5%a4%a7%e5%86%99%e5%ad%97%e6%af%8d%e5%8d%95%e8%af%8d%e4%b9%8b%e9%97%b4%e5%8a%a0%e4%b8%8b%e5%88%92%e7%ba%bf_%e7%9a%84%e6%96%b9%e5%bc%8f%e5%91%bd%e5%90%8d%e6%9e%9a%e4%b8%be%e5%90%8c%e6%a0%b7%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a8%e6%ad%a4%e6%96%b9%e5%bc%8f%e5%ae%9a%e4%b9%89" class="header-anchor"></a>规则3.5对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘_’的方式命名（枚举同样建议使用此方式定义）。
</h4><h4 id="规则36-除了头文件或编译开关等特殊标识定义宏定义不能使用下划线_开头和结尾"><a href="#%e8%a7%84%e5%88%9936-%e9%99%a4%e4%ba%86%e5%a4%b4%e6%96%87%e4%bb%b6%e6%88%96%e7%bc%96%e8%af%91%e5%bc%80%e5%85%b3%e7%ad%89%e7%89%b9%e6%ae%8a%e6%a0%87%e8%af%86%e5%ae%9a%e4%b9%89%e5%ae%8f%e5%ae%9a%e4%b9%89%e4%b8%8d%e8%83%bd%e4%bd%bf%e7%94%a8%e4%b8%8b%e5%88%92%e7%ba%bf_%e5%bc%80%e5%a4%b4%e5%92%8c%e7%bb%93%e5%b0%be" class="header-anchor"></a>规则3.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘_’开头和结尾。
</h4><h2 id="变量"><a href="#%e5%8f%98%e9%87%8f" class="header-anchor"></a>变量
</h2><h3 id="原则-3"><a href="#%e5%8e%9f%e5%88%99-3" class="header-anchor"></a>原则
</h3><h4 id="原则41-一个变量只有一个功能不能把一个变量用作多种用途"><a href="#%e5%8e%9f%e5%88%9941-%e4%b8%80%e4%b8%aa%e5%8f%98%e9%87%8f%e5%8f%aa%e6%9c%89%e4%b8%80%e4%b8%aa%e5%8a%9f%e8%83%bd%e4%b8%8d%e8%83%bd%e6%8a%8a%e4%b8%80%e4%b8%aa%e5%8f%98%e9%87%8f%e7%94%a8%e4%bd%9c%e5%a4%9a%e7%a7%8d%e7%94%a8%e9%80%94" class="header-anchor"></a>原则4.1 一个变量只有一个功能，不能把一个变量用作多种用途。
</h4><blockquote>
<p>我怎么感觉在某些情况下无妨啊，开多了变量会占用性能吧？</p>
<p>也就是说：重要性：代码的可读性、可维护性和减少错误&gt;性能消耗</p>
<p>下列答案基于<strong>chatGPT</strong></p>
<p>遵循“一个变量只有一个功能”的原则确实会增加一些变量的数量，但这通常不会显著增加系统开销，特别是在现代编程环境和硬件条件下。这是因为：</p>
<ol>
<li><strong>内存开销相对较小</strong>：
<ul>
<li>现代计算机的内存容量通常非常大，增加几个变量所占用的内存是非常小的。这种内存开销在绝大多数应用场景下可以忽略不计。</li>
</ul>
</li>
<li><strong>编译器优化</strong>：
<ul>
<li>现代编译器和解释器非常智能，它们可以优化代码，将不必要的变量删除或者合并，从而减少内存开销。例如，在优化编译过程中，编译器会尝试最小化变量的存储空间，并进行变量复用等优化操作。</li>
</ul>
</li>
<li><strong>代码可读性和维护性优先</strong>：
<ul>
<li>代码的可读性和可维护性在实际开发中比微小的性能优化更重要。可读性好的代码更容易被团队中的其他开发人员理解和维护，从而降低了开发和维护的成本。</li>
</ul>
</li>
<li><strong>开发效率和错误减少</strong>：
<ul>
<li>使用单一功能变量可以减少代码中的错误，使开发过程更加顺利。这种减少错误和提升开发效率的好处往往远远超过因为增加变量数量而带来的微小性能损失。</li>
</ul>
</li>
</ol>
<p><strong>示例分析</strong>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">python
</span></span><span class="line"><span class="cl"># 增加系统开销的担忧
</span></span><span class="line"><span class="cl">total_items = 10
</span></span><span class="line"><span class="cl">price = 5.99
</span></span><span class="line"><span class="cl">total_cost = total_items * price
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 不好的做法：减少变量数量
</span></span><span class="line"><span class="cl">x = 10
</span></span><span class="line"><span class="cl">x = 5.99
</span></span><span class="line"><span class="cl">x = x * x  # 这样做容易引入错误，也降低了代码的可读性
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"># 正确做法：使用多个变量，增加代码可读性
</span></span><span class="line"><span class="cl">total_items = 10
</span></span><span class="line"><span class="cl">price_per_item = 5.99
</span></span><span class="line"><span class="cl">total_cost = total_items * price_per_item
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这个示例中，尽管引入了多个变量，但它们使代码更容易理解和维护。变量名清晰地表达了它们的用途，减少了开发和调试中的潜在错误。</p>
<p><strong>总结</strong>：</p>
<p>遵循“一个变量只有一个功能”的原则，不仅不会显著增加系统开销，反而可以通过提升代码质量和开发效率，降低长远的开发和维护成本。因此，在大多数情况下，这种做法是非常值得的。实际开发中，尤其是在团队协作和大型项目中，应优先考虑代码的可读性和可维护性。</p>
</blockquote>
<h4 id="原则42-结构功能单一不要设计面面俱到的数据结构"><a href="#%e5%8e%9f%e5%88%9942-%e7%bb%93%e6%9e%84%e5%8a%9f%e8%83%bd%e5%8d%95%e4%b8%80%e4%b8%8d%e8%a6%81%e8%ae%be%e8%ae%a1%e9%9d%a2%e9%9d%a2%e4%bf%b1%e5%88%b0%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" class="header-anchor"></a>原则4.2 结构功能单一；不要设计面面俱到的数据结构。
</h4><h4 id="原则43-不用或者少用全局变量"><a href="#%e5%8e%9f%e5%88%9943-%e4%b8%8d%e7%94%a8%e6%88%96%e8%80%85%e5%b0%91%e7%94%a8%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f" class="header-anchor"></a>原则4.3 不用或者少用全局变量。
</h4><h3 id="规则-5"><a href="#%e8%a7%84%e5%88%99-5" class="header-anchor"></a>规则
</h3><h4 id="规则41-防止局部变量与全局变量同名"><a href="#%e8%a7%84%e5%88%9941-%e9%98%b2%e6%ad%a2%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e4%b8%8e%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e5%90%8c%e5%90%8d" class="header-anchor"></a>规则4.1 防止局部变量与全局变量同名。
</h4><h4 id="规则42-通讯过程中使用的结构必须注意字节序"><a href="#%e8%a7%84%e5%88%9942-%e9%80%9a%e8%ae%af%e8%bf%87%e7%a8%8b%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%9a%84%e7%bb%93%e6%9e%84%e5%bf%85%e9%a1%bb%e6%b3%a8%e6%84%8f%e5%ad%97%e8%8a%82%e5%ba%8f" class="header-anchor"></a>规则4.2 通讯过程中使用的结构，必须注意字节序。
</h4><blockquote>
<p>字节序的解释（基于chatGPT）</p>
<p>字节序（Byte Order）是指在计算机内存中存储多字节数据时，字节的排列顺序。不同计算机系统可能采用不同的字节序，主要有两种类型：大端序（Big-Endian）和小端序（Little-Endian）。</p>
<h5 id="大端序big-endian"><a href="#%e5%a4%a7%e7%ab%af%e5%ba%8fbig-endian" class="header-anchor"></a>大端序（Big-Endian）
</h5><ul>
<li>
<p><strong>定义</strong>：高位字节存储在低地址，低位字节存储在高地址。</p>
</li>
<li>
<p>示例</p>
<p>：假设有一个4字节（32位）的数值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">plaintext
</span></span><span class="line"><span class="cl">0x12345678
</span></span></code></pre></td></tr></table>
</div>
</div><p>。在大端序系统中，它的存储顺序如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">plaintext
</span></span><span class="line"><span class="cl">makefile复制代码地址:   0x00  0x01  0x02  0x03
</span></span><span class="line"><span class="cl">值:     0x12  0x34  0x56  0x78
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="小端序little-endian"><a href="#%e5%b0%8f%e7%ab%af%e5%ba%8flittle-endian" class="header-anchor"></a>小端序（Little-Endian）
</h5><ul>
<li>
<p><strong>定义</strong>：低位字节存储在低地址，高位字节存储在高地址。</p>
</li>
<li>
<p>示例</p>
<p>：同样的数值</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">plaintext
</span></span><span class="line"><span class="cl">0x12345678
</span></span></code></pre></td></tr></table>
</div>
</div><p>在小端序系统中的存储顺序如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">plaintext
</span></span><span class="line"><span class="cl">makefile复制代码地址:   0x00  0x01  0x02  0x03
</span></span><span class="line"><span class="cl">值:     0x78  0x56  0x34  0x12
</span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h5 id="为什么字节序很重要"><a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e5%ad%97%e8%8a%82%e5%ba%8f%e5%be%88%e9%87%8d%e8%a6%81" class="header-anchor"></a>为什么字节序很重要
</h5><p>在多字节数据传输或跨平台交互时，字节序的不同可能导致数据解释错误。例如，一个大端序系统发送数据到一个小端序系统，如果不做任何处理，小端序系统可能会错误地解读数据内容。</p>
<h5 id="字节序的处理"><a href="#%e5%ad%97%e8%8a%82%e5%ba%8f%e7%9a%84%e5%a4%84%e7%90%86" class="header-anchor"></a>字节序的处理
</h5><ol>
<li><strong>网络字节序</strong>：网络协议（如TCP/IP）通常规定使用大端序，这被称为网络字节序（Network Byte Order）。</li>
<li><strong>字节序转换函数</strong>：大多数编程语言提供了用于字节序转换的函数。例如，在C语言中，<code>htons</code>（Host TO Network Short）、<code>htonl</code>（Host TO Network Long）、<code>ntohs</code>（Network TO Host Short）、<code>ntohl</code>（Network TO Host Long）等函数用于在主机字节序和网络字节序之间进行转换。</li>
</ol>
<h5 id="示例代码"><a href="#%e7%a4%ba%e4%be%8b%e4%bb%a3%e7%a0%81" class="header-anchor"></a>示例代码
</h5><p><strong>C语言中的字节序处理</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="n">plaintext</span>
</span></span><span class="line"><span class="cl"><span class="n">c复制代码</span><span class="err">#</span><span class="n">include</span> <span class="o">&lt;</span><span class="n">stdio</span><span class="p">.</span><span class="n">h</span><span class="o">&gt;</span>
</span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp">#include</span> <span class="cpf">&lt;arpa/inet.h&gt;</span><span class="cp">
</span></span></span><span class="line"><span class="cl"><span class="cp"></span>
</span></span><span class="line"><span class="cl"><span class="kt">void</span> <span class="nf">print_bytes</span><span class="p">(</span><span class="kt">uint32_t</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">bytes</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">value</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;%02x &#34;</span><span class="p">,</span> <span class="n">bytes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">host_value</span> <span class="o">=</span> <span class="mh">0x12345678</span><span class="p">;</span> <span class="c1">// 主机字节序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="kt">uint32_t</span> <span class="n">network_value</span> <span class="o">=</span> <span class="nf">htonl</span><span class="p">(</span><span class="n">host_value</span><span class="p">);</span> <span class="c1">// 转换为网络字节序（大端序）
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Host byte order: &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">print_bytes</span><span class="p">(</span><span class="n">host_value</span><span class="p">);</span> <span class="c1">// 打印主机字节序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Network byte order: &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">print_bytes</span><span class="p">(</span><span class="n">network_value</span><span class="p">);</span> <span class="c1">// 打印网络字节序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="kt">uint32_t</span> <span class="n">converted_back</span> <span class="o">=</span> <span class="nf">ntohl</span><span class="p">(</span><span class="n">network_value</span><span class="p">);</span> <span class="c1">// 转换回主机字节序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nf">printf</span><span class="p">(</span><span class="s">&#34;Converted back to host byte order: &#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="nf">print_bytes</span><span class="p">(</span><span class="n">converted_back</span><span class="p">);</span> <span class="c1">// 打印转换回的主机字节序
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>输出</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">plaintext
</span></span><span class="line"><span class="cl">vbnet复制代码Host byte order: 78 56 34 12 
</span></span><span class="line"><span class="cl">Network byte order: 12 34 56 78 
</span></span><span class="line"><span class="cl">Converted back to host byte order: 78 56 34 12 
</span></span></code></pre></td></tr></table>
</div>
</div><h5 id="总结"><a href="#%e6%80%bb%e7%bb%93" class="header-anchor"></a>总结
</h5><p>字节序在计算机内存中存储多字节数据时非常重要。理解和处理字节序问题，特别是在跨平台或网络通信中，确保数据正确传输和解释是至关重要的。通过明确协议中的字节序和使用合适的字节序转换函数，可以避免数据传输中的错误。</p>
</blockquote>
<h4 id="规则43-严禁使用未经初始化的变量作为右值"><a href="#%e8%a7%84%e5%88%9943-%e4%b8%a5%e7%a6%81%e4%bd%bf%e7%94%a8%e6%9c%aa%e7%bb%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e7%9a%84%e5%8f%98%e9%87%8f%e4%bd%9c%e4%b8%ba%e5%8f%b3%e5%80%bc" class="header-anchor"></a>规则4.3 严禁使用未经初始化的变量作为右值。
</h4><h3 id="建议-4"><a href="#%e5%bb%ba%e8%ae%ae-4" class="header-anchor"></a>建议
</h3><h4 id="建议41-构造仅有一个模块或函数可以修改创建而其余有关模块或函数只访问的全局变量防止多个不同模块或函数都可以修改创建同一全局变量的现象"><a href="#%e5%bb%ba%e8%ae%ae41-%e6%9e%84%e9%80%a0%e4%bb%85%e6%9c%89%e4%b8%80%e4%b8%aa%e6%a8%a1%e5%9d%97%e6%88%96%e5%87%bd%e6%95%b0%e5%8f%af%e4%bb%a5%e4%bf%ae%e6%94%b9%e5%88%9b%e5%bb%ba%e8%80%8c%e5%85%b6%e4%bd%99%e6%9c%89%e5%85%b3%e6%a8%a1%e5%9d%97%e6%88%96%e5%87%bd%e6%95%b0%e5%8f%aa%e8%ae%bf%e9%97%ae%e7%9a%84%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e9%98%b2%e6%ad%a2%e5%a4%9a%e4%b8%aa%e4%b8%8d%e5%90%8c%e6%a8%a1%e5%9d%97%e6%88%96%e5%87%bd%e6%95%b0%e9%83%bd%e5%8f%af%e4%bb%a5%e4%bf%ae%e6%94%b9%e5%88%9b%e5%bb%ba%e5%90%8c%e4%b8%80%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e7%9a%84%e7%8e%b0%e8%b1%a1" class="header-anchor"></a>建议4.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。
</h4><h4 id="建议42-使用面向接口编程思想通过api访问数据如果本模块的数据需要对外部模块开放应提供接口函数来设置获取同时注意全局数据的访问互斥"><a href="#%e5%bb%ba%e8%ae%ae42-%e4%bd%bf%e7%94%a8%e9%9d%a2%e5%90%91%e6%8e%a5%e5%8f%a3%e7%bc%96%e7%a8%8b%e6%80%9d%e6%83%b3%e9%80%9a%e8%bf%87api%e8%ae%bf%e9%97%ae%e6%95%b0%e6%8d%ae%e5%a6%82%e6%9e%9c%e6%9c%ac%e6%a8%a1%e5%9d%97%e7%9a%84%e6%95%b0%e6%8d%ae%e9%9c%80%e8%a6%81%e5%af%b9%e5%a4%96%e9%83%a8%e6%a8%a1%e5%9d%97%e5%bc%80%e6%94%be%e5%ba%94%e6%8f%90%e4%be%9b%e6%8e%a5%e5%8f%a3%e5%87%bd%e6%95%b0%e6%9d%a5%e8%ae%be%e7%bd%ae%e8%8e%b7%e5%8f%96%e5%90%8c%e6%97%b6%e6%b3%a8%e6%84%8f%e5%85%a8%e5%b1%80%e6%95%b0%e6%8d%ae%e7%9a%84%e8%ae%bf%e9%97%ae%e4%ba%92%e6%96%a5" class="header-anchor"></a>建议4.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。
</h4><h4 id="建议43-在首次使用前初始化变量初始化的地方离使用的地方越近越好建议43-在首次使用前初始化变量初始化的地方离使用的地方越近越好"><a href="#%e5%bb%ba%e8%ae%ae43-%e5%9c%a8%e9%a6%96%e6%ac%a1%e4%bd%bf%e7%94%a8%e5%89%8d%e5%88%9d%e5%a7%8b%e5%8c%96%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e7%9a%84%e5%9c%b0%e6%96%b9%e7%a6%bb%e4%bd%bf%e7%94%a8%e7%9a%84%e5%9c%b0%e6%96%b9%e8%b6%8a%e8%bf%91%e8%b6%8a%e5%a5%bd%e5%bb%ba%e8%ae%ae43-%e5%9c%a8%e9%a6%96%e6%ac%a1%e4%bd%bf%e7%94%a8%e5%89%8d%e5%88%9d%e5%a7%8b%e5%8c%96%e5%8f%98%e9%87%8f%e5%88%9d%e5%a7%8b%e5%8c%96%e7%9a%84%e5%9c%b0%e6%96%b9%e7%a6%bb%e4%bd%bf%e7%94%a8%e7%9a%84%e5%9c%b0%e6%96%b9%e8%b6%8a%e8%bf%91%e8%b6%8a%e5%a5%bd" class="header-anchor"></a>建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。
</h4><h4 id="建议44-明确全局变量的初始化顺序避免跨模块的初始化依赖"><a href="#%e5%bb%ba%e8%ae%ae44-%e6%98%8e%e7%a1%ae%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e9%a1%ba%e5%ba%8f%e9%81%bf%e5%85%8d%e8%b7%a8%e6%a8%a1%e5%9d%97%e7%9a%84%e5%88%9d%e5%a7%8b%e5%8c%96%e4%be%9d%e8%b5%96" class="header-anchor"></a>建议4.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖。
</h4><h4 id="建议45-尽量减少没有必要的数据类型默认转换与强制转换"><a href="#%e5%bb%ba%e8%ae%ae45-%e5%b0%bd%e9%87%8f%e5%87%8f%e5%b0%91%e6%b2%a1%e6%9c%89%e5%bf%85%e8%a6%81%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e9%bb%98%e8%ae%a4%e8%bd%ac%e6%8d%a2%e4%b8%8e%e5%bc%ba%e5%88%b6%e8%bd%ac%e6%8d%a2" class="header-anchor"></a>建议4.5 尽量减少没有必要的数据类型默认转换与强制转换。
</h4><h2 id="宏常量"><a href="#%e5%ae%8f%e5%b8%b8%e9%87%8f" class="header-anchor"></a>宏、常量
</h2><h3 id="规则-6"><a href="#%e8%a7%84%e5%88%99-6" class="header-anchor"></a>规则
</h3><h4 id="规则51-用宏定义表达式时要使用完备的括号"><a href="#%e8%a7%84%e5%88%9951-%e7%94%a8%e5%ae%8f%e5%ae%9a%e4%b9%89%e8%a1%a8%e8%be%be%e5%bc%8f%e6%97%b6%e8%a6%81%e4%bd%bf%e7%94%a8%e5%ae%8c%e5%a4%87%e7%9a%84%e6%8b%ac%e5%8f%b7" class="header-anchor"></a>规则5.1 用宏定义表达式时，要使用完备的括号。
</h4><h4 id="规则52-将宏所定义的多条表达式放在大括号中"><a href="#%e8%a7%84%e5%88%9952-%e5%b0%86%e5%ae%8f%e6%89%80%e5%ae%9a%e4%b9%89%e7%9a%84%e5%a4%9a%e6%9d%a1%e8%a1%a8%e8%be%be%e5%bc%8f%e6%94%be%e5%9c%a8%e5%a4%a7%e6%8b%ac%e5%8f%b7%e4%b8%ad" class="header-anchor"></a>规则5.2 将宏所定义的多条表达式放在大括号中。
</h4><h4 id="规则53-使用宏时不允许参数发生变化"><a href="#%e8%a7%84%e5%88%9953-%e4%bd%bf%e7%94%a8%e5%ae%8f%e6%97%b6%e4%b8%8d%e5%85%81%e8%ae%b8%e5%8f%82%e6%95%b0%e5%8f%91%e7%94%9f%e5%8f%98%e5%8c%96" class="header-anchor"></a>规则5.3 使用宏时，不允许参数发生变化。
</h4><h4 id="规则54-不允许直接使用魔鬼数字"><a href="#%e8%a7%84%e5%88%9954-%e4%b8%8d%e5%85%81%e8%ae%b8%e7%9b%b4%e6%8e%a5%e4%bd%bf%e7%94%a8%e9%ad%94%e9%ac%bc%e6%95%b0%e5%ad%97" class="header-anchor"></a>规则5.4 不允许直接使用魔鬼数字。
</h4><p>说明：使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。</p>
<h3 id="建议-5"><a href="#%e5%bb%ba%e8%ae%ae-5" class="header-anchor"></a>建议
</h3><h4 id="建议51-除非必要应尽可能使用函数代替宏"><a href="#%e5%bb%ba%e8%ae%ae51-%e9%99%a4%e9%9d%9e%e5%bf%85%e8%a6%81%e5%ba%94%e5%b0%bd%e5%8f%af%e8%83%bd%e4%bd%bf%e7%94%a8%e5%87%bd%e6%95%b0%e4%bb%a3%e6%9b%bf%e5%ae%8f" class="header-anchor"></a>建议5.1 除非必要，应尽可能使用函数代替宏。
</h4><h4 id="建议52-常量建议使用const定义代替宏"><a href="#%e5%bb%ba%e8%ae%ae52-%e5%b8%b8%e9%87%8f%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a8const%e5%ae%9a%e4%b9%89%e4%bb%a3%e6%9b%bf%e5%ae%8f" class="header-anchor"></a>建议5.2 常量建议使用const定义代替宏。
</h4><h4 id="建议53-宏定义中尽量不使用returngotocontinuebreak等改变程序流程的语句"><a href="#%e5%bb%ba%e8%ae%ae53-%e5%ae%8f%e5%ae%9a%e4%b9%89%e4%b8%ad%e5%b0%bd%e9%87%8f%e4%b8%8d%e4%bd%bf%e7%94%a8returngotocontinuebreak%e7%ad%89%e6%94%b9%e5%8f%98%e7%a8%8b%e5%ba%8f%e6%b5%81%e7%a8%8b%e7%9a%84%e8%af%ad%e5%8f%a5" class="header-anchor"></a>建议5.3 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。
</h4><h2 id="质量保证"><a href="#%e8%b4%a8%e9%87%8f%e4%bf%9d%e8%af%81" class="header-anchor"></a>质量保证
</h2><h3 id="原则-4"><a href="#%e5%8e%9f%e5%88%99-4" class="header-anchor"></a>原则
</h3><h4 id="原则61-代码质量保证优先原则性能并没有放在那么靠前的位置有些意外"><a href="#%e5%8e%9f%e5%88%9961-%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f%e4%bf%9d%e8%af%81%e4%bc%98%e5%85%88%e5%8e%9f%e5%88%99%e6%80%a7%e8%83%bd%e5%b9%b6%e6%b2%a1%e6%9c%89%e6%94%be%e5%9c%a8%e9%82%a3%e4%b9%88%e9%9d%a0%e5%89%8d%e7%9a%84%e4%bd%8d%e7%bd%ae%e6%9c%89%e4%ba%9b%e6%84%8f%e5%a4%96" class="header-anchor"></a>原则6.1 代码质量保证优先原则（性能并没有放在那么靠前的位置，有些意外！）
</h4><ul>
<li>正确性，指程序要实现设计要求的功能。</li>
<li>简洁性，指程序易于理解并且易于实现。</li>
<li>可维护性，指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力。</li>
<li>可靠性，指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率。</li>
<li>代码可测试性，指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力。</li>
<li>代码性能高效，指是尽可能少地占用系统资源，包括内存和执行时间。</li>
<li>可移植性，指为了在原来设计的特定环境之外运行，对系统进行修改的能力。</li>
<li>个人表达方式/个人方便性，指个人编程习惯。</li>
</ul>
<h4 id="原则62-要时刻注意易混淆的操作符"><a href="#%e5%8e%9f%e5%88%9962-%e8%a6%81%e6%97%b6%e5%88%bb%e6%b3%a8%e6%84%8f%e6%98%93%e6%b7%b7%e6%b7%86%e7%9a%84%e6%93%8d%e4%bd%9c%e7%ac%a6" class="header-anchor"></a>原则6.2 要时刻注意易混淆的操作符。
</h4><p>易混淆的操作符，如：赋值操作符“=” 逻辑操作符“==” 关系操作符“&lt;” 位操作符&quot;&laquo;&quot; 关系操作符“&gt;” 位操作符“&raquo;” 逻辑操作符“||” 位操作符&quot;|&quot; 逻辑操作符“&amp;&amp;” 位操作符&quot;&amp;&quot; 逻辑操作符&quot;!&quot; 位操作符“~”。
易用错的操作符，如：除操作符&quot;/&quot;、求余操作符&quot;%&quot;、自加、自减操作符“++”、“&ndash;”。</p>
<h4 id="原则63-必须了解编译系统的内存分配方式特别是编译系统对不同类型的变量的内存分配规则如局部变量在何处分配静态变量在何处分配等"><a href="#%e5%8e%9f%e5%88%9963-%e5%bf%85%e9%a1%bb%e4%ba%86%e8%a7%a3%e7%bc%96%e8%af%91%e7%b3%bb%e7%bb%9f%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e6%96%b9%e5%bc%8f%e7%89%b9%e5%88%ab%e6%98%af%e7%bc%96%e8%af%91%e7%b3%bb%e7%bb%9f%e5%af%b9%e4%b8%8d%e5%90%8c%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%8f%98%e9%87%8f%e7%9a%84%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e8%a7%84%e5%88%99%e5%a6%82%e5%b1%80%e9%83%a8%e5%8f%98%e9%87%8f%e5%9c%a8%e4%bd%95%e5%a4%84%e5%88%86%e9%85%8d%e9%9d%99%e6%80%81%e5%8f%98%e9%87%8f%e5%9c%a8%e4%bd%95%e5%a4%84%e5%88%86%e9%85%8d%e7%ad%89" class="header-anchor"></a>原则6.3 必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等。
</h4><h4 id="原则64-不仅关注接口同样要关注实现"><a href="#%e5%8e%9f%e5%88%9964-%e4%b8%8d%e4%bb%85%e5%85%b3%e6%b3%a8%e6%8e%a5%e5%8f%a3%e5%90%8c%e6%a0%b7%e8%a6%81%e5%85%b3%e6%b3%a8%e5%ae%9e%e7%8e%b0" class="header-anchor"></a>原则6.4 不仅关注接口，同样要关注实现。
</h4><h3 id="规则-7"><a href="#%e8%a7%84%e5%88%99-7" class="header-anchor"></a>规则
</h3><h4 id="规则61-禁止内存操作越界坚持下列措施可以避免内存越界"><a href="#%e8%a7%84%e5%88%9961-%e7%a6%81%e6%ad%a2%e5%86%85%e5%ad%98%e6%93%8d%e4%bd%9c%e8%b6%8a%e7%95%8c%e5%9d%9a%e6%8c%81%e4%b8%8b%e5%88%97%e6%8e%aa%e6%96%bd%e5%8f%af%e4%bb%a5%e9%81%bf%e5%85%8d%e5%86%85%e5%ad%98%e8%b6%8a%e7%95%8c" class="header-anchor"></a>规则6.1 禁止内存操作越界。坚持下列措施可以避免内存越界：
</h4><ul>
<li>数组的大小要考虑最大情况，避免数组分配空间不够。</li>
<li><strong>避免使用危险函数sprintf/vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数snprintf/strncpy/strncat/fgets代替。</strong></li>
<li>使用memcpy/memset时一定要确保长度不要越界</li>
<li>字符串考虑最后的&rsquo;\0&rsquo;，确保所有字符串是以&rsquo;\0&rsquo;结束</li>
<li>指针加减操作时，考虑指针类型长度</li>
<li>数组下标进行检查</li>
<li>使用时sizeof或者strlen计算结构/字符串长度，避免手工计算</li>
</ul>
<h4 id="规则62-禁止内存泄漏坚持下列措施可以避免内存泄漏"><a href="#%e8%a7%84%e5%88%9962-%e7%a6%81%e6%ad%a2%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f%e5%9d%9a%e6%8c%81%e4%b8%8b%e5%88%97%e6%8e%aa%e6%96%bd%e5%8f%af%e4%bb%a5%e9%81%bf%e5%85%8d%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" class="header-anchor"></a>规则6.2 禁止内存泄漏。坚持下列措施可以避免内存泄漏：
</h4><ul>
<li>异常出口处检查内存、定时器/文件句柄/Socket/队列/信号量/GUI等资源是否全部释放</li>
<li>删除结构指针时，必须从底层向上层顺序删除</li>
<li>使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了</li>
<li>避免重复分配内存</li>
<li>小心使用有return、break语句的宏，确保前面资源已经释放</li>
<li>检查队列中每个成员是否释放</li>
</ul>
<h4 id="规则63-禁止引用已经释放的内存空间坚持下列措施可以避免引用已经释放的内存空间"><a href="#%e8%a7%84%e5%88%9963-%e7%a6%81%e6%ad%a2%e5%bc%95%e7%94%a8%e5%b7%b2%e7%bb%8f%e9%87%8a%e6%94%be%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%9d%9a%e6%8c%81%e4%b8%8b%e5%88%97%e6%8e%aa%e6%96%bd%e5%8f%af%e4%bb%a5%e9%81%bf%e5%85%8d%e5%bc%95%e7%94%a8%e5%b7%b2%e7%bb%8f%e9%87%8a%e6%94%be%e7%9a%84%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4" class="header-anchor"></a>规则6.3 禁止引用已经释放的内存空间。坚持下列措施可以避免引用已经释放的内存空间：
</h4><ul>
<li><strong>内存释放后，把指针置为NULL；使用内存指针前进行非空判断。</strong></li>
<li>耦合度较强的模块互相调用时，一定要仔细考虑其调用关系，防止已经删除的对象被再次使用。</li>
<li>避免操作已发送消息的内存。</li>
<li>自动存储对象的地址不应赋值给其他的在第一个对象已经停止存在后仍然保持的对象（具有更大作用域的对象或者静态对象或者从一个函数返回的对象）</li>
</ul>
<h4 id="规则64-编程时要防止差1错误"><a href="#%e8%a7%84%e5%88%9964-%e7%bc%96%e7%a8%8b%e6%97%b6%e8%a6%81%e9%98%b2%e6%ad%a2%e5%b7%ae1%e9%94%99%e8%af%af" class="header-anchor"></a>规则6.4 编程时，要防止差1错误。
</h4><p>此类错误一般是由于把“&lt;=”误写成“&lt;”或“&gt;=”误写成“&gt;”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。</p>
<h4 id="规则65-所有的if--else-if结构应该由else子句结束switch语句必须有default分支"><a href="#%e8%a7%84%e5%88%9965-%e6%89%80%e6%9c%89%e7%9a%84if--else-if%e7%bb%93%e6%9e%84%e5%ba%94%e8%af%a5%e7%94%b1else%e5%ad%90%e5%8f%a5%e7%bb%93%e6%9d%9fswitch%e8%af%ad%e5%8f%a5%e5%bf%85%e9%a1%bb%e6%9c%89default%e5%88%86%e6%94%af" class="header-anchor"></a>规则6.5 所有的if &hellip; else if结构应该由else子句结束；switch语句必须有default分支。
</h4><h3 id="建议-6"><a href="#%e5%bb%ba%e8%ae%ae-6" class="header-anchor"></a>建议
</h3><h4 id="建议61-函数中分配的内存在函数退出之前要释放"><a href="#%e5%bb%ba%e8%ae%ae61-%e5%87%bd%e6%95%b0%e4%b8%ad%e5%88%86%e9%85%8d%e7%9a%84%e5%86%85%e5%ad%98%e5%9c%a8%e5%87%bd%e6%95%b0%e9%80%80%e5%87%ba%e4%b9%8b%e5%89%8d%e8%a6%81%e9%87%8a%e6%94%be" class="header-anchor"></a>建议6.1 函数中分配的内存，在函数退出之前要释放。
</h4><p><strong>有很多函数申请内存，保存在数据结构中，要在申请处加上注释，说明在何处释放。</strong></p>
<h4 id="建议62-if语句尽量加上else分支对没有else分支的语句要小心对待"><a href="#%e5%bb%ba%e8%ae%ae62-if%e8%af%ad%e5%8f%a5%e5%b0%bd%e9%87%8f%e5%8a%a0%e4%b8%8aelse%e5%88%86%e6%94%af%e5%af%b9%e6%b2%a1%e6%9c%89else%e5%88%86%e6%94%af%e7%9a%84%e8%af%ad%e5%8f%a5%e8%a6%81%e5%b0%8f%e5%bf%83%e5%af%b9%e5%be%85" class="header-anchor"></a>建议6.2 if语句尽量加上else分支，对没有else分支的语句要小心对待。
</h4><h4 id="建议63-不要滥用goto语句"><a href="#%e5%bb%ba%e8%ae%ae63-%e4%b8%8d%e8%a6%81%e6%bb%a5%e7%94%a8goto%e8%af%ad%e5%8f%a5" class="header-anchor"></a>建议6.3 不要滥用goto语句。
</h4><p>goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。但好处是可以利用goto语句方面退出多重循环。</p>
<h4 id="建议64-时刻注意表达式是否会上溢下溢"><a href="#%e5%bb%ba%e8%ae%ae64-%e6%97%b6%e5%88%bb%e6%b3%a8%e6%84%8f%e8%a1%a8%e8%be%be%e5%bc%8f%e6%98%af%e5%90%a6%e4%bc%9a%e4%b8%8a%e6%ba%a2%e4%b8%8b%e6%ba%a2" class="header-anchor"></a>建议6.4 时刻注意表达式是否会上溢、下溢。
</h4><p>此种问题一般是出现在使用无符号变量时可能会出现边界i溢出情况。</p>
<h2 id="程序效率"><a href="#%e7%a8%8b%e5%ba%8f%e6%95%88%e7%8e%87" class="header-anchor"></a>程序效率
</h2><h3 id="原则-5"><a href="#%e5%8e%9f%e5%88%99-5" class="header-anchor"></a>原则
</h3><h4 id="原则71-在保证软件系统的正确性简洁可维护性可靠性及可测性的前提下提高代码效率"><a href="#%e5%8e%9f%e5%88%9971-%e5%9c%a8%e4%bf%9d%e8%af%81%e8%bd%af%e4%bb%b6%e7%b3%bb%e7%bb%9f%e7%9a%84%e6%ad%a3%e7%a1%ae%e6%80%a7%e7%ae%80%e6%b4%81%e5%8f%af%e7%bb%b4%e6%8a%a4%e6%80%a7%e5%8f%af%e9%9d%a0%e6%80%a7%e5%8f%8a%e5%8f%af%e6%b5%8b%e6%80%a7%e7%9a%84%e5%89%8d%e6%8f%90%e4%b8%8b%e6%8f%90%e9%ab%98%e4%bb%a3%e7%a0%81%e6%95%88%e7%8e%87" class="header-anchor"></a>原则7.1 在保证软件系统的正确性、简洁、可维护性、可靠性及可测性的前提下，提高代码效率。
</h4><p><strong>让一个正确的程序更快速，比让一个足够快的程序正确，要容易得太多。大多数时候，不要把注意力集中在如何使代码更快上，应首先关注让代码尽可能地清晰易读和更可靠。</strong></p>
<h4 id="原则72-通过对数据结构程序算法的优化来提高效率"><a href="#%e5%8e%9f%e5%88%9972-%e9%80%9a%e8%bf%87%e5%af%b9%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e7%a8%8b%e5%ba%8f%e7%ae%97%e6%b3%95%e7%9a%84%e4%bc%98%e5%8c%96%e6%9d%a5%e6%8f%90%e9%ab%98%e6%95%88%e7%8e%87" class="header-anchor"></a>原则7.2 通过对数据结构、程序算法的优化来提高效率。
</h4><h3 id="建议-7"><a href="#%e5%bb%ba%e8%ae%ae-7" class="header-anchor"></a>建议
</h3><h4 id="建议71-将不变条件的计算移到循环体外"><a href="#%e5%bb%ba%e8%ae%ae71-%e5%b0%86%e4%b8%8d%e5%8f%98%e6%9d%a1%e4%bb%b6%e7%9a%84%e8%ae%a1%e7%ae%97%e7%a7%bb%e5%88%b0%e5%be%aa%e7%8e%af%e4%bd%93%e5%a4%96" class="header-anchor"></a>建议7.1 将不变条件的计算移到循环体外。
</h4><h4 id="建议72-对于多维大数组避免来回跳跃式访问数组成员"><a href="#%e5%bb%ba%e8%ae%ae72-%e5%af%b9%e4%ba%8e%e5%a4%9a%e7%bb%b4%e5%a4%a7%e6%95%b0%e7%bb%84%e9%81%bf%e5%85%8d%e6%9d%a5%e5%9b%9e%e8%b7%b3%e8%b7%83%e5%bc%8f%e8%ae%bf%e9%97%ae%e6%95%b0%e7%bb%84%e6%88%90%e5%91%98" class="header-anchor"></a>建议7.2 对于多维大数组，避免来回跳跃式访问数组成员。
</h4><h4 id="建议73-创建资源库以减少分配对象的开销"><a href="#%e5%bb%ba%e8%ae%ae73-%e5%88%9b%e5%bb%ba%e8%b5%84%e6%ba%90%e5%ba%93%e4%bb%a5%e5%87%8f%e5%b0%91%e5%88%86%e9%85%8d%e5%af%b9%e8%b1%a1%e7%9a%84%e5%bc%80%e9%94%80" class="header-anchor"></a>建议7.3 创建资源库，以减少分配对象的开销。
</h4><p>例如，使用线程池机制，避免线程频繁创建、销毁的系统调用；使用内存池，对于频繁申请、释放的小块内存，一次性申请一个大块的内存，当系统申请内存时，从内存池获取小块内存，使用完毕再释放到内存池中，避免内存申请释放的频繁系统调用</p>
<h4 id="建议74-将多次被调用的-小函数改为inline函数或者宏实现"><a href="#%e5%bb%ba%e8%ae%ae74-%e5%b0%86%e5%a4%9a%e6%ac%a1%e8%a2%ab%e8%b0%83%e7%94%a8%e7%9a%84-%e5%b0%8f%e5%87%bd%e6%95%b0%e6%94%b9%e4%b8%bainline%e5%87%bd%e6%95%b0%e6%88%96%e8%80%85%e5%ae%8f%e5%ae%9e%e7%8e%b0" class="header-anchor"></a>建议7.4 将多次被调用的 “小函数”改为inline函数或者宏实现。
</h4><p>inline函数的优点：其一编译时不用展开，代码SIZE小。其二可以加断点，易于定位问题，例如对于引用计数加减的时候。其三函数编译时，编译器会做语法检查。</p>
<h2 id="8-注释"><a href="#8-%e6%b3%a8%e9%87%8a" class="header-anchor"></a>8 注释
</h2><h3 id="原则-6"><a href="#%e5%8e%9f%e5%88%99-6" class="header-anchor"></a>原则
</h3><h4 id="原则81-优秀的代码可以自我解释不通过注释即可轻易读懂"><a href="#%e5%8e%9f%e5%88%9981-%e4%bc%98%e7%a7%80%e7%9a%84%e4%bb%a3%e7%a0%81%e5%8f%af%e4%bb%a5%e8%87%aa%e6%88%91%e8%a7%a3%e9%87%8a%e4%b8%8d%e9%80%9a%e8%bf%87%e6%b3%a8%e9%87%8a%e5%8d%b3%e5%8f%af%e8%bd%bb%e6%98%93%e8%af%bb%e6%87%82" class="header-anchor"></a>原则8.1 优秀的代码可以自我解释，不通过注释即可轻易读懂。
</h4><p>**优秀的代码不写注释也可轻易读懂，注释无法把糟糕的代码变好，**需要很多注释来解释的代码往往存在坏味道，需要重构。</p>
<h4 id="原则82-注释的内容要清楚明了含义准确防止注释二义性"><a href="#%e5%8e%9f%e5%88%9982-%e6%b3%a8%e9%87%8a%e7%9a%84%e5%86%85%e5%ae%b9%e8%a6%81%e6%b8%85%e6%a5%9a%e6%98%8e%e4%ba%86%e5%90%ab%e4%b9%89%e5%87%86%e7%a1%ae%e9%98%b2%e6%ad%a2%e6%b3%a8%e9%87%8a%e4%ba%8c%e4%b9%89%e6%80%a7" class="header-anchor"></a>原则8.2 注释的内容要清楚、明了，含义准确，防止注释二义性。
</h4><p>有歧义的注释反而会导致维护者更难看懂代码，<strong>正如带两块表反而不知道准确时间。</strong></p>
<h4 id="原则83-在代码的功能意图层次上进行注释即注释解释代码难以直接表达的意图而不是重复描述代码"><a href="#%e5%8e%9f%e5%88%9983-%e5%9c%a8%e4%bb%a3%e7%a0%81%e7%9a%84%e5%8a%9f%e8%83%bd%e6%84%8f%e5%9b%be%e5%b1%82%e6%ac%a1%e4%b8%8a%e8%bf%9b%e8%a1%8c%e6%b3%a8%e9%87%8a%e5%8d%b3%e6%b3%a8%e9%87%8a%e8%a7%a3%e9%87%8a%e4%bb%a3%e7%a0%81%e9%9a%be%e4%bb%a5%e7%9b%b4%e6%8e%a5%e8%a1%a8%e8%be%be%e7%9a%84%e6%84%8f%e5%9b%be%e8%80%8c%e4%b8%8d%e6%98%af%e9%87%8d%e5%a4%8d%e6%8f%8f%e8%bf%b0%e4%bb%a3%e7%a0%81" class="header-anchor"></a>原则8.3 在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码。
</h4><p>注释不是为了名词解释（what），不是为了重复描述代码，而是说明用途（why）。</p>
<h3 id="规则-8"><a href="#%e8%a7%84%e5%88%99-8" class="header-anchor"></a>规则
</h3><h4 id="规则81-修改代码时维护代码周边的所有注释以保证注释与代码的一致性不再有用的注释要删除"><a href="#%e8%a7%84%e5%88%9981-%e4%bf%ae%e6%94%b9%e4%bb%a3%e7%a0%81%e6%97%b6%e7%bb%b4%e6%8a%a4%e4%bb%a3%e7%a0%81%e5%91%a8%e8%be%b9%e7%9a%84%e6%89%80%e6%9c%89%e6%b3%a8%e9%87%8a%e4%bb%a5%e4%bf%9d%e8%af%81%e6%b3%a8%e9%87%8a%e4%b8%8e%e4%bb%a3%e7%a0%81%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e4%b8%8d%e5%86%8d%e6%9c%89%e7%94%a8%e7%9a%84%e6%b3%a8%e9%87%8a%e8%a6%81%e5%88%a0%e9%99%a4" class="header-anchor"></a>规则8.1 修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除。
</h4><p>这个要求本身不难，但是却是在开发过程中很难坚持做到的一点，也是现在我们公司代码里面存在较为广泛的现象。</p>
<h4 id="规则82-文件头部应进行注释注释必须列出版权说明版本号生成日期作者姓名工号内容功能说明与其它文件的关系修改日志等头文件的注释中还应有函数功能简要说明"><a href="#%e8%a7%84%e5%88%9982-%e6%96%87%e4%bb%b6%e5%a4%b4%e9%83%a8%e5%ba%94%e8%bf%9b%e8%a1%8c%e6%b3%a8%e9%87%8a%e6%b3%a8%e9%87%8a%e5%bf%85%e9%a1%bb%e5%88%97%e5%87%ba%e7%89%88%e6%9d%83%e8%af%b4%e6%98%8e%e7%89%88%e6%9c%ac%e5%8f%b7%e7%94%9f%e6%88%90%e6%97%a5%e6%9c%9f%e4%bd%9c%e8%80%85%e5%a7%93%e5%90%8d%e5%b7%a5%e5%8f%b7%e5%86%85%e5%ae%b9%e5%8a%9f%e8%83%bd%e8%af%b4%e6%98%8e%e4%b8%8e%e5%85%b6%e5%ae%83%e6%96%87%e4%bb%b6%e7%9a%84%e5%85%b3%e7%b3%bb%e4%bf%ae%e6%94%b9%e6%97%a5%e5%bf%97%e7%ad%89%e5%a4%b4%e6%96%87%e4%bb%b6%e7%9a%84%e6%b3%a8%e9%87%8a%e4%b8%ad%e8%bf%98%e5%ba%94%e6%9c%89%e5%87%bd%e6%95%b0%e5%8a%9f%e8%83%bd%e7%ae%80%e8%a6%81%e8%af%b4%e6%98%8e" class="header-anchor"></a>规则8.2 文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。
</h4><p>通常头文件要对功能和用法作简单说明，源文件包含了更多的实现细节或算法讨论。</p>
<h4 id="规则83-函数声明处注释描述函数功能性能及用法包括输入和输出参数函数返回值可重入的要求等定义处详细描述函数功能和实现要点如实现的简要步骤实现的理由设计约束等"><a href="#%e8%a7%84%e5%88%9983-%e5%87%bd%e6%95%b0%e5%a3%b0%e6%98%8e%e5%a4%84%e6%b3%a8%e9%87%8a%e6%8f%8f%e8%bf%b0%e5%87%bd%e6%95%b0%e5%8a%9f%e8%83%bd%e6%80%a7%e8%83%bd%e5%8f%8a%e7%94%a8%e6%b3%95%e5%8c%85%e6%8b%ac%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%ba%e5%8f%82%e6%95%b0%e5%87%bd%e6%95%b0%e8%bf%94%e5%9b%9e%e5%80%bc%e5%8f%af%e9%87%8d%e5%85%a5%e7%9a%84%e8%a6%81%e6%b1%82%e7%ad%89%e5%ae%9a%e4%b9%89%e5%a4%84%e8%af%a6%e7%bb%86%e6%8f%8f%e8%bf%b0%e5%87%bd%e6%95%b0%e5%8a%9f%e8%83%bd%e5%92%8c%e5%ae%9e%e7%8e%b0%e8%a6%81%e7%82%b9%e5%a6%82%e5%ae%9e%e7%8e%b0%e7%9a%84%e7%ae%80%e8%a6%81%e6%ad%a5%e9%aa%a4%e5%ae%9e%e7%8e%b0%e7%9a%84%e7%90%86%e7%94%b1%e8%ae%be%e8%ae%a1%e7%ba%a6%e6%9d%9f%e7%ad%89" class="header-anchor"></a>规则8.3 函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、设计约束等。
</h4><p>重要的、复杂的函数，提供外部使用的接口函数应编写详细的注释。</p>
<h4 id="规则84-全局变量要有较详细的注释包括对其功能取值范围以及存取时注意事项等的说明"><a href="#%e8%a7%84%e5%88%9984-%e5%85%a8%e5%b1%80%e5%8f%98%e9%87%8f%e8%a6%81%e6%9c%89%e8%be%83%e8%af%a6%e7%bb%86%e7%9a%84%e6%b3%a8%e9%87%8a%e5%8c%85%e6%8b%ac%e5%af%b9%e5%85%b6%e5%8a%9f%e8%83%bd%e5%8f%96%e5%80%bc%e8%8c%83%e5%9b%b4%e4%bb%a5%e5%8f%8a%e5%ad%98%e5%8f%96%e6%97%b6%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9%e7%ad%89%e7%9a%84%e8%af%b4%e6%98%8e" class="header-anchor"></a>规则8.4 全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明。
</h4><h4 id="规则85-注释应放在其代码上方相邻位置或右方不可放在下面如放于上方则需与其上面的代码用空行隔开且与下方代码缩进相同"><a href="#%e8%a7%84%e5%88%9985-%e6%b3%a8%e9%87%8a%e5%ba%94%e6%94%be%e5%9c%a8%e5%85%b6%e4%bb%a3%e7%a0%81%e4%b8%8a%e6%96%b9%e7%9b%b8%e9%82%bb%e4%bd%8d%e7%bd%ae%e6%88%96%e5%8f%b3%e6%96%b9%e4%b8%8d%e5%8f%af%e6%94%be%e5%9c%a8%e4%b8%8b%e9%9d%a2%e5%a6%82%e6%94%be%e4%ba%8e%e4%b8%8a%e6%96%b9%e5%88%99%e9%9c%80%e4%b8%8e%e5%85%b6%e4%b8%8a%e9%9d%a2%e7%9a%84%e4%bb%a3%e7%a0%81%e7%94%a8%e7%a9%ba%e8%a1%8c%e9%9a%94%e5%bc%80%e4%b8%94%e4%b8%8e%e4%b8%8b%e6%96%b9%e4%bb%a3%e7%a0%81%e7%bc%a9%e8%bf%9b%e7%9b%b8%e5%90%8c" class="header-anchor"></a>规则8.5 注释应放在其代码上方相邻位置或右方，不可放在下面。如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同。
</h4><p>这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。</p>
<h4 id="规则86-对于switch语句下的case语句如果因为特殊情况需要处理完一个case后进入下一个case处理必须在该case语句处理完下一个case语句前加上明确的注释"><a href="#%e8%a7%84%e5%88%9986-%e5%af%b9%e4%ba%8eswitch%e8%af%ad%e5%8f%a5%e4%b8%8b%e7%9a%84case%e8%af%ad%e5%8f%a5%e5%a6%82%e6%9e%9c%e5%9b%a0%e4%b8%ba%e7%89%b9%e6%ae%8a%e6%83%85%e5%86%b5%e9%9c%80%e8%a6%81%e5%a4%84%e7%90%86%e5%ae%8c%e4%b8%80%e4%b8%aacase%e5%90%8e%e8%bf%9b%e5%85%a5%e4%b8%8b%e4%b8%80%e4%b8%aacase%e5%a4%84%e7%90%86%e5%bf%85%e9%a1%bb%e5%9c%a8%e8%af%a5case%e8%af%ad%e5%8f%a5%e5%a4%84%e7%90%86%e5%ae%8c%e4%b8%8b%e4%b8%80%e4%b8%aacase%e8%af%ad%e5%8f%a5%e5%89%8d%e5%8a%a0%e4%b8%8a%e6%98%8e%e7%a1%ae%e7%9a%84%e6%b3%a8%e9%87%8a" class="header-anchor"></a>规则8.6 对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。
</h4><h4 id="规则87-避免在注释中使用缩写除非是业界通用或子系统内标准化的缩写"><a href="#%e8%a7%84%e5%88%9987-%e9%81%bf%e5%85%8d%e5%9c%a8%e6%b3%a8%e9%87%8a%e4%b8%ad%e4%bd%bf%e7%94%a8%e7%bc%a9%e5%86%99%e9%99%a4%e9%9d%9e%e6%98%af%e4%b8%9a%e7%95%8c%e9%80%9a%e7%94%a8%e6%88%96%e5%ad%90%e7%b3%bb%e7%bb%9f%e5%86%85%e6%a0%87%e5%87%86%e5%8c%96%e7%9a%84%e7%bc%a9%e5%86%99" class="header-anchor"></a>规则8.7 避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写。
</h4><h4 id="规则88-同一产品或项目组统一注释风格"><a href="#%e8%a7%84%e5%88%9988-%e5%90%8c%e4%b8%80%e4%ba%a7%e5%93%81%e6%88%96%e9%a1%b9%e7%9b%ae%e7%bb%84%e7%bb%9f%e4%b8%80%e6%b3%a8%e9%87%8a%e9%a3%8e%e6%a0%bc" class="header-anchor"></a>规则8.8 同一产品或项目组统一注释风格。
</h4><h3 id="建议-8"><a href="#%e5%bb%ba%e8%ae%ae-8" class="header-anchor"></a>建议
</h3><h4 id="建议81-避免在一行代码或表达式的中间插入注释"><a href="#%e5%bb%ba%e8%ae%ae81-%e9%81%bf%e5%85%8d%e5%9c%a8%e4%b8%80%e8%a1%8c%e4%bb%a3%e7%a0%81%e6%88%96%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e4%b8%ad%e9%97%b4%e6%8f%92%e5%85%a5%e6%b3%a8%e9%87%8a" class="header-anchor"></a>建议8.1 避免在一行代码或表达式的中间插入注释。
</h4><h4 id="建议82-注释应考虑程序易读及外观排版的因素使用的语言若是中英兼有的建议多使用中文除非能用非常流利准确的英文表达对于有外籍员工的由产品确定注释语言"><a href="#%e5%bb%ba%e8%ae%ae82-%e6%b3%a8%e9%87%8a%e5%ba%94%e8%80%83%e8%99%91%e7%a8%8b%e5%ba%8f%e6%98%93%e8%af%bb%e5%8f%8a%e5%a4%96%e8%a7%82%e6%8e%92%e7%89%88%e7%9a%84%e5%9b%a0%e7%b4%a0%e4%bd%bf%e7%94%a8%e7%9a%84%e8%af%ad%e8%a8%80%e8%8b%a5%e6%98%af%e4%b8%ad%e8%8b%b1%e5%85%bc%e6%9c%89%e7%9a%84%e5%bb%ba%e8%ae%ae%e5%a4%9a%e4%bd%bf%e7%94%a8%e4%b8%ad%e6%96%87%e9%99%a4%e9%9d%9e%e8%83%bd%e7%94%a8%e9%9d%9e%e5%b8%b8%e6%b5%81%e5%88%a9%e5%87%86%e7%a1%ae%e7%9a%84%e8%8b%b1%e6%96%87%e8%a1%a8%e8%be%be%e5%af%b9%e4%ba%8e%e6%9c%89%e5%a4%96%e7%b1%8d%e5%91%98%e5%b7%a5%e7%9a%84%e7%94%b1%e4%ba%a7%e5%93%81%e7%a1%ae%e5%ae%9a%e6%b3%a8%e9%87%8a%e8%af%ad%e8%a8%80" class="header-anchor"></a>建议8.2 注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。对于有外籍员工的，由产品确定注释语言。
</h4><p>注释语言不统一，影响程序易读性和外观排版，<strong>出于对维护人员的考虑，建议使用中文。</strong></p>
<h4 id="建议83-文件头函数头全局常量变量类型定义的注释格式采用工具可识别的格式"><a href="#%e5%bb%ba%e8%ae%ae83-%e6%96%87%e4%bb%b6%e5%a4%b4%e5%87%bd%e6%95%b0%e5%a4%b4%e5%85%a8%e5%b1%80%e5%b8%b8%e9%87%8f%e5%8f%98%e9%87%8f%e7%b1%bb%e5%9e%8b%e5%ae%9a%e4%b9%89%e7%9a%84%e6%b3%a8%e9%87%8a%e6%a0%bc%e5%bc%8f%e9%87%87%e7%94%a8%e5%b7%a5%e5%85%b7%e5%8f%af%e8%af%86%e5%88%ab%e7%9a%84%e6%a0%bc%e5%bc%8f" class="header-anchor"></a>建议8.3 文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式。
</h4><p>以doxygen格式为例，文件头，函数和全部变量的注释的示例如下：
<strong>文件头注释：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> /** *  @file           （本文件的文件名eg：mib.h）*  @brief          （本文件实现的功能的简述）*  @version 1.1    （版本声明）*  @author        （作者，eg：张三）*  @date          （文件创建日期，eg：2010年12月15日）*/
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>函数头注释：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> /***@ Description:向接收方发送SET请求* @param req - 指向整个SNMP SET 请求报文.* @param ind - 需要处理的subrequest 索引.* @return 成功：SNMP_ERROR_SUCCESS，失败：SNMP_ERROR_COMITFAIL*/Int commit_set_request(Request *req, int ind);
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>全局变量注释：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> /**  模拟的Agent MIB */agentpp_simulation_mib * g_agtSimMib;
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>函数头注释建议写到声明处。并非所有函数都必须写注释，建议针对这样的函数写注释：重要的、复杂的函数，提供外部使用的接口函数。</strong></p>
<h2 id="9-排版与格式"><a href="#9-%e6%8e%92%e7%89%88%e4%b8%8e%e6%a0%bc%e5%bc%8f" class="header-anchor"></a>9 排版与格式
</h2><h3 id="规则-9"><a href="#%e8%a7%84%e5%88%99-9" class="header-anchor"></a>规则
</h3><h4 id="规则91-程序块采用缩进风格编写每级缩进为4个空格"><a href="#%e8%a7%84%e5%88%9991-%e7%a8%8b%e5%ba%8f%e5%9d%97%e9%87%87%e7%94%a8%e7%bc%a9%e8%bf%9b%e9%a3%8e%e6%a0%bc%e7%bc%96%e5%86%99%e6%af%8f%e7%ba%a7%e7%bc%a9%e8%bf%9b%e4%b8%ba4%e4%b8%aa%e7%a9%ba%e6%a0%bc" class="header-anchor"></a>规则9.1 程序块采用缩进风格编写，每级缩进为4个空格。
</h4><p>宏定义、编译开关、条件预处理语句可以顶格（或使用自定义的排版方案，但产品/模块内必须保持一致）。</p>
<h4 id="规则92-相对独立的程序块之间变量说明之后必须加空行"><a href="#%e8%a7%84%e5%88%9992-%e7%9b%b8%e5%af%b9%e7%8b%ac%e7%ab%8b%e7%9a%84%e7%a8%8b%e5%ba%8f%e5%9d%97%e4%b9%8b%e9%97%b4%e5%8f%98%e9%87%8f%e8%af%b4%e6%98%8e%e4%b9%8b%e5%90%8e%e5%bf%85%e9%a1%bb%e5%8a%a0%e7%a9%ba%e8%a1%8c" class="header-anchor"></a>规则9.2 相对独立的程序块之间、变量说明之后必须加空行。
</h4><h4 id="规则93-一条语句不能过长如不能拆分需要分行写一行到底多少字符换行比较合适产品可以自行确定换行时有如下建议"><a href="#%e8%a7%84%e5%88%9993-%e4%b8%80%e6%9d%a1%e8%af%ad%e5%8f%a5%e4%b8%8d%e8%83%bd%e8%bf%87%e9%95%bf%e5%a6%82%e4%b8%8d%e8%83%bd%e6%8b%86%e5%88%86%e9%9c%80%e8%a6%81%e5%88%86%e8%a1%8c%e5%86%99%e4%b8%80%e8%a1%8c%e5%88%b0%e5%ba%95%e5%a4%9a%e5%b0%91%e5%ad%97%e7%ac%a6%e6%8d%a2%e8%a1%8c%e6%af%94%e8%be%83%e5%90%88%e9%80%82%e4%ba%a7%e5%93%81%e5%8f%af%e4%bb%a5%e8%87%aa%e8%a1%8c%e7%a1%ae%e5%ae%9a%e6%8d%a2%e8%a1%8c%e6%97%b6%e6%9c%89%e5%a6%82%e4%b8%8b%e5%bb%ba%e8%ae%ae" class="header-anchor"></a>规则9.3 一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定。换行时有如下建议：
</h4><ul>
<li>换行时要增加一级缩进，使代码可读性更好；</li>
<li>低优先级操作符处划分新行；换行时操作符应该也放下来，放在新行首；</li>
<li>换行时建议一个完整的语句放在一行，不要根据字符数断行</li>
</ul>
<h4 id="规则94-多个短语句包括赋值语句不允许写在同一行内即一行只写一条语句"><a href="#%e8%a7%84%e5%88%9994-%e5%a4%9a%e4%b8%aa%e7%9f%ad%e8%af%ad%e5%8f%a5%e5%8c%85%e6%8b%ac%e8%b5%8b%e5%80%bc%e8%af%ad%e5%8f%a5%e4%b8%8d%e5%85%81%e8%ae%b8%e5%86%99%e5%9c%a8%e5%90%8c%e4%b8%80%e8%a1%8c%e5%86%85%e5%8d%b3%e4%b8%80%e8%a1%8c%e5%8f%aa%e5%86%99%e4%b8%80%e6%9d%a1%e8%af%ad%e5%8f%a5" class="header-anchor"></a>规则9.4 多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句。
</h4><h4 id="规则95-iffordowhilecaseswitchdefault等语句独占一行"><a href="#%e8%a7%84%e5%88%9995-iffordowhilecaseswitchdefault%e7%ad%89%e8%af%ad%e5%8f%a5%e7%8b%ac%e5%8d%a0%e4%b8%80%e8%a1%8c" class="header-anchor"></a>规则9.5 if、for、do、while、case、switch、default等语句独占一行。
</h4><h4 id="规则96-在两个以上的关键字变量常量进行对等操作时它们之间的操作符之前之后或者前后要加空格进行非对等操作时如果是关系密切的立即操作符如后不应加空格"><a href="#%e8%a7%84%e5%88%9996-%e5%9c%a8%e4%b8%a4%e4%b8%aa%e4%bb%a5%e4%b8%8a%e7%9a%84%e5%85%b3%e9%94%ae%e5%ad%97%e5%8f%98%e9%87%8f%e5%b8%b8%e9%87%8f%e8%bf%9b%e8%a1%8c%e5%af%b9%e7%ad%89%e6%93%8d%e4%bd%9c%e6%97%b6%e5%ae%83%e4%bb%ac%e4%b9%8b%e9%97%b4%e7%9a%84%e6%93%8d%e4%bd%9c%e7%ac%a6%e4%b9%8b%e5%89%8d%e4%b9%8b%e5%90%8e%e6%88%96%e8%80%85%e5%89%8d%e5%90%8e%e8%a6%81%e5%8a%a0%e7%a9%ba%e6%a0%bc%e8%bf%9b%e8%a1%8c%e9%9d%9e%e5%af%b9%e7%ad%89%e6%93%8d%e4%bd%9c%e6%97%b6%e5%a6%82%e6%9e%9c%e6%98%af%e5%85%b3%e7%b3%bb%e5%af%86%e5%88%87%e7%9a%84%e7%ab%8b%e5%8d%b3%e6%93%8d%e4%bd%9c%e7%ac%a6%e5%a6%82%e5%90%8e%e4%b8%8d%e5%ba%94%e5%8a%a0%e7%a9%ba%e6%a0%bc" class="header-anchor"></a>规则9.6 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－&gt;），后不应加空格。
</h4><p>1.在已经非常清晰的语句中没有必要再留空格，如<strong>括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格</strong>，因为在C语言中括号已经是最清晰的标志了。
2.逗号、分号只在后面加空格
3.比较操作符, 赋值操作符&quot;=&quot;、 &ldquo;+=&quot;，算术操作符&rdquo;+&quot;、&quot;%&quot;，逻辑操作符&quot;&amp;&amp;&quot;、&quot;&amp;&quot;，位域操作符&quot;&laquo;&quot;、&quot;^&ldquo;等双目操作符的前后加空格。
4.&rdquo;!&quot;、&quot;~&quot;、&quot;++&quot;、&quot;&ndash;&quot;、&quot;&amp;&quot;（地址操作符）等单目操作符前后不加空格。
5.&quot;-&gt;&quot;、&quot;.&ldquo;前后不加空格。</p>
<ol start="6">
<li>if、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。</li>
</ol>
<h3 id="建议-9"><a href="#%e5%bb%ba%e8%ae%ae-9" class="header-anchor"></a>建议
</h3><h4 id="建议91-注释符包括与注释内容之间要用一个空格进行分隔"><a href="#%e5%bb%ba%e8%ae%ae91-%e6%b3%a8%e9%87%8a%e7%ac%a6%e5%8c%85%e6%8b%ac%e4%b8%8e%e6%b3%a8%e9%87%8a%e5%86%85%e5%ae%b9%e4%b9%8b%e9%97%b4%e8%a6%81%e7%94%a8%e4%b8%80%e4%b8%aa%e7%a9%ba%e6%a0%bc%e8%bf%9b%e8%a1%8c%e5%88%86%e9%9a%94" class="header-anchor"></a>建议9.1 注释符（包括‘/’‘//’‘/’）与注释内容之间要用一个空格进行分隔。
</h4><h4 id="建议92-源程序中关系较为紧密的代码应尽可能相邻"><a href="#%e5%bb%ba%e8%ae%ae92-%e6%ba%90%e7%a8%8b%e5%ba%8f%e4%b8%ad%e5%85%b3%e7%b3%bb%e8%be%83%e4%b8%ba%e7%b4%a7%e5%af%86%e7%9a%84%e4%bb%a3%e7%a0%81%e5%ba%94%e5%b0%bd%e5%8f%af%e8%83%bd%e7%9b%b8%e9%82%bb" class="header-anchor"></a>建议9.2 源程序中关系较为紧密的代码应尽可能相邻。
</h4><h2 id="表达式"><a href="#%e8%a1%a8%e8%be%be%e5%bc%8f" class="header-anchor"></a>表达式
</h2><p><strong>本小节内容虽少，但却是平时写代码过程中容易忽略并且会产生较大影响的问题，需要额外注意。</strong></p>
<h3 id="规则-10"><a href="#%e8%a7%84%e5%88%99-10" class="header-anchor"></a>规则
</h3><h4 id="规则101-表达式的值在标准所允许的任何运算次序下都应该是相同的"><a href="#%e8%a7%84%e5%88%99101-%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e5%80%bc%e5%9c%a8%e6%a0%87%e5%87%86%e6%89%80%e5%85%81%e8%ae%b8%e7%9a%84%e4%bb%bb%e4%bd%95%e8%bf%90%e7%ae%97%e6%ac%a1%e5%ba%8f%e4%b8%8b%e9%83%bd%e5%ba%94%e8%af%a5%e6%98%af%e7%9b%b8%e5%90%8c%e7%9a%84" class="header-anchor"></a>规则10.1 表达式的值在标准所允许的任何运算次序下都应该是相同的。
</h4><p>说明：除了逗号(,)，逻辑与(&amp;&amp;)，逻辑或(||)之外，C标准没有规定同级操作符是从左还是从右开始计算，需要保证一个表达式有且只有一个计算结果，较好的方法就是<strong>将复合表达式分开写成若干个简单表达式，明确表达式的运算次序，就可以有效消除非预期副作用。</strong>
1.自增或自减操作符</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl"> x = b[i] + i++;b[i] 的运算是先于还是后于 i++ 的运算，表达式会产生不同的结果，把自增运算做为单独的语句，可以避免这个问题。
</span></span></code></pre></td></tr></table>
</div>
</div><p>2.函数参数，函数参数通常从右到左压栈，但函数参数的计算次序不一定与压栈次序相同。
示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">x = func( i++, i);
</span></span></code></pre></td></tr></table>
</div>
</div><p>应该修改代码明确先计算第一个参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">i++;x = func(i, i);
</span></span></code></pre></td></tr></table>
</div>
</div><p>3.函数指针
示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">p-&gt;task_start_fn(p++);
</span></span></code></pre></td></tr></table>
</div>
</div><p>求函数地址p与计算p++无关，结果是任意值。必须单独计算p++：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">p-&gt;task_start_fn(p);p++;
</span></span></code></pre></td></tr></table>
</div>
</div><p>4.函数调用
示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">g_var</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="ne">int</span> <span class="n">fun1</span><span class="p">(){</span>    <span class="n">g_var</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>    <span class="k">return</span> <span class="n">g_var</span><span class="p">;}</span><span class="ne">int</span> <span class="n">fun2</span><span class="p">(){</span>    <span class="n">g_var</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>    <span class="k">return</span> <span class="n">g_var</span><span class="p">;}</span><span class="ne">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">fun1</span><span class="p">()</span> <span class="o">+</span> <span class="n">fun2</span><span class="p">();</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>编译器可能先计算fun1()，也可能先计算fun2()，由于x的结果依赖于函数fun1()/fun2()的计算次序（fun1()/fun2()被调用时修改和使用了同一个全局变量），则上面的代码存在问题。
5.嵌套赋值语句
6.volatile访问
限定符volatile表示可能被其它途径更改的变量，例如硬件自动更新的寄存器。编译器不会优化对volatile变量的读取。</p>
<h3 id="建议-10"><a href="#%e5%bb%ba%e8%ae%ae-10" class="header-anchor"></a>建议
</h3><h4 id="建议101-函数调用不要作为另一个函数的参数使用否则对于代码的调试阅读都不利"><a href="#%e5%bb%ba%e8%ae%ae101-%e5%87%bd%e6%95%b0%e8%b0%83%e7%94%a8%e4%b8%8d%e8%a6%81%e4%bd%9c%e4%b8%ba%e5%8f%a6%e4%b8%80%e4%b8%aa%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0%e4%bd%bf%e7%94%a8%e5%90%a6%e5%88%99%e5%af%b9%e4%ba%8e%e4%bb%a3%e7%a0%81%e7%9a%84%e8%b0%83%e8%af%95%e9%98%85%e8%af%bb%e9%83%bd%e4%b8%8d%e5%88%a9" class="header-anchor"></a>建议10.1 函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利。
</h4><p>如下代码不合理，仅用于说明当函数作为参数时，由于参数压栈次数不是代码可以控制的，可能造成未知的输出：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">g_var</span><span class="p">;</span><span class="ne">int</span> <span class="n">fun1</span><span class="p">(){</span>    <span class="n">g_var</span> <span class="o">+=</span> <span class="mi">10</span><span class="p">;</span>    <span class="k">return</span> <span class="n">g_var</span><span class="p">;}</span><span class="ne">int</span> <span class="n">fun2</span><span class="p">(){</span>    <span class="n">g_var</span> <span class="o">+=</span> <span class="mi">100</span><span class="p">;</span>    <span class="k">return</span> <span class="n">g_var</span><span class="p">;}</span><span class="ne">int</span> <span class="n">main</span><span class="p">(</span><span class="ne">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[],</span> <span class="n">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]){</span>    <span class="n">g_var</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;func1: </span><span class="si">%d</span><span class="s2">, func2: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">fun1</span><span class="p">(),</span> <span class="n">fun2</span><span class="p">());</span>    <span class="n">g_var</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;func2: </span><span class="si">%d</span><span class="s2">, func1: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">fun2</span><span class="p">(),</span> <span class="n">fun1</span><span class="p">());}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="建议102-赋值语句不要写在if等语句中或者作为函数的参数使用"><a href="#%e5%bb%ba%e8%ae%ae102-%e8%b5%8b%e5%80%bc%e8%af%ad%e5%8f%a5%e4%b8%8d%e8%a6%81%e5%86%99%e5%9c%a8if%e7%ad%89%e8%af%ad%e5%8f%a5%e4%b8%ad%e6%88%96%e8%80%85%e4%bd%9c%e4%b8%ba%e5%87%bd%e6%95%b0%e7%9a%84%e5%8f%82%e6%95%b0%e4%bd%bf%e7%94%a8" class="header-anchor"></a>建议10.2 赋值语句不要写在if等语句中，或者作为函数的参数使用。
</h4><p>1.因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。
2.作用函数参数来使用，参数的压栈顺序不同可能导致结果未知。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-gdscript3" data-lang="gdscript3"><span class="line"><span class="cl"><span class="ne">int</span> <span class="n">g_var</span><span class="p">;</span><span class="ne">int</span> <span class="n">main</span><span class="p">(</span><span class="ne">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[],</span> <span class="n">char</span> <span class="o">*</span><span class="n">envp</span><span class="p">[]){</span>    <span class="n">g_var</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;set 1st: </span><span class="si">%d</span><span class="s2">, add 2nd: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">g_var</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">g_var</span><span class="o">++</span><span class="p">);</span>    <span class="n">g_var</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>    <span class="n">printf</span><span class="p">(</span><span class="s2">&#34;add 1st: </span><span class="si">%d</span><span class="s2">, set 2nd: </span><span class="si">%d</span><span class="se">\n</span><span class="s2">&#34;</span><span class="p">,</span> <span class="n">g_var</span><span class="o">++</span><span class="p">,</span> <span class="n">g_var</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="建议103-用括号明确表达式的操作顺序避免过分依赖默认优先级"><a href="#%e5%bb%ba%e8%ae%ae103-%e7%94%a8%e6%8b%ac%e5%8f%b7%e6%98%8e%e7%a1%ae%e8%a1%a8%e8%be%be%e5%bc%8f%e7%9a%84%e6%93%8d%e4%bd%9c%e9%a1%ba%e5%ba%8f%e9%81%bf%e5%85%8d%e8%bf%87%e5%88%86%e4%be%9d%e8%b5%96%e9%bb%98%e8%ae%a4%e4%bc%98%e5%85%88%e7%ba%a7" class="header-anchor"></a>建议10.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级。
</h4><p>1.一元操作符，不需要使用括号
2.二元以上操作符，如果涉及多种操作符，则应该使用括号
3.<strong>即使所有操作符都是相同的，如果涉及类型转换或者量级提升，也应该使用括号控制计算的次序</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">/* 除了逗号(,)，逻辑与(&amp;&amp;)，逻辑或(||)之外，C标准没有规定同级操作符是从左还是从右开始计算，以上表达式存在种计算次序：f4 = (f1 +  f2) + f3 或f4 = f1 + (f2 + f3)，浮点数计算过程中可能四舍五入，量级提升，计算次序的不同会导致f4的结果不同，以上表达式在不同编译器上的计算结果可能不一样，建议增加括号明确计算顺序*/f4 =  f1 + f2 + f3;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="建议104-赋值操作符不能使用在产生布尔值的表达式上"><a href="#%e5%bb%ba%e8%ae%ae104-%e8%b5%8b%e5%80%bc%e6%93%8d%e4%bd%9c%e7%ac%a6%e4%b8%8d%e8%83%bd%e4%bd%bf%e7%94%a8%e5%9c%a8%e4%ba%a7%e7%94%9f%e5%b8%83%e5%b0%94%e5%80%bc%e7%9a%84%e8%a1%a8%e8%be%be%e5%bc%8f%e4%b8%8a" class="header-anchor"></a>建议10.4 赋值操作符不能使用在产生布尔值的表达式上。
</h4><h2 id="11-代码编辑编译"><a href="#11-%e4%bb%a3%e7%a0%81%e7%bc%96%e8%be%91%e7%bc%96%e8%af%91" class="header-anchor"></a>11 代码编辑、编译
</h2><h3 id="规则-11"><a href="#%e8%a7%84%e5%88%99-11" class="header-anchor"></a>规则
</h3><h4 id="规则111-使用编译器的最高告警级别理解所有的告警通过修改代码而不是降低告警级别来消除所有告警"><a href="#%e8%a7%84%e5%88%99111-%e4%bd%bf%e7%94%a8%e7%bc%96%e8%af%91%e5%99%a8%e7%9a%84%e6%9c%80%e9%ab%98%e5%91%8a%e8%ad%a6%e7%ba%a7%e5%88%ab%e7%90%86%e8%a7%a3%e6%89%80%e6%9c%89%e7%9a%84%e5%91%8a%e8%ad%a6%e9%80%9a%e8%bf%87%e4%bf%ae%e6%94%b9%e4%bb%a3%e7%a0%81%e8%80%8c%e4%b8%8d%e6%98%af%e9%99%8d%e4%bd%8e%e5%91%8a%e8%ad%a6%e7%ba%a7%e5%88%ab%e6%9d%a5%e6%b6%88%e9%99%a4%e6%89%80%e6%9c%89%e5%91%8a%e8%ad%a6" class="header-anchor"></a>规则11.1 <strong>使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警。</strong>
</h4><h4 id="规则112-在产品软件项目组中要统一编译开关静态检查选项以及相应告警清除策略"><a href="#%e8%a7%84%e5%88%99112-%e5%9c%a8%e4%ba%a7%e5%93%81%e8%bd%af%e4%bb%b6%e9%a1%b9%e7%9b%ae%e7%bb%84%e4%b8%ad%e8%a6%81%e7%bb%9f%e4%b8%80%e7%bc%96%e8%af%91%e5%bc%80%e5%85%b3%e9%9d%99%e6%80%81%e6%a3%80%e6%9f%a5%e9%80%89%e9%a1%b9%e4%bb%a5%e5%8f%8a%e7%9b%b8%e5%ba%94%e5%91%8a%e8%ad%a6%e6%b8%85%e9%99%a4%e7%ad%96%e7%95%a5" class="header-anchor"></a>规则11.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略。
</h4><p>某些语句经编译/静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。</p>
<h4 id="规则113-本地构建工具如pc-lint的配置应该和持续集成的一致"><a href="#%e8%a7%84%e5%88%99113-%e6%9c%ac%e5%9c%b0%e6%9e%84%e5%bb%ba%e5%b7%a5%e5%85%b7%e5%a6%82pc-lint%e7%9a%84%e9%85%8d%e7%bd%ae%e5%ba%94%e8%af%a5%e5%92%8c%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90%e7%9a%84%e4%b8%80%e8%87%b4" class="header-anchor"></a>规则11.3 本地构建工具（如PC-Lint）的配置应该和持续集成的一致。
</h4><h4 id="规则114-使用版本控制配置管理系统及时签入通过本地构建的代码确保签入的代码不会影响构建成功"><a href="#%e8%a7%84%e5%88%99114-%e4%bd%bf%e7%94%a8%e7%89%88%e6%9c%ac%e6%8e%a7%e5%88%b6%e9%85%8d%e7%bd%ae%e7%ae%a1%e7%90%86%e7%b3%bb%e7%bb%9f%e5%8f%8a%e6%97%b6%e7%ad%be%e5%85%a5%e9%80%9a%e8%bf%87%e6%9c%ac%e5%9c%b0%e6%9e%84%e5%bb%ba%e7%9a%84%e4%bb%a3%e7%a0%81%e7%a1%ae%e4%bf%9d%e7%ad%be%e5%85%a5%e7%9a%84%e4%bb%a3%e7%a0%81%e4%b8%8d%e4%bc%9a%e5%bd%b1%e5%93%8d%e6%9e%84%e5%bb%ba%e6%88%90%e5%8a%9f" class="header-anchor"></a>规则11.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功。
</h4><p><strong>及时签入代码降低集成难度。</strong></p>
<h3 id="建议-11"><a href="#%e5%bb%ba%e8%ae%ae-11" class="header-anchor"></a>建议
</h3><h4 id="建议111-要小心地使用编辑器提供的块拷贝功能编程"><a href="#%e5%bb%ba%e8%ae%ae111-%e8%a6%81%e5%b0%8f%e5%bf%83%e5%9c%b0%e4%bd%bf%e7%94%a8%e7%bc%96%e8%be%91%e5%99%a8%e6%8f%90%e4%be%9b%e7%9a%84%e5%9d%97%e6%8b%b7%e8%b4%9d%e5%8a%9f%e8%83%bd%e7%bc%96%e7%a8%8b" class="header-anchor"></a>建议11.1 要小心地使用编辑器提供的块拷贝功能编程。
</h4><h2 id="12-可测性"><a href="#12-%e5%8f%af%e6%b5%8b%e6%80%a7" class="header-anchor"></a>12 可测性
</h2><h3 id="原则-7"><a href="#%e5%8e%9f%e5%88%99-7" class="header-anchor"></a>原则
</h3><h4 id="原则121-模块划分清晰接口明确耦合性小有明确输入和输出否则单元测试实施困难"><a href="#%e5%8e%9f%e5%88%99121-%e6%a8%a1%e5%9d%97%e5%88%92%e5%88%86%e6%b8%85%e6%99%b0%e6%8e%a5%e5%8f%a3%e6%98%8e%e7%a1%ae%e8%80%a6%e5%90%88%e6%80%a7%e5%b0%8f%e6%9c%89%e6%98%8e%e7%a1%ae%e8%be%93%e5%85%a5%e5%92%8c%e8%be%93%e5%87%ba%e5%90%a6%e5%88%99%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e5%ae%9e%e6%96%bd%e5%9b%b0%e9%9a%be" class="header-anchor"></a>原则12.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难。
</h4><p>单元测试实施依赖于：</p>
<ul>
<li>模块间的接口定义清楚、完整、稳定；</li>
<li>模块功能的有明确的验收条件（包括：预置条件、输入和预期结果）；</li>
<li>模块内部的关键状态和关键数据可以查询，可以修改；</li>
<li>模块原子功能的入口唯一；</li>
<li>模块原子功能的出口唯一；</li>
<li>依赖集中处理：和模块相关的全局变量尽量的少，或者采用某种封装形式。</li>
</ul>
<h3 id="规则-12"><a href="#%e8%a7%84%e5%88%99-12" class="header-anchor"></a>规则
</h3><h4 id="规则121-在同一项目组或产品组内要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数并且要有详细的说明"><a href="#%e8%a7%84%e5%88%99121-%e5%9c%a8%e5%90%8c%e4%b8%80%e9%a1%b9%e7%9b%ae%e7%bb%84%e6%88%96%e4%ba%a7%e5%93%81%e7%bb%84%e5%86%85%e8%a6%81%e6%9c%89%e4%b8%80%e5%a5%97%e7%bb%9f%e4%b8%80%e7%9a%84%e4%b8%ba%e9%9b%86%e6%88%90%e6%b5%8b%e8%af%95%e4%b8%8e%e7%b3%bb%e7%bb%9f%e8%81%94%e8%b0%83%e5%87%86%e5%a4%87%e7%9a%84%e8%b0%83%e6%b5%8b%e5%bc%80%e5%85%b3%e5%8f%8a%e7%9b%b8%e5%ba%94%e6%89%93%e5%8d%b0%e5%87%bd%e6%95%b0%e5%b9%b6%e4%b8%94%e8%a6%81%e6%9c%89%e8%af%a6%e7%bb%86%e7%9a%84%e8%af%b4%e6%98%8e" class="header-anchor"></a>规则12.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。
</h4><p>本规则是针对项目组或产品组的。**代码至始至终只有一份代码，不存在开发版本和测试版本的说法。测试与最终发行的版本是通过编译开关的不同来实现的。**并且编译开关要规范统一。统一使用编译开关来实现测试版本与发行版本的区别，一般不允许再定义其它新的编译开关。</p>
<h4 id="规则122-在同一项目组或产品组内调测打印的日志要有统一的规定"><a href="#%e8%a7%84%e5%88%99122-%e5%9c%a8%e5%90%8c%e4%b8%80%e9%a1%b9%e7%9b%ae%e7%bb%84%e6%88%96%e4%ba%a7%e5%93%81%e7%bb%84%e5%86%85%e8%b0%83%e6%b5%8b%e6%89%93%e5%8d%b0%e7%9a%84%e6%97%a5%e5%bf%97%e8%a6%81%e6%9c%89%e7%bb%9f%e4%b8%80%e7%9a%84%e8%a7%84%e5%ae%9a" class="header-anchor"></a>规则12.2 在同一项目组或产品组内，调测打印的日志要有统一的规定。
</h4><p>统一的调测日志记录便于集成测试，具体包括：</p>
<ul>
<li>统一的日志分类以及日志级别；</li>
<li>通过命令行、网管等方式可以配置和改变日志输出的内容和格式；</li>
<li>在关键分支要记录日志，日志建议不要记录在原子函数中，否则难以定位；</li>
<li>调试日志记录的内容需要包括文件名/模块名、代码行号、函数名、被调用函数名、错误码、错误发生的环境等。</li>
</ul>
<h4 id="规则123-使用断言记录内部假设"><a href="#%e8%a7%84%e5%88%99123-%e4%bd%bf%e7%94%a8%e6%96%ad%e8%a8%80%e8%ae%b0%e5%bd%95%e5%86%85%e9%83%a8%e5%81%87%e8%ae%be" class="header-anchor"></a>规则12.3 使用断言记录内部假设。
</h4><h4 id="规则124-不能用断言来检查运行时错误"><a href="#%e8%a7%84%e5%88%99124-%e4%b8%8d%e8%83%bd%e7%94%a8%e6%96%ad%e8%a8%80%e6%9d%a5%e6%a3%80%e6%9f%a5%e8%bf%90%e8%a1%8c%e6%97%b6%e9%94%99%e8%af%af" class="header-anchor"></a>规则12.4 不能用断言来检查运行时错误。
</h4><p>断言的使用是有条件的。断言只能用于程序内部逻辑的条件判断，而不能用于对外部输入数据的判断,因为在网上实际运行时，是完全有可能出现外部输入非法数据的情况。</p>
<h2 id="13-安全性"><a href="#13-%e5%ae%89%e5%85%a8%e6%80%a7" class="header-anchor"></a>13 安全性
</h2><h3 id="原则-8"><a href="#%e5%8e%9f%e5%88%99-8" class="header-anchor"></a>原则
</h3><h4 id="原则131-对用户输入进行检查"><a href="#%e5%8e%9f%e5%88%99131-%e5%af%b9%e7%94%a8%e6%88%b7%e8%be%93%e5%85%a5%e8%bf%9b%e8%a1%8c%e6%a3%80%e6%9f%a5" class="header-anchor"></a>原则13.1 对用户输入进行检查。
</h4><p>以下场景需要对用户输入进行检验，以确保安全：</p>
<ul>
<li>用户输入作为循环条件</li>
<li>用户输入作为数组下标</li>
<li>用户输入作为内存分配的尺寸参数</li>
<li>用户输入作为格式化字符串</li>
<li>用户输入作为业务数据（如作为命令执行参数、拼装sql语句、以特定格式持久化）</li>
</ul>
<p><strong>这些情况下如果不对用户数据做合法性验证，很可能导致DOS、内存越界、格式化字符串漏洞、命令注入、SQL注入、缓冲区溢出、数据破坏等问题。</strong>
可采取以下措施对用户输入检查：
* 用户输入作为数值的，做数值范围检查
* 用户输入是字符串的，检查字符串长度
* 用户输入作为格式化字符串的，检查关键字“%”
* 用户输入作为业务数据，对关键字进行检查、转义</p>
<h3 id="规则-13"><a href="#%e8%a7%84%e5%88%99-13" class="header-anchor"></a>规则
</h3><h4 id="规则131-确保所有字符串是以null结束"><a href="#%e8%a7%84%e5%88%99131-%e7%a1%ae%e4%bf%9d%e6%89%80%e6%9c%89%e5%ad%97%e7%ac%a6%e4%b8%b2%e6%98%af%e4%bb%a5null%e7%bb%93%e6%9d%9f" class="header-anchor"></a>规则13.1 确保所有字符串是以NULL结束。
</h4><p>C语言中’\0’作为字符串的结束符，即NULL结束符。<strong>标准字符串处理函数（如strcpy()、strlen()）依赖NULL结束符来确定字符串的长度。没有正确使用NULL结束字符串会导致缓冲区溢出和其它未定义的行为。</strong>
为了避免缓冲区溢出，常常会用相对安全的限制字符数量的字符串操作函数代替一些危险函数。如：</p>
<ul>
<li>用strncpy()代替strcpy()</li>
<li>用strncat()代替strcat()</li>
<li>用snprintf()代替sprintf()</li>
<li>用fgets()代替gets()</li>
</ul>
<p>错误示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char a[16];strncpy(a, &#34;0123456789abcdef&#34;, sizeof(a));
</span></span></code></pre></td></tr></table>
</div>
</div><p>正确示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char a[16];strncpy(a, &#34;0123456789abcdef&#34;, sizeof(a) - 1 );a[sizeof(a) - 1] = &#39;\0&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="规则132-不要将边界不明确的字符串写到固定长度的数组中"><a href="#%e8%a7%84%e5%88%99132-%e4%b8%8d%e8%a6%81%e5%b0%86%e8%be%b9%e7%95%8c%e4%b8%8d%e6%98%8e%e7%a1%ae%e7%9a%84%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%86%99%e5%88%b0%e5%9b%ba%e5%ae%9a%e9%95%bf%e5%ba%a6%e7%9a%84%e6%95%b0%e7%bb%84%e4%b8%ad" class="header-anchor"></a>规则13.2 不要将边界不明确的字符串写到固定长度的数组中。
</h4><p>边界不明确的字符串（如来自gets()、getenv()、scanf()的字符串），长度可能大于目标数组长度，直接拷贝到固定长度的数组中容易导致缓冲区溢出。
错误示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char buff[256];char *editor = getenv(&#34;EDITOR&#34;);if (editor != NULL){    strcpy(buff, editor);}
</span></span></code></pre></td></tr></table>
</div>
</div><p>正确示例，使用malloc分配指定长度的内存：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char *buff;char *editor = getenv(&#34;EDITOR&#34;);if (editor != NULL){    buff = malloc(strlen(editor) + 1);    if (buff != NULL)    {        strcpy(buff, editor);    }}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="规则133-避免整数溢出"><a href="#%e8%a7%84%e5%88%99133-%e9%81%bf%e5%85%8d%e6%95%b4%e6%95%b0%e6%ba%a2%e5%87%ba" class="header-anchor"></a>规则13.3 避免整数溢出。
</h4><p>当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。带符号和无符号的数都有可能发生溢出。</p>
<h4 id="规则134-避免符号错误"><a href="#%e8%a7%84%e5%88%99134-%e9%81%bf%e5%85%8d%e7%ac%a6%e5%8f%b7%e9%94%99%e8%af%af" class="header-anchor"></a>规则13.4 避免符号错误。
</h4><p>带符号整型转换到无符号整型，最高位（high-order bit）会丧失其作为符号位的功能。如果该带符号整数的值非负，那么转换后值不变；如果该带符号整数的值为负，那么转换后的结果通常是一个非常大的正数。
错误示例，符号错误绕过长度检查：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define BUF_SIZE 10int main(int argc,char* argv[]){    int    length;    char buf[BUF_SIZE];    if (argc != 3)    {        return -1;    }    length = atoi(argv[1]); //如果atoi返回的长度为负数    if (length &lt; BUF_SIZE)  // len为负数，长度检查无效    {        memcpy(buf, argv[2], length); /* 带符号的len被转换为size_t类型的无符号整数，负值被解释为一个极大的正整数。memcpy()调用时引发buf缓冲区溢出 */        printf(&#34;Data copied\n&#34;);    }    else    {        printf(&#34;Too many data\n&#34;);    }}
</span></span></code></pre></td></tr></table>
</div>
</div><p>正确示例，将len声明为无符号整型：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">#define BUF_SIZE 10int main(int argc, char* argv[]){    unsigned int length;    char buf[BUF_SIZE];    if (argc != 3)    {        return -1;    }    length = atoi(argv[1]);    if (length &lt; BUF_SIZE)    {        memcpy(buf, argv[2], length);        printf(&#34;Data copied\n&#34;);    }    else    {        printf(&#34;Too much data\n&#34;);    }    return 0;}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="规则135-避免截断错误"><a href="#%e8%a7%84%e5%88%99135-%e9%81%bf%e5%85%8d%e6%88%aa%e6%96%ad%e9%94%99%e8%af%af" class="header-anchor"></a>规则13.5 避免截断错误。
</h4><p>将一个较大整型转换为较小整型，并且该数的原值超出较小类型的表示范围，就会发生截断错误，原值的低位被保留而高位被丢弃。截断错误会引起数据丢失。
错误示例，符号错误绕过长度检查：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int main(int argc, char* argv[]){    unsigned short total = strlen(argv[1]) + strlen(argv[2]) + 1;        char* buffer = (char*)malloc(total);    strcpy(buffer, argv[1]);    strcat(buffer, argv[2]);    free(buffer);    return 0;}
</span></span></code></pre></td></tr></table>
</div>
</div><p>示例代码中total被定义为unsigned short，相对于strlen()的返回值类型size_t（通常为unsigned long）太小。如果攻击者提供的两个入参长度分别为65500和36，unsigned long的65500+36+1会被取模截断，total的最终值是（65500+36+1）%65536 = 1。malloc()只为buff分配了1字节空间，为strcpy()和strcat()的调用创造了缓冲区溢出的条件。
正确示例，将涉及到计算的变量声明为统一的类型，并检查计算结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">int main(int argc, char* argv[]){    size_t total = strlen(argv[1]) + strlen(argv[2]) + 1;    if ((total &lt;= strlen(argv[1])) || (total &lt;= strlen(argv[2])))    {        /* handle error */        return -1;    }    char* buffer = (char*)malloc(total);    strcpy(buffer, argv[1]);    strcat(buffer, argv[2]);    free(buffer);    return 0;}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="规则136-确保格式字符和参数匹配"><a href="#%e8%a7%84%e5%88%99136-%e7%a1%ae%e4%bf%9d%e6%a0%bc%e5%bc%8f%e5%ad%97%e7%ac%a6%e5%92%8c%e5%8f%82%e6%95%b0%e5%8c%b9%e9%85%8d" class="header-anchor"></a>规则13.6 确保格式字符和参数匹配。
</h4><p>使用格式化字符串应该小心，确保格式字符和参数之间的匹配，保留数量和数据类型。格式字符和参数之间的不匹配会导致未定义的行为。大多数情况下，不正确的格式化字符串会导致程序异常终止。<strong>大部分格式化字符串出问题，都是由于 copy-paste省事导致的，需要格外注意！</strong></p>
<h4 id="规则137-避免将用户输入作为格式化字符串的一部分或者全部"><a href="#%e8%a7%84%e5%88%99137-%e9%81%bf%e5%85%8d%e5%b0%86%e7%94%a8%e6%88%b7%e8%be%93%e5%85%a5%e4%bd%9c%e4%b8%ba%e6%a0%bc%e5%bc%8f%e5%8c%96%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%9a%84%e4%b8%80%e9%83%a8%e5%88%86%e6%88%96%e8%80%85%e5%85%a8%e9%83%a8" class="header-anchor"></a>规则13.7 避免将用户输入作为格式化字符串的一部分或者全部。
</h4><p>调用格式化I/O函数时，不要直接或者间接将用户输入作为格式化字符串的一部分或者全部。攻击者对一个格式化字符串拥有部分或完全控制，存在以下风险：进程崩溃、查看栈的内容、改写内存、甚至执行任意代码。
错误示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char input[1000];if (fgets(input, sizeof(input) - 1, stdin) == NULL){    /* handle error */}input[sizeof(input)-1] = &#39;\0&#39;;printf(input);
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码input直接来自用户输入，并作为格式化字符串直接传递给printf()。当用户输入的是“%s%s%s%s%s%s%s%s%s%s%s%s”，就可能触发无效指针或未映射的地址读取。格式字符%s显示栈上相应参数所指定的地址的内存。这里input被当成格式化字符串，而没有提供参数，因此printf()读取栈中任意内存位置，指导格式字符耗尽或者遇到一个无效指针或未映射地址为止。
正确示例，给printf()传两个参数，第一个参数为”%s”，目的是将格式化字符串确定下来；第二个参数为用户输入input：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char input[1000];if (fgets(input, sizeof(input)-1, stdin) == NULL) {    /* handle error */}input[sizeof(input)-1] = &#39;\0&#39;;printf(“%s”, input);
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="规则138-避免使用strlen计算二进制数据的长度"><a href="#%e8%a7%84%e5%88%99138-%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8strlen%e8%ae%a1%e7%ae%97%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e6%8d%ae%e7%9a%84%e9%95%bf%e5%ba%a6" class="header-anchor"></a>规则13.8 避免使用strlen()计算二进制数据的长度。
</h4><p>strlen()函数用于计算字符串的长度，它返回字符串中第一个NULL结束符之前的字符的数量。因此用strlen()处理文件I/O函数读取的内容时要小心，因为这些内容可能是二进制也可能是文本。
错误示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char buf[BUF_SIZE + 1];if (fgets(buf, sizeof(buf), fp) == NULL){    /* handle error */}buf[strlen(buf) - 1] = &#39;\0&#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码试图从一个输入行中删除行尾的换行符（\n）。如果buf的第一个字符是NULL，strlen(buf)返回0，这时对buf进行数组下标为[-1]的访问操作将会越界。
正确示例，在不能确定从文件读取到的数据的类型时，不要使用依赖NULL结束符的字符串操作函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char buf[BUF_SIZE + 1];char *p;if (fgets(buf, sizeof(buf), fp)) {    p = strchr(buf, &#39;\n&#39;);    if (p)     {        *p = &#39;\0&#39;;    }}else{    /* handle error condition */}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="规则139-使用int类型变量来接受字符io函数的返回值"><a href="#%e8%a7%84%e5%88%99139-%e4%bd%bf%e7%94%a8int%e7%b1%bb%e5%9e%8b%e5%8f%98%e9%87%8f%e6%9d%a5%e6%8e%a5%e5%8f%97%e5%ad%97%e7%ac%a6io%e5%87%bd%e6%95%b0%e7%9a%84%e8%bf%94%e5%9b%9e%e5%80%bc" class="header-anchor"></a>规则13.9 使用int类型变量来接受字符I/O函数的返回值。
</h4><p>字符I/O函数fgetc()、getc()和getchar()都从一个流读取一个字符，并把它以int值的形式返回。如果这个流到达了文件尾或者发生读取错误，函数返回EOF。fputc()、putc()、putchar()和ungetc()也返回一个字符或EOF。
**如果这些I/O函数的返回值需要与EOF进行比较，不要将返回值转换为char类型。**因为char是有符号8位的值，int是32位的值。如果getchar()返回的字符的ASCII值为0xFF，转换为char类型后将被解释为EOF。因为这个值被有符号扩展为0xFFFFFFFF（EOF的值）执行比较。
错误示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char buf[BUF_SIZE];char ch;int i = 0;while ( (ch = getchar()) != &#39;\n&#39; &amp;&amp; ch != EOF ){    if ( i &lt; BUF_SIZE - 1 )    {        buf[i++] = ch;    }}buf[i] = &#39;\0&#39;; /* terminate NTBS */
</span></span></code></pre></td></tr></table>
</div>
</div><p>正确做法：使用int类型的变量接受getchar()的返回值。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">char buf[BUF_SIZE];int ch;int i = 0;while (((ch = getchar()) != &#39;\n&#39;) &amp;&amp; ch != EOF) {    if (i &lt; BUF_SIZE - 1)    {        buf[i++] = ch;    }}buf[i] = &#39;\0&#39;; /* terminate NTBS */
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="规则1310-防止命令注入"><a href="#%e8%a7%84%e5%88%991310-%e9%98%b2%e6%ad%a2%e5%91%bd%e4%bb%a4%e6%b3%a8%e5%85%a5" class="header-anchor"></a>规则13.10 防止命令注入。
</h4><p>如果system()的参数由用户的输入组成，恶意用户可以通过构造恶意输入，改变system()调用的行为。
示例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">system(sprintf(&#34;any_exe %s&#34;, input));
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果恶意用户输入参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">happy; useradd attacker
</span></span></code></pre></td></tr></table>
</div>
</div><p>最终shell会将字符串解释为两条独立的命令：“any_exe happy; useradd attacker”。</p>
<h2 id="14-单元测试"><a href="#14-%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" class="header-anchor"></a>14 单元测试
</h2><h3 id="规则-14"><a href="#%e8%a7%84%e5%88%99-14" class="header-anchor"></a>规则
</h3><h4 id="规则141-在编写代码的同时或者编写代码前编写单元测试用例验证软件设计编码的正确"><a href="#%e8%a7%84%e5%88%99141-%e5%9c%a8%e7%bc%96%e5%86%99%e4%bb%a3%e7%a0%81%e7%9a%84%e5%90%8c%e6%97%b6%e6%88%96%e8%80%85%e7%bc%96%e5%86%99%e4%bb%a3%e7%a0%81%e5%89%8d%e7%bc%96%e5%86%99%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e7%94%a8%e4%be%8b%e9%aa%8c%e8%af%81%e8%bd%af%e4%bb%b6%e8%ae%be%e8%ae%a1%e7%bc%96%e7%a0%81%e7%9a%84%e6%ad%a3%e7%a1%ae" class="header-anchor"></a><strong>规则14.1 在编写代码的同时，或者编写代码前，编写单元测试用例验证软件设计/编码的正确。</strong>
</h4><h3 id="建议-12"><a href="#%e5%bb%ba%e8%ae%ae-12" class="header-anchor"></a>建议
</h3><h4 id="建议141-单元测试关注单元的行为而不是实现避免针对函数的测试"><a href="#%e5%bb%ba%e8%ae%ae141-%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e5%85%b3%e6%b3%a8%e5%8d%95%e5%85%83%e7%9a%84%e8%a1%8c%e4%b8%ba%e8%80%8c%e4%b8%8d%e6%98%af%e5%ae%9e%e7%8e%b0%e9%81%bf%e5%85%8d%e9%92%88%e5%af%b9%e5%87%bd%e6%95%b0%e7%9a%84%e6%b5%8b%e8%af%95" class="header-anchor"></a>建议14.1 单元测试关注单元的行为而不是实现，避免针对函数的测试。
</h4><h2 id="15-可移植性"><a href="#15-%e5%8f%af%e7%a7%bb%e6%a4%8d%e6%80%a7" class="header-anchor"></a>15 可移植性
</h2><h3 id="规则-15"><a href="#%e8%a7%84%e5%88%99-15" class="header-anchor"></a>规则
</h3><h4 id="规则151-不能定义重定义或取消定义标准库平台中保留的标识符宏和函数"><a href="#%e8%a7%84%e5%88%99151-%e4%b8%8d%e8%83%bd%e5%ae%9a%e4%b9%89%e9%87%8d%e5%ae%9a%e4%b9%89%e6%88%96%e5%8f%96%e6%b6%88%e5%ae%9a%e4%b9%89%e6%a0%87%e5%87%86%e5%ba%93%e5%b9%b3%e5%8f%b0%e4%b8%ad%e4%bf%9d%e7%95%99%e7%9a%84%e6%a0%87%e8%af%86%e7%ac%a6%e5%ae%8f%e5%92%8c%e5%87%bd%e6%95%b0" class="header-anchor"></a>规则15.1 不能定义、重定义或取消定义标准库/平台中保留的标识符、宏和函数。
</h4><h3 id="建议-13"><a href="#%e5%bb%ba%e8%ae%ae-13" class="header-anchor"></a>建议
</h3><h4 id="建议151-不使用与硬件或操作系统关系很大的语句而使用建议的标准语句以提高软件的可移植性和可重用性"><a href="#%e5%bb%ba%e8%ae%ae151-%e4%b8%8d%e4%bd%bf%e7%94%a8%e4%b8%8e%e7%a1%ac%e4%bb%b6%e6%88%96%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f%e5%85%b3%e7%b3%bb%e5%be%88%e5%a4%a7%e7%9a%84%e8%af%ad%e5%8f%a5%e8%80%8c%e4%bd%bf%e7%94%a8%e5%bb%ba%e8%ae%ae%e7%9a%84%e6%a0%87%e5%87%86%e8%af%ad%e5%8f%a5%e4%bb%a5%e6%8f%90%e9%ab%98%e8%bd%af%e4%bb%b6%e7%9a%84%e5%8f%af%e7%a7%bb%e6%a4%8d%e6%80%a7%e5%92%8c%e5%8f%af%e9%87%8d%e7%94%a8%e6%80%a7" class="header-anchor"></a>建议15.1 不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。
</h4><p><strong>使用标准的数据类型，有利于程序的移植。</strong></p>
<h4 id="建议152-除非为了满足特殊需求避免使用嵌入式汇编"><a href="#%e5%bb%ba%e8%ae%ae152-%e9%99%a4%e9%9d%9e%e4%b8%ba%e4%ba%86%e6%bb%a1%e8%b6%b3%e7%89%b9%e6%ae%8a%e9%9c%80%e6%b1%82%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e5%b5%8c%e5%85%a5%e5%bc%8f%e6%b1%87%e7%bc%96" class="header-anchor"></a>建议15.2 除非为了满足特殊需求，避免使用嵌入式汇编。
</h4><h2 id="16-业界编程规范"><a href="#16-%e4%b8%9a%e7%95%8c%e7%bc%96%e7%a8%8b%e8%a7%84%e8%8c%83" class="header-anchor"></a>16 业界编程规范
</h2><ul>
<li>《Google C++编程指南》</li>
<li>《汽车业C语言使用规范(MISRA)》</li>
</ul>
<blockquote>
<p>仅供参考，可能有误</p>
</blockquote>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/">嵌入式</a>
        
            <a href="/tags/c%E8%AF%AD%E8%A8%80/">C语言</a>
        
            <a href="/tags/%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/">代码规范</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css"integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI&#43;WdtXRGWt2kTvGFasHpSy3SV"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG&#43;vnGctmUb0ZY0l8"crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"integrity="sha384-&#43;VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4&#43;/RRE05"crossorigin="anonymous"
                defer
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.body, {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ],
            ignoredClasses: ["gist"]
        });})
</script>
    
</article>

    

    

<aside class="related-content--wrapper">
    <h2 class="section-title">相关文章</h2>
    <div class="related-content">
        <div class="flex article-list--tile">
            
                
<article class="has-image">
    <a href="/p/cubemx%E4%B8%8B%E7%9A%84freertos/">
        
        
            <div class="article-image">
                <img src="/p/cubemx%E4%B8%8B%E7%9A%84freertos/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post CubeMX下的freeRTOS"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">CubeMX下的freeRTOS</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/pcb%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AB%8B%E5%88%9Beda%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/">
        
        
            <div class="article-image">
                <img src="/p/pcb%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AB%8B%E5%88%9Beda%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post PCB设计与立创EDA使用备忘录"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">PCB设计与立创EDA使用备忘录</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E6%B5%85%E6%9E%90pid/">
        
        
            <div class="article-image">
                <img src="/p/%E6%B5%85%E6%9E%90pid/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 浅析PID"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">浅析PID</h2>
        </div>
    </a>
</article>

            
                
<article class="has-image">
    <a href="/p/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/">
        
        
            <div class="article-image">
                <img src="/p/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/background.60116b1ccfc8632e9a65f7d51df3efc2_hu2042364712198079406.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy"
                        alt="Featured image of post 物联网协议基础"
                        
                        data-hash="md5-YBFrHM/IYy6aZffVHfPvwg==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">物联网协议基础</h2>
        </div>
    </a>
</article>

            
        </div>
    </div>
</aside>

     
    
        
    <div class="disqus-container">
    <div id="disqus_thread"></div>
<script>
    window.disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "hugo-theme-stack" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
</div>

<style>
    .disqus-container {
        background-color: var(--card-background);
        border-radius: var(--card-border-radius);
        box-shadow: var(--shadow-l1);
        padding: var(--card-padding);
    }
</style>

<script>
    window.addEventListener('onColorSchemeChange', (e) => {
        if (typeof DISQUS == 'object') {
            DISQUS.reset({
                reload: true
            });
        }
    })
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2024 - 
        
        2025 cita
    </section>
    
    <section class="powerby">
        
            Hello World <br/>
        使用 <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> 构建 <br />
        主题 <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.27.0">Stack</a></b> 由 <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a> 设计
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css"crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css"crossorigin="anonymous"
            >

            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js"integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z&#43;KMkF24hUW8WePSA9HM="crossorigin="anonymous"
                
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
