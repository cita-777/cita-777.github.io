[{"content":"CubeMX使用FreeRTOS编程指南 一、开发前言 CMSIS是一种接口标准，目的是屏蔽软硬件差异以提高软件的兼容性。RTOS v1使得软件能够在不同的实时操作系统下运行（屏蔽不同RTOS提供的API的差别)，而RTOS v2则是拓展了RTOS v1，兼容更多的CPU架构和实时操作系统。因此我们在使用时可以根据实际情况选择，如果学习过程中使用STM32F1、F4等单片机时没必要选择RTOS v2，更高的兼容性背后时更加冗余的代码，理解起来比较困难。\n使用 STM32CubeMX 代码生成，在 STM32Cube 固件中，通过 ARM 提供的通用 CMSIS-OS（ cmsis_os.h 和 cmsis_os.c 文件，这两个文件把给 FreeRTOS 封装了一层，调用这其中的各类函数，和直接调用 FreeRTOS 的函数没有区别 ） 封装层，将 FreeRTOS 用作实时操作系统。也就是说在一套代码里有着两套标准，在阅读源码时需要注意区分。大多数教程讲解 FreeRTOS 的函数，此处说明ARM封装后函数。\n二、配置界面 开启 FreeRTOS 之后，可以看到配置项主要分为以下几个部分\n这几个部分的主要功能如下表：\n配置项 功能 Tasks and Queues 任务与队列，用于配置任务体以及消息队列； Timers and Semaphores 软件定时器与信号量，用于配置内核对象 （软件定时器和信号量）； Mutexes 互斥量，用于配置内核对象（互斥量） Events 事件，配置内核对象（事件） FreeRTOS Heap Usage 查看用户任务和系统任务的堆占用 Config Parameters 系统的参数配置 Include Parameters 系统的功能裁剪 Advanced Settings CubeMX 生成代码预配置项 User Constants 用户常量定义 以上各个功能分的很清晰，我们需要配置什么功能就去对应的选项下进行配置，下面根据各个配置项进行详细配置介绍\n三、系统设置 首先我们先了解一下 Config Parameters，他的配置参数如下\n参数功能表：\n参数 功能 API 显示 FreeRTOS API 接口版本 Version 显示 FreeRTOS 内核版本，CMSIS 版本 Kernel Setting FreeRTOS 调度内核设置 Memory management setting 内存管理设置 Hook function related definitions 钩子函数有关定义 Run time and task stats gathering related definitions 系统运行时的参数收集配置 Co-routine related definitions 协程配置 Software timer definitons 软件定时器任务配置 Interrupt nesting behaviour configuration 中断优先级配置 API 和 Version 不过多解释，显示版本信息\n2.1 调度内核设置 Kernel Setting 是 FreeRTOS 的调度内核配置，展开后有下面的配置项，使用时一般保持默认，也可以根据需要修改\n![屏幕截图 2024-12-18 114744](D:\\Desktop\\各类工程文件\\cita-site\\content\\post\\cubeMX下的freeRTOS\\屏幕截图 2024-12-18 114744.png)\nUSE_PREEMPTION USE_PREEMPTION 是 RTOS 的调度方式选择，为 1 时使用抢占式调度器，为 0 时使用协程，如果使用抢占式调度器的话内核会在每个时钟节拍中断中进行任务切换，当使用协程的话会在如下地方进行任务切换\n一个任务调用了函数 taskYIELD()。 一个任务调用了可以使任务进入阻塞态的 API 函数。 应用程序明确定义了在中断中执行上下文切换。 CPU_CLOCK_HZ CPU_CLOCK_HZ 是 CPU 系统时钟频率，默认使用的是晶振通过时钟树后获得的时钟频率\nTICK_RATE_HZ TICK_RATE_HZ 是 RTOS 的心跳时钟频率，默认为最大值 1000 ，即心跳时钟 1ms 跳动一次\nMAX_PRIORITIES MAX_PRIORITIES 是 RTOS 任务的最高优先级设置，默认56级，一般来说一个优先级表是32位，这里用了两个，对应64位，其中8位用于系统任务的优先级处理\nMINIMAL_STACK_SIZE MINIMAL_STACK_SIZE 设置分配给空闲任务的堆栈大小，该值是用字（32位）指定的，而不是字节，默认为128个字，如果修改过空闲任务，则根据实际情况修改\nMAX_TASK_NAME_LEN MAX_TASK_NAME_LEN 设置任务名称的最大字符数，默认16位足够\nUSE_16_BIT_TICKS USE_16_BIT_TICKS 存放 Tick 周期的计数器的数字位宽，默认为 Disable 即 16 位\nIDLE_SHOULD_YIELD 如果IDLE_SHOULD_YIELD 设置为0，则空闲任务永远不会让位于另一个任务，只在被抢占时才会离开运行状态。如果 IDLE_SHOULD_YIELD 设置为1，那么当有另一个空闲优先级任务处于Ready状态时，空闲任务将不会执行它定义的功能的不止一次迭代，而不会让位于另一个任务，这确保当应用程序任务处于空闲状态时，在空闲任务中花费的时间最少，即同在空闲优先级下，空闲任务优先级更高，不会被抢占，不会以时间片运行\nUSE_MUTEXES、USE_RECURSIVE_MUTEXES、USE_COUNTING_SEMAPHORES 为 1 则开启系统构建过程中的互斥量、递归互斥量和信号量，该值强制为1（ENABLE）\nQUEUE_REGISTRY_SIZE 队列注册表的大小，可以用于管理队列名称和队列实体，方便运行中进行查看与管理，默认为8\nUSE_APPLICATION_TASK_TAG 使能时会给任务一个 TAG 标签，便于用户进行使用\nENABLE_BACKWARD_COMPATIBILITY 一个兼容性使能，使能后， FreeRTOS 8.0.0 之后的版本可以通过宏定义使用 8.0.0 版本之前的函数接口，默认使能\nUSE_PORT_OPTIMISED_TASK_SELECTION 查找下一个任务方式的选择，查找下一个就绪任务就是查找优先级表，对优先级表进行导0算法，分为通用切换或者针对性切换，一般默认不使能，使用通用切换，通用切换使用C编写，执行效率低，兼容性高；针对性切换使用处理器自带的导0指令，使用汇编编写，切换效率高，但兼容性差\nUSE_TICKLESS_IDLE 使能后会生成的两个空函数PreSleepProcessing和PostSleepProcessing，用户可以编写代码进入低功耗模式，生成函数如下图\n![屏幕截图 2024-12-18 114807](D:\\Desktop\\各类工程文件\\cita-site\\content\\post\\cubeMX下的freeRTOS\\屏幕截图 2024-12-18 114807.png)\nUSE_TASK_NOTIFICATIONS 任务通知使能，每个RTOS任务都有一个32位的通知值，RTOS任务通知是一个直接发送给任务的事件，它可以解除接收任务的阻塞，并可选地更新接收任务的通知值，为1开启，为0关闭，关闭可以为每个任务节省8个字节的内存空间\nRECORD_STACK_HIGH_ADDRESS 记录任务的堆栈入口地址到TCB，为1使能，为0关闭\n2.2 内存管理设置 内存管理可以看到3个配置参数\n![屏幕截图 2024-12-18 114823](D:\\Desktop\\各类工程文件\\cita-site\\content\\post\\cubeMX下的freeRTOS\\屏幕截图 2024-12-18 114823.png)\nMemory Allocation 内存分配方式，此处默认动态和静态都可以\nTOTAL_HEAP_SIZE 内存堆的分配大小，堆本质上就是一个数组，此处是设置堆数组的大小，设置时要考虑最小要满足所有任务的使用要求，最大不要超过系统的分配上限\nMemory Management scheme 内存分配方式，有heap_1.c, heap_2.c, heap_3.c, heap_4.c and heap5.c 5种，其中1、2、4、5都是先建立一个堆数组，从数组中申请，用完再释放，与C语言中molloc和free使用链表的方式不同，该方式在 MCU 中更安全稳定，此处默认使用的方式4，具体申请释放方式可以在heap4.c中阅读到\n2.3 钩子函数配置 钩子函数是一种回调函数，用于在任务执行一次之后或者某些事件发生后执行的函数，该配置项里面有五个选项，控制5种不同功能的钩子函数开启，当然用户也可以在代码中自己定义\nUSE_IDLE_HOOK 使能后，系统生成一个空回调函数，由用户编写函数主体\n1 2 void vApplicationIdleHook(void) 1 每当空闲任务执行一次，钩子函数都会被执行一次\nUSE_TICK_HOOK 使能后，系统生成一个空回调函数，由用户编写函数主体\n1 2 void vApplicationTickHook(void) 1 每个TICK周期，钩子函数都会执行一次\nUSE_MALLOC_FAILED_HOOK 使能后，系统生成一个空回调函数，由用户编写函数主体\n1 2 void vApplicationMallocFailedHook(void) 1 当申请动态内存失败时，钩子函数会执行一次\nUSE_DAEMON_TASK_STARTUP_HOOK 使能后，系统生成一个空回调函数，由用户编写函数主体\n1 2 void vApplicationDaemonTaskStartupHook(void). 1 任务刚启动时，钩子函数会执行一次\nCHECK_FOR_STACK_OVERFLOW 使能后，系统生成一个空回调函数，由用户编写函数主体\n1 2 void vApplicationStackOverflowHook( xTaskHandle xTask, signed char *pcTaskName ); 1 任务栈溢出时，钩子函数会执行一次，传入任务 TCB 和任务名称\n当我们在 CubeMX 里面开启对应钩子函数，生成代码之后，在FreeRTOS就可以看到自动生成的钩子函数，我们在里面编写相应的功能就行\n2.5 任务运行追踪配置 功能配置项如下：\nGENERATE_RUN_TIME_STATS 开启时间统计功能，在调用 vTaskGetRunTimeStats() 函数时，将任务运行时间信息保存到可读列表中\nUSE_TRACE_FACILITY 使能后会包含额外的结构成员和函数以帮助执行可视化和跟踪，默认开启，方便 MDK 软件工具调试使用\nUSE_STATS_FORMATTING_FUNCTIONS 使能后会生成 vTaskList() 和 vTaskGetRunTimeStats() 函数用于获取任务运行状态\n2.6 协程配置 Co-routine related definitions 是协程的配置项，两个选项用来配置协程是否开启，以及协程的优先级，开启后，需要用户手动创建协程，在协程几乎很少用到了，是 FreeRTOS目前还没有把协程移除的计划，但 FreeRTOS是不会再更新和维护协程了，因此大家解一下就行\n协程特点：\n堆栈使用\n所有的协程使用同一个堆栈(如果是任务的话每个任务都有自己的堆栈)，这样就比使用任务消耗更少的 RAM 调度器和优先级\n协程使用合作式的调度器，但是可以在使用抢占式的调度器中使用协程 宏实现\n协程是通过宏定义来实现的 使用限制\n为了降低对 RAM 的消耗做了很多的限制 具体 API 接口和调度原理可以参考这篇文章 : FreeRTOS协程\n2.7 软件定时器配置 软件定时器配置的一些相关项如下：\n这四个配置项主要与软件定时器处理任务有关，软件定时器任务属于系统任务（守护线程），开启软件定时器后用于维护软件定时器\nUSE_TIMERS 默认开启软件定时器任务\nTIMER_TASK_PRIORITY 软件定时器任务优先级\nTIMER_QUEUE_LENGTH 定时器任务队列长度，FreeRTOS 是通过队列来发送控制命令给定时器任务，叫做定时器命令队列，此处设置队列长度\nTIMER_TASK_STACK_DEPTH 软件定时器任务堆栈大小\n2.8 中断优先级配置 LIBRARY_LOWEST_INTERRUPT_PRIORITY 此宏是用来设置最低优先级，FreeRTOS 使用的4位优先级，对应16位优先级，对应的最低优先级为15\nLIBRARY_MAX_SYSCALL_INTERRUPT_PRIORITY 设置FreeRTOS 系统可管理的最大优先级，也就是设置阈值优先级，这个大家可以自由设置，这里设置为5，也就是高于5 的优先级(优先级数小于5)不归 FreeRTOS 管理\n三、内核裁剪 Include Parameters 下的选项应用于内核裁剪，裁剪不必要的功能，精简系统功能，减少资源占用，主要有以下几个选项：\n配置项可裁剪的函数功能如下：\n选项 功能 vTaskPrioritySet 改变某个任务的任务优先级。 uxTaskPriorityGet 查询某个任务的优先级。 vTaskDelete 删除任务 vTaskCleanUpResources 回收任务删除后的资源如RAM等等 vTaskSuspend 挂起任务 vTaskDelayUntil 阻塞延时一段绝对时间（绝对延时去去除程序执行时间，执行更精准） vTaskDelay 阻塞延时一段相对时间 xTaskGetSchedulerState 获取任务调度器的状态，开启或未开启 xTaskResumeFromISR 在中断服务函数中恢复一个任务的运行 xQueueGetMutexHolder 获取信号量的队列拥有者，返回拥有此信号量的队列 xSemaphoreGetMutexHolder 查询拥有互斥锁的任务，返回任务控制块 pcTaskGetTaskName 获取任务名称 uxTaskGetStackHighWaterMark 获取任务的堆栈的历史剩余最小值，FreeRTOS 中叫做“高水位线” xTaskGetCurrentTaskHandle 此函数用于获取当前任务的任务句柄，就是获取当前任务控制块 eTaskGetState 此函数用于查询某个任务的运行壮态，比如：运行态、阻塞态、挂起态、就绪态等 xEventGroupSetBitFromISR 在中断服务函数中将指定的事件位清零 xTimerPendFunctionCall 定时器守护任务的回调函数（定时器守护任务使用到一个命令队列，只要向队列发送信号就可以执行相应代码，可以实现“中断推迟处理”功能） xTaskAbortDelay 中止延时函数，该函数能立即解除任务的阻塞状态，将任务插入就绪列表中 xTaskGetHandle 此函数根据任务名字获取的任务句柄（控制块） 四、创建任务与队列 4.1 CubeMX 下任务创建与配置 任务（线程）是操作系统运行的基本单元，也是资源分配的基本单元， CubeMX 任务的创建基本以图形化进行，配置方式如下\n进入Tashs and Queues 配置，点击 Add 添加新任务\n任务配置参数介绍\n参数 功能 Task Name 任务名称，保存在 TCB 结构体中，设置时自己起名字 Priority 任务优先级，任务的调度等级，根据自己创建任务的紧急程度设定 比如通信任务不能被打断，可以设计较高优先级 Stack Size（Words） 设定给任务分配的内存大小，单位是字，对于32位单片机来说占4个字节 Entry Function 任务实体，即任务的运行函数名 Code Generation 代码生成模式 As weak： 产生一个用 __weak 修饰的弱定义任务函数，用户可自己在进行定义； As external： 产生一个外部引用的任务函数，用户需要自己定义该函数； Default： 产生一个默认格式的任务函数，用户需要在该函数内实现自己的功能 Parameter: 传入的参数，保持默认就行 Allocation: 内存分配方式 Static： 静态方式是直接在RAM占据一个静态空间 Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间 设置完成后点击OK，配置就完成了，之后生成代码，使用 MDK 进一步配置任务的具体信息\n在生成的代码中，我们打开 freertos.c 文件可以在代码中看到任务的配置信息\n在 freertos.c 文件的末尾部分，我们可以看到生成的任务实体\n任务实体本身就是一个死循环函数，循环执行程序代码，但循环体代码里面必须要有延时函数，释放当前任务对 MCU 的控制权，使其他低优先级可以执行，此外，关于任务，CubeMX 提供了一系列的用户调用接口函数，具体如下\n函数 功能 osThreadNew 创建新任务 *osThreadGetName 获取任务名称 osThreadGetId 获取当前任务的控制块（TCB） osThreadGetState 获取当前任务的运行状态 osThreadGetStackSize 获取任务的堆栈大小 osThreadGetStackSpace 获取任务剩余的堆栈大小 osThreadSetPriority 设定任务优先级 osThreadGetPriority 获取任务优先级 osThreadYield 切换控制权给下一个任务 osThreadSuspend 挂起任务 osThreadResume 恢复任务（挂起多少次恢复多少次） osThreadDetach 分离任务，方便任务结束进行回收 osThreadJoin 等待指定的任务停止 osThreadExit 停止当前任务 osThreadTerminate 停止指定任务 osThreadGetCount 获取激活的任务数量 osThreadEnumerate 列举激活的任务 4.2 CubeMX 下队列的创建与配置 队列，又称为消息队列，用于任务间的数据通信，传输数据，在操作系统里面，直接使用全局变量传输数据十分危险，看似正常运行，但不知道啥时候就会因为寄存器或者内存等等原因引起崩溃，所以引入消息，队列的概念，任务发送数据到队列，需要接受消息的任务挂起在队列的挂起列表，等待消息的到来，CubeMX 创建队列的步骤如下：\n先点击 Add 添加队列\n队列配置参数介绍\n参数 功能 Queue Name 队列名称（自己设定） Queue Size 消息队列大小 Item Size 队列传输类型，保持默认16 位就行 Allocation 队列内存的分配方式 Static： 静态方式是直接在RAM占据一个静态空间 Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间 配置需要的参数后，点击OK，然后生成代码\n生成代码后，我们可以在 freertos.c 中系统初始话函数中看到队列的初始化\n初始化函数会在一开始被调用，对 FreeRTOS 系统和内核对象进行初始化，初始化后系统就可以进行调度和使用内核对象，CubeMX 生成的代码自动将创建的内核对象放到初始化函数内，所以我们在任务和中断中直接使用就可以，队列的 FreeRTOS API 接口在CubeMX 内再次进行了封装，使用更加简单，使用方式如下：\n我们使用的 CMSIS 2.0 版本，所以在任务文件中包含调用声明头文件\n1 2 #include \u0026#34;cmsis_os2.h\u0026#34; 1 在队列头文件内我们可以在 600 多行的位置找到有关队列的 API 函数声明：\n下面介绍一下队列有关接口的函数接口：\n函数 功能 osMessageQueueNew 创建并初始化一个新的队列 osMessageQueueGetName 获取队列的名字 osMessageQueuePut 发送一条消息到队列 osMessageQueueGet 从队列等待一条消息 osMessageQueueGetCapacity 获取队列传输消息的峰值 osMessageQueueGetMsgSize 获取队列使用内存池的最大峰值 osMessageQueueGetCount 获取队列的消息数量 osMessageQueueGetSpace 获取队列剩余的可用空槽 osMessageQueueReset 清空队列 osMessageQueueDelete 删除队列 以上的API接口有其对应的传入参数，具体使用方式需要在翻源码的注释，这里我选常用的来介绍一下：\n消息队列常用的是插入与获取消息，初始化系统已经帮助我们完成，在初始化的时候会获取一个队列的句柄，之后对队列的操作都是围绕这个句柄展开，比如上面的代码中，句柄就是 myQueue01Handle ，我们发送一个消息到这个队列，就是调用发送函数，对句柄进行操作，先看一下发送消息的函数原型\n1 2 osStatus_t osMessageQueuePut (osMessageQueueId_t mq_id, const void *msg_ptr, uint8_t msg_prio, uint32_t timeout); 1 参数的功能\n参数 功能 mq_id 传入队列的句柄 *msg_ptr 指向需要发送的消息内容的指针 msg_prio 本次发送消息的优先级（目前API未加入功能） timeout 发送消息的超时时间（设置为0代表一直等待发送成功） osStatus_t（返回值） 返回执行结果 返回值的可能\n错误 含义 osOK 执行正常 osError 系统错误 osErrorTimeout 执行超时 osErrorResource 资源不可用 osErrorParameter 参数无效 osErrorNoMemory 内存不足 osErrorISR 不允许在中断调用 osStatusReserved 防止编译器优化项，不需要管他 所以我们发送一个消息到队列，函数用法如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void StartTask02(void *argument) { /* USER CODE BEGIN StartTask02 */ osStatus_t result; uint8_t dat[]=\u0026#34;666\\r\\n\u0026#34;; /* Infinite loop */ for(;;) { result= osMessageQueuePut(myQueue01Handle,dat,1,0); if(result == osOK) { //发送成功 }else { //发送失败 } osDelay(1); } /* USER CODE END StartTask02 */ } 1234567891011121314151617181920 发送消息的优先级暂时无用，CubeMX 对 FreeRTOS 的支持还不完善，发送消息里面的优先级未使用到，并且入队方式使用的是发送到队列尾部，没有从头部插入的方式，有需求可以 通过包含 queue.h 文件，调用 FreeRTOS 的官方代码，或者自己修改 生成代码的 API 接口结合优先级使用队列的向前插入和向后插入，丰富系统功能！\n除了发送消息到队列，接受队列的消息 API 接口也经常用到，函数原型如下\n1 2 osStatus_t osMessageQueueGet (osMessageQueueId_t mq_id, void *msg_ptr, uint8_t *msg_prio, uint32_t timeout); 1 参数的功能\n参数 功能 mq_id 接受队列的句柄 *msg_ptr 用于接受消息内容的指针 msg_prio 存放接受消息的优先级（目前API未加入功能） timeout 接受消息的超时时间（设置为10代表，当前任务挂起在挂起列表，直到接收成功时恢复，或者10个TICK等待周期到达然后任务强行恢复，不再等待，为0则是不等待，等待期间任务挂起在内核对象的挂起队列） osStatus_t（返回值） 返回执行结果 函数用法\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void StartTask02(void *argument) { /* USER CODE BEGIN StartTask02 */ osStatus_t result; uint8_t dat[10]={}; uint8_t *pro; /* Infinite loop */ for(;;) { result= osMessageQueueGet(myQueue01Handle,dat,pro,10); if(result == osOK) { //接受成功 }else { //接受失败 } osDelay(1); } /* USER CODE END StartTask02 */ } 123456789101112131415161718192021 注意：FreeRTOS 中获取和发送消息的 API 接口函数分为任务中调用和中断中调用，CubeMX 代码接口将两者整合了，调用时自动判断调用环境是在 ISR 还是正常运行环境中\n五、创建定时器和信号量 5.1 CubeMX下定时器的创建和配置 软件定时器本质上就是设置一段时间，当设置的时间到达之后就执行指定的功能函数，调用的这个函数叫做回调函数。回调函数的两次执行间隔叫做定时器的定时周期，简而言之，当定时器的定时周期到了以后就会执行回调函数，下面介绍一下 CubeMX 中开启定时器的方法：\n在 CubeMX 里面按下面步骤添加定时器\n然后配置具体参数，参数的功能如下：\n参数 功能 Timer Name 设置定时器的名称 Callback 设定定时器的回调函数体 Type 设定定时器的执行类型 osTimerPeriodic 定时器周期执行回调函数 osTimerOnce 定时器只执行一次回调函数 Code Generation Option 代码生成模式 As weak： 产生一个用 __weak 修饰的弱定义任务函数，用户可自己在进行定义； As external： 产生一个外部引用的任务函数，用户需要自己定义该函数； Default： 产生一个默认格式的任务函数，用户需要在该函数内实现自己的功能 Parameter 传入参数，保持默认NULL就行 Allocation 软件定时器内存的分配方式，一般使用动态 Static： 静态方式是直接在RAM占据一个静态空间 Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间 参数配置完成后，生成代码，我们可以在 freertos.c 文件里面看到定时器创建后获得的句柄，以及生成的回调函数：\n有了句柄，我们就可以调用 cmsis_os2.c 里面的定时器接口函数对定时器进行操作，先看一下 CubeMX 提供的定时器接口函数及其功能\n函数 功能 osTimerNew 新建定时器，返回定时器控制句柄 osTimerGetName 获取定时器名称 osTimerStart 设置定时器周期，启动定时器 osTimerStop 停止定时器 osTimerIsRunning 检测定时器是否在运行 osTimerDelete 删除定时器 其中常用的接口是定时器的启动和停止\n定时器启动： osTimerStart，函数原型\n1 2 osStatus_t osTimerStart (osTimerId_t timer_id, uint32_t ticks); 1 参数介绍：\n参数 功能 timer_id 需要启动的定时器句柄 ticks 设置定时器的运行周期 此处的 ticks 设定的数字是定时器两次调用回调函数的周期数目，每个 tick 是一个心跳时钟的长度\n使用例程：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 void StartTask02(void *argument) { /* USER CODE BEGIN StartTask02 */ osStatus_t result; uint8_t dat[10]={0}; uint8_t *pro; result= osTimerStart(myTimer01Handle,10); if(result == osOK) { //启动成功 }else { //启动失败 } /* Infinite loop */ for(;;) { osDelay(10); } /* USER CODE END StartTask02 */ } 123456789101112131415161718192021222324 按照例程启动定时器，定时器会以 10个tick 的周期，调用回调函数\n回调函数不要放阻塞函数，程序尽可能短\n定时器启动： osTimerStop，函数原型\n1 2 osStatus_t osTimerStop (osTimerId_t timer_id); 1 参数只有一个，就是定时器的控制句柄，传入即可停止定时器，例程如下\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void StartTask02(void *argument) { /* USER CODE BEGIN StartTask02 */ osStatus_t result; uint8_t dat[10]={0}; uint8_t *pro; result= osTimerStop(myTimer01Handle); if(result == osOK) { //停止成功 }else { //停止失败 } /* Infinite loop */ for(;;) { osDelay(10); } /* USER CODE END StartTask02 */ } 123456789101112131415161718192021 软件定时器是由软件定时器维护任务进行维护，检测各个定时器的状态，进行处理，回调回调函数，软件定时器维护任务的参数配置在前面的 Config 就已经提到过\n5.2 CubeMX下信号量的创建和配置 信号量是 RTOS 的一个内核对象，该对象有一个队列表示该信号量拥有的信号数目，任何任务都可以对这个信号数目进行获取和释放，获取时信号-1，释放时信号+1，为0时不能继续获取，此时有任务想要继续获取信号量的话，任务会挂起在该内核对象的挂起列表，等到信号可以获取时进行恢复，根据这个特性，信号量常用于控制对共享资源的访问和任务同步，下面介绍一下 CubeMX 下信号量的配置：\n点开配置页面，可以看到有两个信号量添加页面，其中 Binary Semaphores 是二值信号量，Counting Semaphores 是计数信号量，二进制信号量，仅有一个队列或者说 token，用于同步一个操作；计数信号量则拥有多个 tokens，可用于同步多个操作，或者管理有限资源\n二值信号量创建：\n点击 Add，配置参数\n参数介绍\n参数 功能 Semaphore Name 信号量名称 Allocation 内存分配方式，一般使用动态 Static： 静态方式是直接在RAM占据一个静态空间 Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间 计数信号量：\n点击 Add，配置参数\n参数介绍\n参数 功能 Semaphore Name 信号量名称 Count 计数信号量的最大数目 Allocation 内存分配方式，一般使用动态 Static： 静态方式是直接在RAM占据一个静态空间 Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间 配置完成后我们生成代码，在 freertos.c 的初始化代码中可以看到信号量被创建，并且返回了信号量的控制句柄\n下面介绍一下 CubeMX 提供的信号量操作函数接口：\n函数 功能 osSemaphoreNew 创建新的信号量 *osSemaphoreGetName 获取信号量的名称 osSemaphoreAcquire 获取信号量 osSemaphoreRelease 释放信号量 osSemaphoreGetCount 获取当前可用信号量的数目 osSemaphoreDelete 删除信号量 其中常用的函数有获取和释放信号量，下面介绍一下这两个函数的参数和使用方式\n获取信号量 osSemaphoreAcquire\n函数原型\n1 2 osStatus_t osSemaphoreAcquire (osSemaphoreId_t semaphore_id, uint32_t timeout); 1 参数介绍\n参数 功能 semaphore_id 传入要获取信号量的控制句柄 timeout 获取等待时间（等待期间任务挂起在内核对象的挂起队列） 使用例程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void StartDefaultTask(void *argument) { /* USER CODE BEGIN StartDefaultTask */ osStatus_t result; /* Infinite loop */ for(;;) { result = osSemaphoreAcquire(myBinarySem01Handle,10); if(result == osOK) { //获取成功 }else { //获取失败 } osDelay(1); } /* USER CODE END StartDefaultTask */ } 123456789101112131415161718192021 释放信号量 osSemaphoreRelease\n函数原型\n1 2 osStatus_t osSemaphoreRelease (osSemaphoreId_t semaphore_id); 1 参数 功能 semaphore_id 传入要释放的信号量控制句柄 使用例程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 void StartDefaultTask(void *argument) { /* USER CODE BEGIN StartDefaultTask */ osStatus_t result; /* Infinite loop */ for(;;) { result = osSemaphoreRelease(myBinarySem01Handle); if(result == osOK) { //释放成功 }else { //释放失败 } osDelay(1); } /* USER CODE END StartDefaultTask */ } 123456789101112131415161718192021 二值信号量和计数信号量的操作基本一致，没用区别，只是用有的信号队列最大数目不同而已\n同时注意信号量在使用过程中会出现优先级反转的Bug，使用时需要注意\n六、创建互斥量 6.1 CubeMX下互斥量的创建和配置 互斥量其实就是一个拥有优先级继承的二值信号量，互斥信号量适合用于那些需要互斥访问的应用中，在互斥访问中互斥信号量相当于一个钥匙，当任务想要使用资源的时候就必须先获得这个钥匙，当使用完资源以后就必须归还这个钥匙，这样其他的任务就可以拿着这个钥匙去使用资源，与信号量不同的是，互斥量的释放必须由获取他的任务进行释放，如果不释放，可能会造成死锁\n死锁就是两个任务获取对方拥有的锁，各自进入挂起列表，无法释放互斥锁\n下面介绍一下 CubeMX 下互斥量的配置，在配置界面我们可用看到两个互斥量配置界面，上面的是普通互斥量，其获取只能获取一次，重复获取是无效的，而第二个则是递归互斥量，递归互斥信号量可以获取多次，但对应的也要释放多次才能让出使用权，比如我获取3次，任务要释放3次才能释放该互斥量的使用权\n使用互斥量，需要点击 Add 然后配置参数\n参数介绍：\n参数 功能 Mutex Name 互斥量名称 Allocation 内存分配方式，一般使用动态 Static： 静态方式是直接在RAM占据一个静态空间 Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间 递归互斥信号量的配置方式与其相同，包括配置参数也相同，两者只是在用法上有些许区别，添加方式如下：\n添加配置完成后，点击生成代码，在 freertos.c 文件中我们可以看到互斥量初始化完成，并且生成了对应的控制句柄\nCubeMX 提供的 API 接口函数如下\n函数 功能 osMutexNew 创建互斥量 *osMutexGetName 获取互斥量名称 osMutexAcquire 任务获取互斥量 osMutexRelease 任务释放互斥量 osMutexGetOwner 获取互斥量的拥有任务的任务 TCB osMutexDelete 删除互斥量 主要使用到的还是互斥量的获取与释放，下面分析一下这两个函数：\n获取互斥量 osMutexAcquire\n函数原型\n1 2 osStatus_t osMutexAcquire (osMutexId_t mutex_id, uint32_t timeout); 1 参数介绍：\n参数 功能 mutex_id 互斥量控制句柄 timeout 获取互斥量时的等待时间（等待期间任务挂起在内核对象的挂起队列） 使用方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void StartTask02(void *argument) { /* USER CODE BEGIN StartTask02 */ osStatus_t result; result= osMutexAcquire(myMutex01Handle,10); if(result == osOK) { //获取成功 }else { //获取失败 } /* Infinite loop */ for(;;) { osDelay(10); } /* USER CODE END StartTask02 */ } 12345678910111213141516171819 释放互斥量 osMutexRelease\n函数原型\n1 2 osStatus_t osMutexRelease (osMutexId_t mutex_id); 1 参数介绍：\n参数 功能 mutex_id 互斥量控制句柄 使用方式\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void StartTask02(void *argument) { /* USER CODE BEGIN StartTask02 */ osStatus_t result; result= osMutexRelease(myMutex01Handle); if(result == osOK) { //释放成功 }else { //释放失败 } /* Infinite loop */ for(;;) { osDelay(10); } /* USER CODE END StartTask02 */ } 12345678910111213141516171819 使用方式和信号量基本相同，因为互斥量本质上就是信号量的一种\n七、创建事件标志组 7.1 CubeMX下事件的创建和配置 任务间的同步除了信号量还有时间标志组，信号的同步通常是一对一的同步，有的时候系统需要多对一的同步，比如同时满足5个按键按下时，任务启动，如果使用信号会很占据资源，所以 RTOS 引入了事件标志组来满足这一需求，下面我们看一下 CubeMX 内事件标志组的配置方法：\n点击 Add 创建事件标志组\n配置介绍\n参数 功能 Event flags Name 事件标志组名称 Allocation 内存分配方式，一般使用动态 Static： 静态方式是直接在RAM占据一个静态空间 Dynamic：动态方则是在初始配置的内存池大小数组中动态申请、释放空间 配置完成后，生成代码，在系统初始化内，看有没有生成事件标志组控制句柄，可以看到句柄创建完成\nCubeMX 提供的配置事件标志组的接口 API 如下：\n函数 功能 osEventFlagsNew 创建事件标志组 *osEventFlagsGetName 获取事件标志组名称 osEventFlagsSet 设置事件标志组 osEventFlagsClear 清除事件标志组 osEventFlagsGet 获取当前事件组标志信息 osEventFlagsWait 等待事件标志组触发 osEventFlagsDelete 删除事件标志组 常用的 API 接口是设置事件标志组以及等待事件标志组的触发，下面我们分析一下这两个 API\n在了解 API 前我们需要简单了解一下事件的触发原理：首先事件标志组的数据类型为 EventGroupHandle_t，事件标志组中的所有事件位都存储在一个无符号的 EventBits_t 类型的变量中，当 configUSE_16_BIT_TICKS 为 1 的时候事件标志组可以存储 8 个事件位，当 configUSE_16_BIT_TICKS 为 0 的时候事件标志组存储 24个事件位，每个事件位其实就是一个0或者1数字，就像下面的24位组成一个事件标志组\n我们在使用事件API接口函数前需要先定义我们需要的触发事件位，比如添加如下的代码\n1 2 3 #define event1 1\u0026lt;\u0026lt;1 //事件1 #define event2 1\u0026lt;\u0026lt;2 //事件2 12 编写好触发事件后，我们在看如何使用 API 接口\n设置事件标志 osEventFlagsSet\n函数原型\n1 2 uint32_t osEventFlagsSet (osEventFlagsId_t ef_id, uint32_t flags); 1 参数介绍：\n参数 功能 ef_id 事件标志组控制句柄 flags 事件位 使用方式：设置事件1和事件2\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void StartDefaultTask(void *argument) { /* USER CODE BEGIN StartDefaultTask */ osStatus_t result; /* Infinite loop */ for(;;) { result = osEventFlagsSet(myEvent01Handle,event1); if(result == osOK) { //事件1设置成功 }else { //事件1设置失败 } result = osEventFlagsSet(myEvent01Handle,event2); if(result == osOK) { //事件2设置成功 }else { //事件2设置失败 } osDelay(1); } /* USER CODE END StartDefaultTask */ } 123456789101112131415161718192021222324252627 等待事件标志 osEventFlagsWait\n函数原型\n1 2 uint32_t osEventFlagsWait (osEventFlagsId_t ef_id, uint32_t flags, uint32_t options, uint32_t timeout); 1 参数介绍：\n参数 功能 ef_id 事件标志组控制句柄 flags 等待的事件位 options 等待事件位的操作 osFlagsWaitAny ：等待的事件位有任意一个等到就恢复任务 osFlagsWaitAll：等待的事件位全部等到才恢复任务 osFlagsNoClear：等待成功后不清楚所等待的标志位（默认清除） timeout 等待事件组的等待时间（等待期间任务挂起在内核对象的挂起队列） 使用例子：同时等待事件1和事件2，且等待到不清除\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 void StartDefaultTask(void *argument) { /* USER CODE BEGIN StartDefaultTask */ osStatus_t result; /* Infinite loop */ for(;;) { result = osEventFlagsWait(myEvent01Handle,event1|event2,osFlagsWaitAll|osFlagsNoClear,10); if(result == osOK) { //等待成功 }else { //等待失败 } osDelay(1); } /* USER CODE END StartDefaultTask */ } 12345678910111213141516171819 八、用户常量 User Constants 用于添加用户常量，将不变的量转化为常量保存，可以节省 RAM 资源空间，因为常量和变量的保存位置不同，详细了解可以参考这篇文章：C语言：内存四区\n九、任务通知 FreeRTOS 的每个任务都有一个 32 位的通知值，任务控制块中的成员变量 ulNotifiedValue 就是这个通知值。任务通知是一个事件，假如某个任务通知的接收任务因为等待任务通知而阻塞的话，向这个接收任务发送任务通知以后就会解除这个任务的阻塞状态，CubeMX内没有提供相关的配置项，但在其生成的 FreeRTOS 接口里面有相关函数进行配置，函数位置如下：\n接口函数功能：\n函数 功能 osThreadFlagsSet 设置任务的通知标志 osThreadFlagsClear 清除任务通知 osThreadFlagsGet 获取任务标志 osThreadFlagsWait 等待特定的任务标志 常用的两个 API 就是设置任务通知和等待任务通知函数\n设置通知 osThreadFlagsSet\n函数原型\n1 2 uint32_t osThreadFlagsSet (osThreadId_t thread_id, uint32_t flags); 1 参数介绍：\n参数 功能 thread_id 任务控制块 flags 设置的标志 使用方式\n先定义一个事件标志\n1 2 #define event1 1\u0026lt;\u0026lt;1 //事件1 1 然后调用 API 通知对应任务事件发生\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void StartDefaultTask(void *argument) { /* USER CODE BEGIN StartDefaultTask */ osStatus_t result; /* Infinite loop */ for(;;) { result = osThreadFlagsSet(myTask02Handle,event1); if(result == osOK) { //设置成功 }else { //设置失败 } osDelay(1); } /* USER CODE END StartDefaultTask */ } 1234567891011121314151617181920 等待通知 osThreadFlagsWait\n函数原型\n1 2 uint32_t osThreadFlagsWait (uint32_t flags, uint32_t options, uint32_t timeout); 1 参数介绍：\n参数 功能 flags 设置的标志 options 设置功能 timeout 超时时间 options参数\n参数 功能 osFlagsWaitAny 等待32位通知值任意一位触发后恢复任务（默认） osFlagsWaitAll 等待指定的任务通知值全部触发后再恢复任务 osFlagsNoClear 恢复任务后不清除任务标志（默认清除） 使用方式\n调用 API 等待对应的任务通知就绪，当其他任务设置到对应的通知后，任务恢复运行\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 void StartDefaultTask(void *argument) { /* USER CODE BEGIN StartDefaultTask */ osStatus_t result; /* Infinite loop */ for(;;) { result = osThreadFlagsWait(myTask02Handle,osFlagsWaitAll,event1); if(result == osOK) { //等待成功 }else { //等待失败 } osDelay(1); } /* USER CODE END StartDefaultTask */ } 1234567891011121314151617181920 任务通知其实个任务事件标志组使用上没有多大的区别，但他们两个的实现原理不同，同时任务通知对资源的占用更少\n根据 FreeRTOS 官方的统计，使用任务通知替代二值信号量的时候任务解除阻 塞的时间要快 45%，并且需要的 RAM 也更少\n十、系统内核配置 CubeMX 生成的代码中封装了一系列内核配置函数，有些函数也经常使用到，比如获取时间戳和调度器管理的函数，这里不做过多解释，简单的介绍一下函数的功能\n函数 功能 osKernelInitialize 初始化RTOS的内核 osKernelGetInfo 获取RTOS的信息 osKernelGetState 获取当前内核的运行状态 osKernelStart 启动内核调度 osKernelLock 锁内核调度器 osKernelUnlock 解锁内核调度器 osKernelRestoreLock 恢复RTOS内核调度器锁状态 osKernelSuspend 挂起任务 osKernelResume 恢复任务 osKernelGetTickCount 用于获取系统当前运行的时钟节拍数 osKernelGetTickFreq 用于获取系统当前运行的时钟节拍的分频频率 osKernelGetSysTimerCount 获取系统时钟（SysTick）的计数值 osKernelGetSysTimerFreq 获取系统时钟（SysTick）的频率 仅供参考，可能有误\n","date":"2024-12-18T00:00:00Z","image":"http://localhost:1313/p/cubemx%E4%B8%8B%E7%9A%84freertos/background_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/cubemx%E4%B8%8B%E7%9A%84freertos/","title":"CubeMX下的freeRTOS"},{"content":"本篇课程基于B站UP主Expert电子实验室的教学视频，同时加上本人思考与总结汇总而成。\n零基础入门PCB设计保姆级教学\nExpert电子实验室\n本部分笔记为扫盲篇（基础篇）\n1. 电路设计 1.1 原理图四要素 元件符号 连接线 结点 注释 1.2 基本原件介绍 1.2.1 电阻 对于贴片电阻的读数 1）3位读数：前2位为有效数字，第3位表示10的n次幂(也可以理解为0的个数)。精度为±5%\n2）4位读数：前3位为有效数字，第4位表示10的n次幂(也可以理解为0的个数)。读法和3位的原理一样，精度为±1%\n3）阻值小于10的读数：通常在两个数之间插入一个字母R，用字母R来代替小数点\n1.2.2 电容 主要功能：储能和滤波 单位计算 1 1uF=1000nF；1nF=1000pF 分类 读数以及含义 1.2.3 电感 Inductor，\n单位换算 1 1H=1000mH；1mH=1000uH； 主要功能：滤波，扼流，谐振，储能 分类 读数以及含义 1.2.4 二极管 主要功能 实现对交流电整流、对调制信号检波、限幅和钳位以及对电源电压的稳压等多种功能 。\n分类以及简单介绍 外观（判断正负极） 对于直插式发光二极管：长脚为正极，内部小块为正极。 一般封装类型的正负极判断 1.2.5 三极管 分类：NPN（控地） 和 PNP（控电源） 工作状态 截止状态 发射结反偏，集电结反偏。即：I ce=0\n放大状态 发射结正偏，集电结反偏。\n饱和状态\n发射结正偏，集电结正偏\n常见封装 1.2.6 场效应管（尚未掌握） 基本介绍 场效应晶体管（Field Effect Transistor缩写(FET)）简称场效应管。它是利用控制输入回路的电场效应来控制输出回路电流的一种半导体器件。\n特点 具有输入电阻高、噪声小、功耗低、动态范围大、易于集成、没有二次击穿现象、安全工作区域宽等优点。\n类型 结型场效应管（junction FET—JFET) 金属 - 氧化物半导体场效应管（metal-oxide semiconductor FET，简称MOS-FET） 与三极管的对比 封装 1.2.7 芯片 / IC 具体见数据手册\n1.3 数据手册 自己找去\n1.4 电路原理图设计 网络标签 网络标签 (Net Label)：网络标号表示一个电器连接点，具有相同网络标号的器件表明是电气连接在一起。\n模块化 注释 总结： 分模块、分图页 标注重要参数 标注元件特殊/重要功能 标注注意事项 合理的网络标签 标注LOGO/版本号 ==成功的原理图设计=合理的元件选型+正确的电路设计==\n2. PCB设计 PCB基本介绍 PCB板就是印制电路板，又称印刷电路板，是电子元器件电气连接的提供者。PCB根据其基板材料的不同而不同，高频微波板、金属基板，铝基板、铁基板、铜基板、双面板及多层板PCB是英文Printed Circuit Board的缩写，中文名称为印制电路板，又称印刷电路板、印刷线路板，是重要的电子部件。\n2.1PCB 组成 2.1.1铺铜 作用 将PCB上闲置的空间作为基准面，然后用固体铜填充，这些铜区又称为灌铜。覆铜的意义在于，减小地线阻抗，提高抗干扰能力；降低压降，提高电源效率；与地线相连，还可以减小环路面积。\n方式 大面积覆铜 大面积覆铜，具备了加大电流和屏蔽双重作用，但是大面积覆铜，如果过波峰焊时，板子就可能会翘起来，甚至会起泡。因此大面积覆铜，一般也会开几个槽，缓解铜箔起泡。低频电路、有大电流的电路等常用大面积的覆铜。\n网格覆铜 从散热的角度说，它降低了铜的受热面，又起到了一定的电磁屏蔽的作用。因此，高频电路对抗干扰要求高的多用网格覆铜\n2.1.2过孔 功能 电气连接：过孔用于将不同层面的电路连接起来，使得电路板能够在不同的层次上进行有效的信号和电源传输。 器件固定或定位：过孔还可以用作固定电子部件的位置，如电阻、电容等，确保其在电路板上的正确布局。 分类 通孔：从PCB的上层钻到底层的机械钻孔。 盲孔：从 PCB 的上层或底层到内层钻孔和电镀的孔。 埋孔：指位于印刷线路板内层的连接孔，它不会延伸到线路板的表面。 2.1.3焊盘 定义： 元件通过PCB上的引线孔，用焊锡焊接固定在PCB上，印制导线把焊盘连接起来，实现元件在电路中的电气连接。引线孔及周围的铜箔称为焊盘。\n2.1.4丝印 PCB丝印是指在电子线路板（Printed Circuit Board）上印刷的信息，如文字、标志、图形等。这些丝印具有重要的功能，它们可以帮助标识电子元件的位置、数值、型号等信息，以及元件的方向和正确的安装方式。\n2.1.5阻焊 在铜层上面覆盖油墨层，油墨层覆盖住铜层上面不需要焊接的线路，防止PCB上的线路和其他的金属、焊锡或者其它的导电物体接触导致短路，起到绝缘及保护铜层作用，选择性露出焊接需要的铜PAD、IC等。\n2.2PCB结构 叠层结构 PCB材料的组成主要有PP半固态片和Core芯板两部分组成，这就构成了所看到的绿色、红色或者黑色等的板子，再加上敷铜线路层，器件，就构成了电路板。\n==叠层结构布局有讲究==，但是一般的二层板双面都可能需要走底地线和电源。 图示 2.3 PCB设计流程 2.end.1PCB设计规则总览（持续添加ing） 电路布局与元器件安放：\n电路布局是否合理？ 元器件之间的距离是否足够？ 元器件的放置方向是否一致？ 是否合理安排了元器件的布局顺序？ 是否考虑了元器件的封装形式和选择？ 是否进行了元器件的标注和排列规范？ 是否考虑了元器件的插拔次数和位置？ 是否进行了元器件的冗余设计？ 是否考虑了元器件的热管理和散热问题？ 是否进行了元器件的可靠性分析？ 信号管理：\n线宽与过孔\n1）8/8mil，过孔选择12mil（0.3mm）。 2）6/6mil，过孔选择12mil（0.3mm）。 3）4/4mil，过孔选择8mil（0.2mm）。 4）3.5/3.5mil，过孔选择8mil（0.2mm）。 5）3.5/3.5mil，过孔选择4mil（0.1mm，激光打孔）。 6）2/2mil，过孔选择4mil（0.1mm，激光打孔）。 参考过孔：内径12mil、外径20mil 参考内径20mil、外径30mil\n是否进行了信号完整性分析？\n是否进行了阻抗匹配设计？\n是否进行了信号线路的优化布局和仿真验证？\n是否考虑了电磁干扰和射频干扰的影响？\n是否进行了电磁场模拟分析？\n是否考虑了信号传输速率和衰减问题？\n是否考虑了线路的阻抗匹配和信号损耗？\n是否进行了线路的阻抗匹配设计？\n电源管理：\n电流与布线宽度\n电源线、地线的宽度最好尽可能宽，地线比电源线宽。这些关系为：地线\u0026gt;电源线\u0026gt;信号线，通常信号线的宽度为0.2-0.3mm(8-12mil)，最细的宽度为0.05-0.07mm(2-2.8mil)，电源线为1.2-2.5mm(48-100mil)。(0.025mm=1mil).\nPCB走线载流计算器-EDA365电子论坛通信数码-人工智能-计算机-半导体-手机家电消费电子硬件门户网站\n是否考虑了电源的滤波和稳压？\n是否进行了电源线和地线的分离和规范设计？\n是否考虑了过压和过流保护的设计？\n是否进行了电源供应的充足性和稳定性分析？\nPCB工艺与环境因素：\n是否考虑了PCB的工作环境和应用场景 是否进行了PCB的加工工艺和成本分析？ 是否进行了PCB布线的仿真验证？ 是否考虑了PCB的防火、加固、环境友好等设计因素？ 仅供参考，可能有误\n","date":"2024-11-29T00:00:00Z","image":"http://localhost:1313/p/pcb%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AB%8B%E5%88%9Beda%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/background_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/pcb%E8%AE%BE%E8%AE%A1%E4%B8%8E%E7%AB%8B%E5%88%9Beda%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98%E5%BD%95/","title":"PCB设计与立创EDA使用备忘录"},{"content":"规范制订说明 前言 基于华为C语言编程规范 在线wiki文档\n代码总体原则 清晰第一 代码的可阅读性高于性能，只有确定性能是瓶颈时，才应该主动优化\n优秀的代码可以自我解释（以我的水平可能做到比较难） 常写注释，并且注释写的清晰 简洁为美 写的代码越多，意味着出错的地方越多，也就意味着代码的可靠性越低。\n如果重构/修改其他风格的代码时，比较明智的做法是根据现有代码的现有风格继续编写代码，或者使用格式转换工具进行转换成公司内部风格。\n术语 原则：编程时必须坚持的指导思想。\n规则：编程时强制必须遵守的约定。\n建议：编程时必须加以考虑的约定。\n说明：对此原则/规则/建议进行必要的解释。\n示例：对此原则/规则/建议从正、反两个方面给出例子。\n延伸阅读材料：建议进一步阅读的参考材料。\n头文件 不合理的头文件布局是编译时间过长的根因，不合理的头文件实际上不合理的设计。\n如果引入了新的依赖，则一旦被依赖的头文件修改，任何直接和间接依赖其头文件的代码都会被重新编译。\n原则 原则1.1 头文件中适合放置接口的声明，不适合放置实现 头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。\n内部使用的函数（相当于类的私有方法）声明不应放在头文件中 内部使用的宏、枚举、结构定义不应放入头文件中。 变量定义不应放在头文件中，应放在.c文件中。 否则多次依赖会重复定义\n变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。即使必须使用全局变量，也只应当在.c中定义全局变量，在.h中仅声明变量为全局的。 原则1.2 头文件应当职责单一。 原则1.3 头文件应向稳定的方向包含。 说明：头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。\n规则 规则1.1 每一个.c文件应有一个同名.h文件，用于声明需要对外公开的接口。 说明：如果一个.c文件不需要对外公布任何接口，则其就不应当存在，除非它是程序的入口，如main函数所在的文件。\n规则1.2 禁止头文件循环依赖 任何一个头文件的改变都会使得循环中的所有头文件重新编译\n规则1.3 .c/.h文件禁止包含用不到的头文件。 规则1.4 头文件应当自包含。 “头文件应当自包含”是指头文件应该包含自身所需的所有内容，而不依赖于其他头文件。这样的头文件通常被称为”自包含头文件”。下面解释一下这个概念的意义：\n独立性和可移植性：自包含头文件使得头文件本身更加独立，不依赖于其他头文件。这样做有助于提高代码的可移植性，因为当你在其他项目或环境中使用这个头文件时，不需要担心它依赖的其他头文件是否可用。 简化依赖关系：自包含头文件可以简化代码的依赖关系。如果一个头文件依赖于另一个头文件，而后者又依赖于其他头文件，这会形成复杂的依赖链。通过自包含头文件，可以减少这种依赖链，提高代码的可维护性。 避免重复包含：自包含头文件通常会包含预处理器指令来避免重复包含。这样可以确保在包含相同头文件多次时不会导致重复定义的问题。 提高效率：自包含头文件可以减少预处理器的工作量，因为它们不需要解析其他头文件的内容。这有助于提高编译效率。 规则1.5 总是编写内部#include保护符（#define 保护）。 所有头文件都应当使用#define 防止头文件被多重包含，命名格式为FILENAME_H，为了保证唯一性，更好的命名是PROJECTNAME_PATH_FILENAME_H。\n规则1.6 禁止在头文件中定义变量。 说明：在头文件中定义变量，将会由于头文件被其他.c文件包含而导致变量重复定义。\n规则1.7 只能通过包含头文件的方式使用其他.c提供的接口，禁止在.c中通过extern的方式使用外部函数接口、变量。 规则1.8 禁止在extern “C”中包含头文件。 extern \u0026quot;C\u0026quot; 是用于在 C++ 中声明 C 函数时的一种语法。它告诉编译器这些函数按照 C 语言的约定进行链接。\n在 C++ 中，函数名的重载、名称修饰（name mangling）等特性会导致函数名在编译后被修改，这样的函数名在链接时可能无法与 C 代码中的函数名匹配。为了解决这个问题，C++ 提供了 extern \u0026quot;C\u0026quot;，它告诉编译器不要对函数名进行 C++ 风格的名称修饰，而是按照 C 语言的规则进行链接。\n函数 函数设计的精髓：编写整洁函数，同时把代码有效组织起来。\n整洁函数要求：代码简单直接、不隐藏设计者的意图、用干净利落的抽象和直截了当的控制语句将函数有机组织起来。\n代码的有效组织包括：逻辑层组织和物理层组织两个方面。逻辑层，主要是把不同功能的函数通过某种联系组织起来，主要关注模块间的接口，也就是模块的架构。物理层，无论使用什么样的目录或者名字空间等，需要把函数用一种标准的方法组织起来。例如：设计良好的目录结构、函数名字、文件组织等，这样可以方便查找。\n原则 原则2.1 一个函数仅完成一件功能。 说明：一个函数实现多个功能给开发、使用、维护都带来很大的困难。\n将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。\n原则2.2 重复代码应该尽可能提炼成函数 说明：重复代码提炼成函数可以带来维护成本的降低。\n可以使用代码重复度检查工具\n规则 规则2.1 避免函数过长，新增函数不超过50行（非空非注释行）。 规则2.2 避免函数的代码块嵌套过深，新增函数的代码块嵌套不超过4层。 减少代码嵌套层数的方法 使用函数抽象：将嵌套的代码块提取成独立的函数，以便于重用和理解。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 plaintext \u0026gt;python复制代码def main_function(): if condition: process_items(items) else: handle_condition_not_met() \u0026gt;def process_items(items): for item in items: if item_valid(item): process_item(item) else: handle_invalid_item(item) \u0026gt;def item_valid(item): return item.condition \u0026gt;def process_item(item): # 处理item pass \u0026gt;def handle_invalid_item(item): # 处理无效item pass \u0026gt;def handle_condition_not_met(): # 处理条件未满足情况 pass 使用早期返回：在函数内部，尽早返回结果，而不是在多层嵌套中处理。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 python \u0026gt;def main_function(): if not condition: handle_condition_not_met() return for item in items: if not item_valid(item): handle_invalid_item(item) continue process_item(item) \u0026gt;def item_valid(item): return item.condition \u0026gt;def process_item(item): # 处理item pass \u0026gt;def handle_invalid_item(item): # 处理无效item pass \u0026gt;def handle_condition_not_met(): # 处理条件未满足情况 pass 使用异常处理：适用于处理特殊情况或错误的情况。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 python \u0026gt;def main_function(): try: if condition: for item in items: process_item(item) else: raise ConditionNotMetError except ConditionNotMetError: handle_condition_not_met() \u0026gt;def process_item(item): if not item_valid(item): raise InvalidItemError # 处理item \u0026gt;def item_valid(item): return item.condition \u0026gt;def handle_condition_not_met(): # 处理条件未满足情况 pass \u0026gt;class ConditionNotMetError(Exception): pass \u0026gt;class InvalidItemError(Exception): pass 这些方法可以帮助将嵌套降低到合理的水平，使代码更易读、更易维护。\n规则2.3 可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护。 可能用不到。\n说明：可重入函数是指可能被多个任务并发调用的函数。在多任务操作系统中，函数具有可重入性是多个任务可以共用此函数的必要条件。共享变量指的全局变量和static变量。\n规则2.4 对参数的合法性检查，由调用者负责还是由接口函数负责，应在项目组/模块内应统一规定。缺省由调用者负责。 规则2.5 对函数的错误返回码要全面处理。 规则2.6 设计高扇入，合理扇出（小于7）的函数。 说明：扇出是指一个函数直接调用（控制）其它函数的数目，而扇入是指有多少上级函数调用它。\n建议2.1 函数不变参数使用const。\n建议2.2 函数应避免使用全局变量、静态局部变量和I/O操作，不可避免的地方应集中使用。\n建议2.4 函数的参数个数不超过5个。\n建议2.5 除打印类函数外，不要使用可变长参函数。\n标识符命名与定义 通用命名规则\nunix like风格\n单词用小写字母，每个单词直接用下划线‘_’分割，例如text_mutex，kernel_text_address。\nWindows风格\n大小写字母混用，单词连在一起，每个单词首字母大写\n匈牙利命名法\n匈牙利命名主要包括三个部分：基本类型、一个或更多的前缀、一个限定词。\n原则 原则3.1标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解。 原则3.2 除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音。 示例：一些常见可以缩写的例子：\nargument 可缩写为 arg buffer 可缩写为 buff clock 可缩写为 clk command 可缩写为 cmd compare 可缩写为 cmp configuration 可缩写为 cfg device 可缩写为 dev error 可缩写为 err hexadecimal 可缩写为 hex increment 可缩写为 inc initialize 可缩写为 init maximum 可缩写为 max message 可缩写为 msg minimum 可缩写为 min parameter 可缩写为 para previous 可缩写为 prev register 可缩写为 reg semaphore 可缩写为 sem statistic 可缩写为 stat synchronize 可缩写为 sync temp 可缩写为 tmp 规则 规则3.1 产品/项目组内部应保持统一的命名风格。 示例：\nadd/remove begin/end create/destroy insert/delete first/last get/release increment/decrement put/get add/delete lock/unlock open/close min/max old/new start/stop next/previous source/target show/hide send/receive source/destination copy/paste up/down\n建议 建议3.2 尽量避免名字中出现数字编号，除非逻辑上的确需要编号。 建议3.3 标识符前不应添加模块、项目、产品、部门的名称作为前缀。 建议3.4 平台/驱动等适配代码的标识符命名风格保持和平台/驱动一致。 文件命名规则 建议 建议3.6 文件命名统一采用小写字符。 变量命名规则 规则 规则3.2 全局变量应增加“g_”前缀。 规则3.3 静态变量应增加“s_”前缀。 规则3.4 禁止使用单字节命名变量，但允许定义i、j、k作为局部循环变量。 建议 建议3.7 不建议使用匈牙利命名法。 建议3.8 使用名词或者形容词＋名词方式命名变量。 函数命名规则 建议 建议3.9 函数命名应以函数要执行的动作命名，一般采用动词或者动词＋名词的结构。 宏的命名规则 规则 规则3.5对于数值或者字符串等等常量的定义，建议采用全大写字母，单词之间加下划线‘_’的方式命名（枚举同样建议使用此方式定义）。 规则3.6 除了头文件或编译开关等特殊标识定义，宏定义不能使用下划线‘_’开头和结尾。 变量 原则 原则4.1 一个变量只有一个功能，不能把一个变量用作多种用途。 我怎么感觉在某些情况下无妨啊，开多了变量会占用性能吧？\n也就是说：重要性：代码的可读性、可维护性和减少错误\u0026gt;性能消耗\n下列答案基于chatGPT\n遵循“一个变量只有一个功能”的原则确实会增加一些变量的数量，但这通常不会显著增加系统开销，特别是在现代编程环境和硬件条件下。这是因为：\n内存开销相对较小： 现代计算机的内存容量通常非常大，增加几个变量所占用的内存是非常小的。这种内存开销在绝大多数应用场景下可以忽略不计。 编译器优化： 现代编译器和解释器非常智能，它们可以优化代码，将不必要的变量删除或者合并，从而减少内存开销。例如，在优化编译过程中，编译器会尝试最小化变量的存储空间，并进行变量复用等优化操作。 代码可读性和维护性优先： 代码的可读性和可维护性在实际开发中比微小的性能优化更重要。可读性好的代码更容易被团队中的其他开发人员理解和维护，从而降低了开发和维护的成本。 开发效率和错误减少： 使用单一功能变量可以减少代码中的错误，使开发过程更加顺利。这种减少错误和提升开发效率的好处往往远远超过因为增加变量数量而带来的微小性能损失。 示例分析：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 python # 增加系统开销的担忧 total_items = 10 price = 5.99 total_cost = total_items * price # 不好的做法：减少变量数量 x = 10 x = 5.99 x = x * x # 这样做容易引入错误，也降低了代码的可读性 # 正确做法：使用多个变量，增加代码可读性 total_items = 10 price_per_item = 5.99 total_cost = total_items * price_per_item 在这个示例中，尽管引入了多个变量，但它们使代码更容易理解和维护。变量名清晰地表达了它们的用途，减少了开发和调试中的潜在错误。\n总结：\n遵循“一个变量只有一个功能”的原则，不仅不会显著增加系统开销，反而可以通过提升代码质量和开发效率，降低长远的开发和维护成本。因此，在大多数情况下，这种做法是非常值得的。实际开发中，尤其是在团队协作和大型项目中，应优先考虑代码的可读性和可维护性。\n原则4.2 结构功能单一；不要设计面面俱到的数据结构。 原则4.3 不用或者少用全局变量。 规则 规则4.1 防止局部变量与全局变量同名。 规则4.2 通讯过程中使用的结构，必须注意字节序。 字节序的解释（基于chatGPT）\n字节序（Byte Order）是指在计算机内存中存储多字节数据时，字节的排列顺序。不同计算机系统可能采用不同的字节序，主要有两种类型：大端序（Big-Endian）和小端序（Little-Endian）。\n大端序（Big-Endian） 定义：高位字节存储在低地址，低位字节存储在高地址。\n示例\n：假设有一个4字节（32位）的数值\n1 2 plaintext 0x12345678 。在大端序系统中，它的存储顺序如下：\n1 2 3 plaintext makefile复制代码地址: 0x00 0x01 0x02 0x03 值: 0x12 0x34 0x56 0x78 小端序（Little-Endian） 定义：低位字节存储在低地址，高位字节存储在高地址。\n示例\n：同样的数值\n1 2 plaintext 0x12345678 在小端序系统中的存储顺序如下：\n1 2 3 plaintext makefile复制代码地址: 0x00 0x01 0x02 0x03 值: 0x78 0x56 0x34 0x12 为什么字节序很重要 在多字节数据传输或跨平台交互时，字节序的不同可能导致数据解释错误。例如，一个大端序系统发送数据到一个小端序系统，如果不做任何处理，小端序系统可能会错误地解读数据内容。\n字节序的处理 网络字节序：网络协议（如TCP/IP）通常规定使用大端序，这被称为网络字节序（Network Byte Order）。 字节序转换函数：大多数编程语言提供了用于字节序转换的函数。例如，在C语言中，htons（Host TO Network Short）、htonl（Host TO Network Long）、ntohs（Network TO Host Short）、ntohl（Network TO Host Long）等函数用于在主机字节序和网络字节序之间进行转换。 示例代码 C语言中的字节序处理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 plaintext c复制代码#include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;arpa/inet.h\u0026gt; void print_bytes(uint32_t value) { uint8_t *bytes = (uint8_t *)\u0026amp;value; for (int i = 0; i \u0026lt; 4; i++) { printf(\u0026#34;%02x \u0026#34;, bytes[i]); } printf(\u0026#34;\\n\u0026#34;); } int main() { uint32_t host_value = 0x12345678; // 主机字节序 uint32_t network_value = htonl(host_value); // 转换为网络字节序（大端序） printf(\u0026#34;Host byte order: \u0026#34;); print_bytes(host_value); // 打印主机字节序 printf(\u0026#34;Network byte order: \u0026#34;); print_bytes(network_value); // 打印网络字节序 uint32_t converted_back = ntohl(network_value); // 转换回主机字节序 printf(\u0026#34;Converted back to host byte order: \u0026#34;); print_bytes(converted_back); // 打印转换回的主机字节序 return 0; } 输出\n1 2 3 4 plaintext vbnet复制代码Host byte order: 78 56 34 12 Network byte order: 12 34 56 78 Converted back to host byte order: 78 56 34 12 总结 字节序在计算机内存中存储多字节数据时非常重要。理解和处理字节序问题，特别是在跨平台或网络通信中，确保数据正确传输和解释是至关重要的。通过明确协议中的字节序和使用合适的字节序转换函数，可以避免数据传输中的错误。\n规则4.3 严禁使用未经初始化的变量作为右值。 建议 建议4.1 构造仅有一个模块或函数可以修改、创建，而其余有关模块或函数只访问的全局变量，防止多个不同模块或函数都可以修改、创建同一全局变量的现象。 建议4.2 使用面向接口编程思想，通过API访问数据：如果本模块的数据需要对外部模块开放，应提供接口函数来设置、获取，同时注意全局数据的访问互斥。 建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。建议4.3 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。 建议4.4 明确全局变量的初始化顺序，避免跨模块的初始化依赖。 建议4.5 尽量减少没有必要的数据类型默认转换与强制转换。 宏、常量 规则 规则5.1 用宏定义表达式时，要使用完备的括号。 规则5.2 将宏所定义的多条表达式放在大括号中。 规则5.3 使用宏时，不允许参数发生变化。 规则5.4 不允许直接使用魔鬼数字。 说明：使用魔鬼数字的弊端：代码难以理解；如果一个有含义的数字多处使用，一旦需要修改这个数值，代价惨重。\n建议 建议5.1 除非必要，应尽可能使用函数代替宏。 建议5.2 常量建议使用const定义代替宏。 建议5.3 宏定义中尽量不使用return、goto、continue、break等改变程序流程的语句。 质量保证 原则 原则6.1 代码质量保证优先原则（性能并没有放在那么靠前的位置，有些意外！） 正确性，指程序要实现设计要求的功能。 简洁性，指程序易于理解并且易于实现。 可维护性，指程序被修改的能力，包括纠错、改进、新需求或功能规格变化的适应能力。 可靠性，指程序在给定时间间隔和环境条件下，按设计要求成功运行程序的概率。 代码可测试性，指软件发现故障并隔离、定位故障的能力，以及在一定的时间和成本前提下，进行测试设计、测试执行的能力。 代码性能高效，指是尽可能少地占用系统资源，包括内存和执行时间。 可移植性，指为了在原来设计的特定环境之外运行，对系统进行修改的能力。 个人表达方式/个人方便性，指个人编程习惯。 原则6.2 要时刻注意易混淆的操作符。 易混淆的操作符，如：赋值操作符“=” 逻辑操作符“==” 关系操作符“\u0026lt;” 位操作符\u0026quot;\u0026laquo;\u0026quot; 关系操作符“\u0026gt;” 位操作符“\u0026raquo;” 逻辑操作符“||” 位操作符\u0026quot;|\u0026quot; 逻辑操作符“\u0026amp;\u0026amp;” 位操作符\u0026quot;\u0026amp;\u0026quot; 逻辑操作符\u0026quot;!\u0026quot; 位操作符“~”。 易用错的操作符，如：除操作符\u0026quot;/\u0026quot;、求余操作符\u0026quot;%\u0026quot;、自加、自减操作符“++”、“\u0026ndash;”。\n原则6.3 必须了解编译系统的内存分配方式，特别是编译系统对不同类型的变量的内存分配规则，如局部变量在何处分配、静态变量在何处分配等。 原则6.4 不仅关注接口，同样要关注实现。 规则 规则6.1 禁止内存操作越界。坚持下列措施可以避免内存越界： 数组的大小要考虑最大情况，避免数组分配空间不够。 避免使用危险函数sprintf/vsprintf/strcpy/strcat/gets操作字符串，使用相对安全的函数snprintf/strncpy/strncat/fgets代替。 使用memcpy/memset时一定要确保长度不要越界 字符串考虑最后的\u0026rsquo;\\0\u0026rsquo;，确保所有字符串是以\u0026rsquo;\\0\u0026rsquo;结束 指针加减操作时，考虑指针类型长度 数组下标进行检查 使用时sizeof或者strlen计算结构/字符串长度，避免手工计算 规则6.2 禁止内存泄漏。坚持下列措施可以避免内存泄漏： 异常出口处检查内存、定时器/文件句柄/Socket/队列/信号量/GUI等资源是否全部释放 删除结构指针时，必须从底层向上层顺序删除 使用指针数组时，确保在释放数组时，数组中的每个元素指针是否已经提前被释放了 避免重复分配内存 小心使用有return、break语句的宏，确保前面资源已经释放 检查队列中每个成员是否释放 规则6.3 禁止引用已经释放的内存空间。坚持下列措施可以避免引用已经释放的内存空间： 内存释放后，把指针置为NULL；使用内存指针前进行非空判断。 耦合度较强的模块互相调用时，一定要仔细考虑其调用关系，防止已经删除的对象被再次使用。 避免操作已发送消息的内存。 自动存储对象的地址不应赋值给其他的在第一个对象已经停止存在后仍然保持的对象（具有更大作用域的对象或者静态对象或者从一个函数返回的对象） 规则6.4 编程时，要防止差1错误。 此类错误一般是由于把“\u0026lt;=”误写成“\u0026lt;”或“\u0026gt;=”误写成“\u0026gt;”等造成的，由此引起的后果，很多情况下是很严重的，所以编程时，一定要在这些地方小心。\n规则6.5 所有的if \u0026hellip; else if结构应该由else子句结束；switch语句必须有default分支。 建议 建议6.1 函数中分配的内存，在函数退出之前要释放。 有很多函数申请内存，保存在数据结构中，要在申请处加上注释，说明在何处释放。\n建议6.2 if语句尽量加上else分支，对没有else分支的语句要小心对待。 建议6.3 不要滥用goto语句。 goto语句会破坏程序的结构性，所以除非确实需要，最好不使用goto语句。但好处是可以利用goto语句方面退出多重循环。\n建议6.4 时刻注意表达式是否会上溢、下溢。 此种问题一般是出现在使用无符号变量时可能会出现边界i溢出情况。\n程序效率 原则 原则7.1 在保证软件系统的正确性、简洁、可维护性、可靠性及可测性的前提下，提高代码效率。 让一个正确的程序更快速，比让一个足够快的程序正确，要容易得太多。大多数时候，不要把注意力集中在如何使代码更快上，应首先关注让代码尽可能地清晰易读和更可靠。\n原则7.2 通过对数据结构、程序算法的优化来提高效率。 建议 建议7.1 将不变条件的计算移到循环体外。 建议7.2 对于多维大数组，避免来回跳跃式访问数组成员。 建议7.3 创建资源库，以减少分配对象的开销。 例如，使用线程池机制，避免线程频繁创建、销毁的系统调用；使用内存池，对于频繁申请、释放的小块内存，一次性申请一个大块的内存，当系统申请内存时，从内存池获取小块内存，使用完毕再释放到内存池中，避免内存申请释放的频繁系统调用\n建议7.4 将多次被调用的 “小函数”改为inline函数或者宏实现。 inline函数的优点：其一编译时不用展开，代码SIZE小。其二可以加断点，易于定位问题，例如对于引用计数加减的时候。其三函数编译时，编译器会做语法检查。\n8 注释 原则 原则8.1 优秀的代码可以自我解释，不通过注释即可轻易读懂。 **优秀的代码不写注释也可轻易读懂，注释无法把糟糕的代码变好，**需要很多注释来解释的代码往往存在坏味道，需要重构。\n原则8.2 注释的内容要清楚、明了，含义准确，防止注释二义性。 有歧义的注释反而会导致维护者更难看懂代码，正如带两块表反而不知道准确时间。\n原则8.3 在代码的功能、意图层次上进行注释，即注释解释代码难以直接表达的意图，而不是重复描述代码。 注释不是为了名词解释（what），不是为了重复描述代码，而是说明用途（why）。\n规则 规则8.1 修改代码时，维护代码周边的所有注释，以保证注释与代码的一致性。不再有用的注释要删除。 这个要求本身不难，但是却是在开发过程中很难坚持做到的一点，也是现在我们公司代码里面存在较为广泛的现象。\n规则8.2 文件头部应进行注释，注释必须列出：版权说明、版本号、生成日期、作者姓名、工号、内容、功能说明、与其它文件的关系、修改日志等，头文件的注释中还应有函数功能简要说明。 通常头文件要对功能和用法作简单说明，源文件包含了更多的实现细节或算法讨论。\n规则8.3 函数声明处注释描述函数功能、性能及用法，包括输入和输出参数、函数返回值、可重入的要求等；定义处详细描述函数功能和实现要点，如实现的简要步骤、实现的理由、设计约束等。 重要的、复杂的函数，提供外部使用的接口函数应编写详细的注释。\n规则8.4 全局变量要有较详细的注释，包括对其功能、取值范围以及存取时注意事项等的说明。 规则8.5 注释应放在其代码上方相邻位置或右方，不可放在下面。如放于上方则需与其上面的代码用空行隔开，且与下方代码缩进相同。 这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。\n规则8.6 对于switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释。 规则8.7 避免在注释中使用缩写，除非是业界通用或子系统内标准化的缩写。 规则8.8 同一产品或项目组统一注释风格。 建议 建议8.1 避免在一行代码或表达式的中间插入注释。 建议8.2 注释应考虑程序易读及外观排版的因素，使用的语言若是中、英兼有的，建议多使用中文，除非能用非常流利准确的英文表达。对于有外籍员工的，由产品确定注释语言。 注释语言不统一，影响程序易读性和外观排版，出于对维护人员的考虑，建议使用中文。\n建议8.3 文件头、函数头、全局常量变量、类型定义的注释格式采用工具可识别的格式。 以doxygen格式为例，文件头，函数和全部变量的注释的示例如下： 文件头注释：\n1 /** * @file （本文件的文件名eg：mib.h）* @brief （本文件实现的功能的简述）* @version 1.1 （版本声明）* @author （作者，eg：张三）* @date （文件创建日期，eg：2010年12月15日）*/ 函数头注释：\n1 /***@ Description:向接收方发送SET请求* @param req - 指向整个SNMP SET 请求报文.* @param ind - 需要处理的subrequest 索引.* @return 成功：SNMP_ERROR_SUCCESS，失败：SNMP_ERROR_COMITFAIL*/Int commit_set_request(Request *req, int ind); 全局变量注释：\n1 /** 模拟的Agent MIB */agentpp_simulation_mib * g_agtSimMib; 函数头注释建议写到声明处。并非所有函数都必须写注释，建议针对这样的函数写注释：重要的、复杂的函数，提供外部使用的接口函数。\n9 排版与格式 规则 规则9.1 程序块采用缩进风格编写，每级缩进为4个空格。 宏定义、编译开关、条件预处理语句可以顶格（或使用自定义的排版方案，但产品/模块内必须保持一致）。\n规则9.2 相对独立的程序块之间、变量说明之后必须加空行。 规则9.3 一条语句不能过长，如不能拆分需要分行写。一行到底多少字符换行比较合适，产品可以自行确定。换行时有如下建议： 换行时要增加一级缩进，使代码可读性更好； 低优先级操作符处划分新行；换行时操作符应该也放下来，放在新行首； 换行时建议一个完整的语句放在一行，不要根据字符数断行 规则9.4 多个短语句（包括赋值语句）不允许写在同一行内，即一行只写一条语句。 规则9.5 if、for、do、while、case、switch、default等语句独占一行。 规则9.6 在两个以上的关键字、变量、常量进行对等操作时，它们之间的操作符之前、之后或者前后要加空格；进行非对等操作时，如果是关系密切的立即操作符（如－\u0026gt;），后不应加空格。 1.在已经非常清晰的语句中没有必要再留空格，如括号内侧(即左括号后面和右括号前面)不需要加空格，多重括号间不必加空格，因为在C语言中括号已经是最清晰的标志了。 2.逗号、分号只在后面加空格 3.比较操作符, 赋值操作符\u0026quot;=\u0026quot;、 \u0026ldquo;+=\u0026quot;，算术操作符\u0026rdquo;+\u0026quot;、\u0026quot;%\u0026quot;，逻辑操作符\u0026quot;\u0026amp;\u0026amp;\u0026quot;、\u0026quot;\u0026amp;\u0026quot;，位域操作符\u0026quot;\u0026laquo;\u0026quot;、\u0026quot;^\u0026ldquo;等双目操作符的前后加空格。 4.\u0026rdquo;!\u0026quot;、\u0026quot;~\u0026quot;、\u0026quot;++\u0026quot;、\u0026quot;\u0026ndash;\u0026quot;、\u0026quot;\u0026amp;\u0026quot;（地址操作符）等单目操作符前后不加空格。 5.\u0026quot;-\u0026gt;\u0026quot;、\u0026quot;.\u0026ldquo;前后不加空格。\nif、for、while、switch等与后面的括号间应加空格，使if等关键字更为突出、明显。 建议 建议9.1 注释符（包括‘/’‘//’‘/’）与注释内容之间要用一个空格进行分隔。 建议9.2 源程序中关系较为紧密的代码应尽可能相邻。 表达式 本小节内容虽少，但却是平时写代码过程中容易忽略并且会产生较大影响的问题，需要额外注意。\n规则 规则10.1 表达式的值在标准所允许的任何运算次序下都应该是相同的。 说明：除了逗号(,)，逻辑与(\u0026amp;\u0026amp;)，逻辑或(||)之外，C标准没有规定同级操作符是从左还是从右开始计算，需要保证一个表达式有且只有一个计算结果，较好的方法就是将复合表达式分开写成若干个简单表达式，明确表达式的运算次序，就可以有效消除非预期副作用。 1.自增或自减操作符\n1 x = b[i] + i++;b[i] 的运算是先于还是后于 i++ 的运算，表达式会产生不同的结果，把自增运算做为单独的语句，可以避免这个问题。 2.函数参数，函数参数通常从右到左压栈，但函数参数的计算次序不一定与压栈次序相同。 示例：\n1 x = func( i++, i); 应该修改代码明确先计算第一个参数：\n1 i++;x = func(i, i); 3.函数指针 示例：\n1 p-\u0026gt;task_start_fn(p++); 求函数地址p与计算p++无关，结果是任意值。必须单独计算p++：\n1 p-\u0026gt;task_start_fn(p);p++; 4.函数调用 示例：\n1 int g_var = 0;int fun1(){ g_var += 10; return g_var;}int fun2(){ g_var += 100; return g_var;}int x = fun1() + fun2(); 编译器可能先计算fun1()，也可能先计算fun2()，由于x的结果依赖于函数fun1()/fun2()的计算次序（fun1()/fun2()被调用时修改和使用了同一个全局变量），则上面的代码存在问题。 5.嵌套赋值语句 6.volatile访问 限定符volatile表示可能被其它途径更改的变量，例如硬件自动更新的寄存器。编译器不会优化对volatile变量的读取。\n建议 建议10.1 函数调用不要作为另一个函数的参数使用，否则对于代码的调试、阅读都不利。 如下代码不合理，仅用于说明当函数作为参数时，由于参数压栈次数不是代码可以控制的，可能造成未知的输出：\n1 int g_var;int fun1(){ g_var += 10; return g_var;}int fun2(){ g_var += 100; return g_var;}int main(int argc, char *argv[], char *envp[]){ g_var = 1; printf(\u0026#34;func1: %d, func2: %d\\n\u0026#34;, fun1(), fun2()); g_var = 1; printf(\u0026#34;func2: %d, func1: %d\\n\u0026#34;, fun2(), fun1());} 建议10.2 赋值语句不要写在if等语句中，或者作为函数的参数使用。 1.因为if语句中，会根据条件依次判断，如果前一个条件已经可以判定整个条件，则后续条件语句不会再运行，所以可能导致期望的部分赋值没有得到运行。 2.作用函数参数来使用，参数的压栈顺序不同可能导致结果未知。\n1 int g_var;int main(int argc, char *argv[], char *envp[]){ g_var = 1; printf(\u0026#34;set 1st: %d, add 2nd: %d\\n\u0026#34;, g_var = 10, g_var++); g_var = 1; printf(\u0026#34;add 1st: %d, set 2nd: %d\\n\u0026#34;, g_var++, g_var = 10);} 建议10.3 用括号明确表达式的操作顺序，避免过分依赖默认优先级。 1.一元操作符，不需要使用括号 2.二元以上操作符，如果涉及多种操作符，则应该使用括号 3.即使所有操作符都是相同的，如果涉及类型转换或者量级提升，也应该使用括号控制计算的次序\n1 /* 除了逗号(,)，逻辑与(\u0026amp;\u0026amp;)，逻辑或(||)之外，C标准没有规定同级操作符是从左还是从右开始计算，以上表达式存在种计算次序：f4 = (f1 + f2) + f3 或f4 = f1 + (f2 + f3)，浮点数计算过程中可能四舍五入，量级提升，计算次序的不同会导致f4的结果不同，以上表达式在不同编译器上的计算结果可能不一样，建议增加括号明确计算顺序*/f4 = f1 + f2 + f3; 建议10.4 赋值操作符不能使用在产生布尔值的表达式上。 11 代码编辑、编译 规则 规则11.1 使用编译器的最高告警级别，理解所有的告警，通过修改代码而不是降低告警级别来消除所有告警。 规则11.2 在产品软件（项目组）中，要统一编译开关、静态检查选项以及相应告警清除策略。 某些语句经编译/静态检查产生告警，但如果你认为它是正确的，那么应通过某种手段去掉告警信息。\n规则11.3 本地构建工具（如PC-Lint）的配置应该和持续集成的一致。 规则11.4 使用版本控制（配置管理）系统，及时签入通过本地构建的代码，确保签入的代码不会影响构建成功。 及时签入代码降低集成难度。\n建议 建议11.1 要小心地使用编辑器提供的块拷贝功能编程。 12 可测性 原则 原则12.1 模块划分清晰，接口明确，耦合性小，有明确输入和输出，否则单元测试实施困难。 单元测试实施依赖于：\n模块间的接口定义清楚、完整、稳定； 模块功能的有明确的验收条件（包括：预置条件、输入和预期结果）； 模块内部的关键状态和关键数据可以查询，可以修改； 模块原子功能的入口唯一； 模块原子功能的出口唯一； 依赖集中处理：和模块相关的全局变量尽量的少，或者采用某种封装形式。 规则 规则12.1 在同一项目组或产品组内，要有一套统一的为集成测试与系统联调准备的调测开关及相应打印函数，并且要有详细的说明。 本规则是针对项目组或产品组的。**代码至始至终只有一份代码，不存在开发版本和测试版本的说法。测试与最终发行的版本是通过编译开关的不同来实现的。**并且编译开关要规范统一。统一使用编译开关来实现测试版本与发行版本的区别，一般不允许再定义其它新的编译开关。\n规则12.2 在同一项目组或产品组内，调测打印的日志要有统一的规定。 统一的调测日志记录便于集成测试，具体包括：\n统一的日志分类以及日志级别； 通过命令行、网管等方式可以配置和改变日志输出的内容和格式； 在关键分支要记录日志，日志建议不要记录在原子函数中，否则难以定位； 调试日志记录的内容需要包括文件名/模块名、代码行号、函数名、被调用函数名、错误码、错误发生的环境等。 规则12.3 使用断言记录内部假设。 规则12.4 不能用断言来检查运行时错误。 断言的使用是有条件的。断言只能用于程序内部逻辑的条件判断，而不能用于对外部输入数据的判断,因为在网上实际运行时，是完全有可能出现外部输入非法数据的情况。\n13 安全性 原则 原则13.1 对用户输入进行检查。 以下场景需要对用户输入进行检验，以确保安全：\n用户输入作为循环条件 用户输入作为数组下标 用户输入作为内存分配的尺寸参数 用户输入作为格式化字符串 用户输入作为业务数据（如作为命令执行参数、拼装sql语句、以特定格式持久化） 这些情况下如果不对用户数据做合法性验证，很可能导致DOS、内存越界、格式化字符串漏洞、命令注入、SQL注入、缓冲区溢出、数据破坏等问题。 可采取以下措施对用户输入检查： * 用户输入作为数值的，做数值范围检查 * 用户输入是字符串的，检查字符串长度 * 用户输入作为格式化字符串的，检查关键字“%” * 用户输入作为业务数据，对关键字进行检查、转义\n规则 规则13.1 确保所有字符串是以NULL结束。 C语言中’\\0’作为字符串的结束符，即NULL结束符。标准字符串处理函数（如strcpy()、strlen()）依赖NULL结束符来确定字符串的长度。没有正确使用NULL结束字符串会导致缓冲区溢出和其它未定义的行为。 为了避免缓冲区溢出，常常会用相对安全的限制字符数量的字符串操作函数代替一些危险函数。如：\n用strncpy()代替strcpy() 用strncat()代替strcat() 用snprintf()代替sprintf() 用fgets()代替gets() 错误示例：\n1 char a[16];strncpy(a, \u0026#34;0123456789abcdef\u0026#34;, sizeof(a)); 正确示例：\n1 char a[16];strncpy(a, \u0026#34;0123456789abcdef\u0026#34;, sizeof(a) - 1 );a[sizeof(a) - 1] = \u0026#39;\\0\u0026#39;; 规则13.2 不要将边界不明确的字符串写到固定长度的数组中。 边界不明确的字符串（如来自gets()、getenv()、scanf()的字符串），长度可能大于目标数组长度，直接拷贝到固定长度的数组中容易导致缓冲区溢出。 错误示例：\n1 char buff[256];char *editor = getenv(\u0026#34;EDITOR\u0026#34;);if (editor != NULL){ strcpy(buff, editor);} 正确示例，使用malloc分配指定长度的内存：\n1 char *buff;char *editor = getenv(\u0026#34;EDITOR\u0026#34;);if (editor != NULL){ buff = malloc(strlen(editor) + 1); if (buff != NULL) { strcpy(buff, editor); }} 规则13.3 避免整数溢出。 当一个整数被增加超过其最大值时会发生整数上溢，被减小小于其最小值时会发生整数下溢。带符号和无符号的数都有可能发生溢出。\n规则13.4 避免符号错误。 带符号整型转换到无符号整型，最高位（high-order bit）会丧失其作为符号位的功能。如果该带符号整数的值非负，那么转换后值不变；如果该带符号整数的值为负，那么转换后的结果通常是一个非常大的正数。 错误示例，符号错误绕过长度检查：\n1 #define BUF_SIZE 10int main(int argc,char* argv[]){ int length; char buf[BUF_SIZE]; if (argc != 3) { return -1; } length = atoi(argv[1]); //如果atoi返回的长度为负数 if (length \u0026lt; BUF_SIZE) // len为负数，长度检查无效 { memcpy(buf, argv[2], length); /* 带符号的len被转换为size_t类型的无符号整数，负值被解释为一个极大的正整数。memcpy()调用时引发buf缓冲区溢出 */ printf(\u0026#34;Data copied\\n\u0026#34;); } else { printf(\u0026#34;Too many data\\n\u0026#34;); }} 正确示例，将len声明为无符号整型：\n1 #define BUF_SIZE 10int main(int argc, char* argv[]){ unsigned int length; char buf[BUF_SIZE]; if (argc != 3) { return -1; } length = atoi(argv[1]); if (length \u0026lt; BUF_SIZE) { memcpy(buf, argv[2], length); printf(\u0026#34;Data copied\\n\u0026#34;); } else { printf(\u0026#34;Too much data\\n\u0026#34;); } return 0;} 规则13.5 避免截断错误。 将一个较大整型转换为较小整型，并且该数的原值超出较小类型的表示范围，就会发生截断错误，原值的低位被保留而高位被丢弃。截断错误会引起数据丢失。 错误示例，符号错误绕过长度检查：\n1 int main(int argc, char* argv[]){ unsigned short total = strlen(argv[1]) + strlen(argv[2]) + 1; char* buffer = (char*)malloc(total); strcpy(buffer, argv[1]); strcat(buffer, argv[2]); free(buffer); return 0;} 示例代码中total被定义为unsigned short，相对于strlen()的返回值类型size_t（通常为unsigned long）太小。如果攻击者提供的两个入参长度分别为65500和36，unsigned long的65500+36+1会被取模截断，total的最终值是（65500+36+1）%65536 = 1。malloc()只为buff分配了1字节空间，为strcpy()和strcat()的调用创造了缓冲区溢出的条件。 正确示例，将涉及到计算的变量声明为统一的类型，并检查计算结果：\n1 int main(int argc, char* argv[]){ size_t total = strlen(argv[1]) + strlen(argv[2]) + 1; if ((total \u0026lt;= strlen(argv[1])) || (total \u0026lt;= strlen(argv[2]))) { /* handle error */ return -1; } char* buffer = (char*)malloc(total); strcpy(buffer, argv[1]); strcat(buffer, argv[2]); free(buffer); return 0;} 规则13.6 确保格式字符和参数匹配。 使用格式化字符串应该小心，确保格式字符和参数之间的匹配，保留数量和数据类型。格式字符和参数之间的不匹配会导致未定义的行为。大多数情况下，不正确的格式化字符串会导致程序异常终止。大部分格式化字符串出问题，都是由于 copy-paste省事导致的，需要格外注意！\n规则13.7 避免将用户输入作为格式化字符串的一部分或者全部。 调用格式化I/O函数时，不要直接或者间接将用户输入作为格式化字符串的一部分或者全部。攻击者对一个格式化字符串拥有部分或完全控制，存在以下风险：进程崩溃、查看栈的内容、改写内存、甚至执行任意代码。 错误示例：\n1 char input[1000];if (fgets(input, sizeof(input) - 1, stdin) == NULL){ /* handle error */}input[sizeof(input)-1] = \u0026#39;\\0\u0026#39;;printf(input); 上述代码input直接来自用户输入，并作为格式化字符串直接传递给printf()。当用户输入的是“%s%s%s%s%s%s%s%s%s%s%s%s”，就可能触发无效指针或未映射的地址读取。格式字符%s显示栈上相应参数所指定的地址的内存。这里input被当成格式化字符串，而没有提供参数，因此printf()读取栈中任意内存位置，指导格式字符耗尽或者遇到一个无效指针或未映射地址为止。 正确示例，给printf()传两个参数，第一个参数为”%s”，目的是将格式化字符串确定下来；第二个参数为用户输入input：\n1 char input[1000];if (fgets(input, sizeof(input)-1, stdin) == NULL) { /* handle error */}input[sizeof(input)-1] = \u0026#39;\\0\u0026#39;;printf(“%s”, input); 规则13.8 避免使用strlen()计算二进制数据的长度。 strlen()函数用于计算字符串的长度，它返回字符串中第一个NULL结束符之前的字符的数量。因此用strlen()处理文件I/O函数读取的内容时要小心，因为这些内容可能是二进制也可能是文本。 错误示例：\n1 char buf[BUF_SIZE + 1];if (fgets(buf, sizeof(buf), fp) == NULL){ /* handle error */}buf[strlen(buf) - 1] = \u0026#39;\\0\u0026#39;; 上述代码试图从一个输入行中删除行尾的换行符（\\n）。如果buf的第一个字符是NULL，strlen(buf)返回0，这时对buf进行数组下标为[-1]的访问操作将会越界。 正确示例，在不能确定从文件读取到的数据的类型时，不要使用依赖NULL结束符的字符串操作函数：\n1 char buf[BUF_SIZE + 1];char *p;if (fgets(buf, sizeof(buf), fp)) { p = strchr(buf, \u0026#39;\\n\u0026#39;); if (p) { *p = \u0026#39;\\0\u0026#39;; }}else{ /* handle error condition */} 规则13.9 使用int类型变量来接受字符I/O函数的返回值。 字符I/O函数fgetc()、getc()和getchar()都从一个流读取一个字符，并把它以int值的形式返回。如果这个流到达了文件尾或者发生读取错误，函数返回EOF。fputc()、putc()、putchar()和ungetc()也返回一个字符或EOF。 **如果这些I/O函数的返回值需要与EOF进行比较，不要将返回值转换为char类型。**因为char是有符号8位的值，int是32位的值。如果getchar()返回的字符的ASCII值为0xFF，转换为char类型后将被解释为EOF。因为这个值被有符号扩展为0xFFFFFFFF（EOF的值）执行比较。 错误示例：\n1 char buf[BUF_SIZE];char ch;int i = 0;while ( (ch = getchar()) != \u0026#39;\\n\u0026#39; \u0026amp;\u0026amp; ch != EOF ){ if ( i \u0026lt; BUF_SIZE - 1 ) { buf[i++] = ch; }}buf[i] = \u0026#39;\\0\u0026#39;; /* terminate NTBS */ 正确做法：使用int类型的变量接受getchar()的返回值。\n1 char buf[BUF_SIZE];int ch;int i = 0;while (((ch = getchar()) != \u0026#39;\\n\u0026#39;) \u0026amp;\u0026amp; ch != EOF) { if (i \u0026lt; BUF_SIZE - 1) { buf[i++] = ch; }}buf[i] = \u0026#39;\\0\u0026#39;; /* terminate NTBS */ 规则13.10 防止命令注入。 如果system()的参数由用户的输入组成，恶意用户可以通过构造恶意输入，改变system()调用的行为。 示例：\n1 system(sprintf(\u0026#34;any_exe %s\u0026#34;, input)); 如果恶意用户输入参数：\n1 happy; useradd attacker 最终shell会将字符串解释为两条独立的命令：“any_exe happy; useradd attacker”。\n14 单元测试 规则 规则14.1 在编写代码的同时，或者编写代码前，编写单元测试用例验证软件设计/编码的正确。 建议 建议14.1 单元测试关注单元的行为而不是实现，避免针对函数的测试。 15 可移植性 规则 规则15.1 不能定义、重定义或取消定义标准库/平台中保留的标识符、宏和函数。 建议 建议15.1 不使用与硬件或操作系统关系很大的语句，而使用建议的标准语句，以提高软件的可移植性和可重用性。 使用标准的数据类型，有利于程序的移植。\n建议15.2 除非为了满足特殊需求，避免使用嵌入式汇编。 16 业界编程规范 《Google C++编程指南》 《汽车业C语言使用规范(MISRA)》 仅供参考，可能有误\n","date":"2024-11-23T00:00:00Z","image":"http://localhost:1313/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/background_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/%E5%8D%8E%E4%B8%BA%E5%B5%8C%E5%85%A5%E5%BC%8Fc%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81%E7%AE%80%E6%98%8E%E8%A7%84%E8%8C%83/","title":"华为嵌入式C语言代码简明规范"},{"content":"参考学习SUNPLUS 《PID **调节控制做电机速度控制》**后总结，在线阅读链接如下：\n1343214947-695804.pdf\n浅析PID PID 控制器是一种广泛应用于工业控制系统的控制器，它通过将偏差的比例（Proportion）、积分（Integral）和微分（Differential）三个部分进行线性组合，生成控制量，从而对被控对象进行控制。PID 控制器的核心思想是通过对系统偏差的实时调整，使系统的输出尽可能接近期望值。\n1 模拟 PID 控制原理 1.1 模拟 PID 控制系统的原理框图 如图 1-2 所示，模拟 PID 控制系统由 PID 控制器和被控对象（如电机）组成。系统的输入是给定值 ($r(t)$)，输出是实际输出值 ($y(t)$)，偏差 ($e(t) = r(t) - y(t)$) 作为 PID 控制器的输入，控制器的输出 ($u(t)$) 作为被控对象的输入。\nPID 控制器的控制规律可以用以下公式表示：\n$$ u(t) = K_p \\left[ e(t) + \\frac{1}{T_i} \\int_0^t e(\\tau) d\\tau + T_d \\frac{de(t)}{dt} \\right] $$如何理解呢？\n其中：\n$K_p$：比例系数，决定比例控制的强度。 $T_i$：积分时间，决定积分控制的强度。 $T_d$：微分时间，决定微分控制的强度。 PID 控制器的三个部分 比例部分（Proportion） 比例部分的数学表达式为：\n$$ K_p \\cdot e(t) $$作用：比例控制的作用是对偏差瞬间作出反应。偏差一旦产生，控制器立即产生控制作用，使控制量向减少偏差的方向变化。\n特点：\n比例系数 ($K_p$) 越大，控制作用越强，系统的响应速度越快，静态偏差越小。 但 $K_p$ 过大会导致系统振荡，破坏系统的稳定性。 总结：比例控制能够快速响应偏差，但过大的比例系数会导致系统不稳定。\n积分部分（Integral） 积分部分的数学表达式为：\n$$ \\frac{K_p}{T_i} \\int_0^t e(\\tau) d\\tau $$作用：积分控制的作用是消除系统的稳态误差。只要存在偏差，积分控制的作用就会不断增加，直到偏差为零。\n特点：\n积分时间 ($T_i$) 越大，积分作用越弱，系统的响应速度变慢，但可以减少超调量，提高系统的稳定性。 积分时间 ($T_i$) 越小，积分作用越强，系统的响应速度加快，但可能会引起系统振荡。 总结：积分控制能够消除系统的稳态误差，但会降低系统的响应速度，并可能引起超调。\n微分部分（Differential） 微分部分的数学表达式为：\n$$ K_p \\cdot T_d \\cdot \\frac{de(t)}{dt} $$作用：微分控制的作用是根据偏差的变化趋势进行控制。它能够在偏差变化的瞬间提前给出控制信号，抑制系统的超调和振荡。\n特点：\n微分时间 ($T_d$) 越大，微分作用越强，能够有效抑制系统的超调和振荡。 但微分控制对噪声敏感，噪声较大的系统中应谨慎使用微分控制。 总结：微分控制能够加快系统的响应速度，减少超调，但对噪声敏感。\nPID 控制器的综合作用 PID 控制器通过比例、积分和微分三个部分的组合，能够实现对系统的快速、稳定和精确控制：\n比例控制：快速响应偏差，减少静态误差。 积分控制：消除稳态误差，确保系统最终达到期望值。 微分控制：抑制系统的超调和振荡，提高系统的稳定性。 从模拟 PID 到数字 PID 随着计算机技术的发展，模拟 PID 控制逐渐被数字 PID 控制取代。数字 PID 控制通过将模拟 PID 控制规律进行离散化处理，能够在计算机中实现 PID 控制算法。数字 PID 控制具有以下优点：\n灵活性：可以通过软件调整 PID 参数，适应不同的控制需求。 精度：数字控制能够实现高精度的控制。 抗干扰：数字控制对噪声和干扰的抑制能力更强。 总结 PID 控制器通过比例、积分和微分三个部分的组合，能够实现对系统的快速、稳定和精确控制。比例控制负责快速响应偏差，积分控制负责消除稳态误差，微分控制负责抑制系统的超调和振荡。通过合理调整 PID 参数，可以使系统达到最佳的控制效果。\n2. 数字 PID 控制 数字 PID 控制是通过计算机实现的 PID 控制算法。与模拟 PID 控制不同，数字 PID 控制是基于离散时间采样的控制方式，因此需要对连续的 PID 控制规律进行离散化处理。数字 PID 控制算法主要分为两种：位置式 PID 和 增量式 PID。\n2.1 位置式 （全量式）PID 算法 2.1.1 离散化处理 由于计算机控制是采样控制，系统只能在每个采样时刻根据当前的偏差计算控制量，而不能像模拟控制那样连续输出控制量。因此，模拟 PID 控制中的积分和微分项需要进行离散化处理。离散化处理的方法为：以T 作为采样周期， 作为采样序号，则离散采样时间对应着连续时间 ，用矩形法数值积分近似代替积分，用一阶后向差分近似代替微分，可作如下近似变换 $$ t \\approx kT \\qquad (k = 0, 1, 2, \\ldots) $$$$ \\int_0^t e(t) \\, dt \\approx T \\sum_{j=0}^{k} e(jT) = T \\sum_{j=0}^{k} e_j $$$$ \\frac{de(t)}{dt} \\approx \\frac{e(kT) - e[(k-1)T]}{T} = \\frac{e_k - e_{k-1}}{T} $$容易联想到，这里使用中矩形法和一阶向后差分代替微分，此处的后是后方的意思，对应的是计算方法中的向前差分，那么，是否可以用三点向前公式来提高微分部分或者用牛顿-科特斯等其他方法替代呢？事实上是可以的，大部分比赛使用均为普通PID，下限高上限低，这种方法上限理论上会高一些，但调参压力应该会大很多，有没有必要在比赛中运用，效果有待测试。\n基于 Runge-Kutta 模型的耦合四水箱系统自适应 PID 控制器应用 | IEEE 会议出版物 | IEEE Xplore \u0026mdash; Runge-Kutta Model-Based Adaptive PID Controller Applied to a 4 Coupled-tank System | IEEE Conference Publication | IEEE Xplore\n龙格-库塔法 vs 自适应积分法 vs 校正欧拉公式 vs 三点公式 vs 牛顿-科特斯公式\n特性 三点公式（微分） 牛顿-科特斯公式（积分） 校正欧拉公式（积分） 自适应积分法（积分） 龙格-库塔法（积分） 精度 高（优于一阶差分） 高（梯形法和辛普森法优于矩形法） 较高（接近梯形法，优于矩形法） 高（动态调整步长，精度最高） 非常高（四阶龙格-库塔法误差为 $O(h4)$） 噪声敏感性 较低（中心差分对噪声不敏感） 较高（对噪声敏感，可能需要滤波） 较高（对噪声敏感，可能需要滤波） 较高（对噪声敏感，可能需要滤波） 较高（对噪声敏感，可能需要滤波） 计算复杂度 低（只需当前和前或后两个点的数据） 较高（尤其是辛普森法） 适中（比辛普森法低，比矩形法高） 高（动态调整步长，计算量较大） 高（每一步需计算多个中间值） 实时性 受限（需要未来数据） 较好（只需当前和过去数据） 较好（只需当前和过去数据） 较差（动态调整步长，计算量大） 较差（计算量大，不适合实时系统） 存储需求 低（只需存储少量数据） 较高（尤其是辛普森法需要更多历史数据） 适中（需要存储当前和过去数据） 高（需要存储中间计算结果） 高（需要存储中间计算结果） 适用场景 动态变化较快的系统 误差变化较平滑的系统 实时性要求较高的系统 高精度要求的复杂系统 高精度要求的复杂系统 还是先回到最初的地方。\n采样周期 $ T $：计算机每隔 $ T $ 时间采样一次系统的偏差。 采样序号 $ k $：表示第 $ k $ 次采样时刻，$ k = 0, 1, 2, \\dots $。 离散时间 $ kT $：对应连续时间 $ t $。 通过离散化处理，积分和微分项可以近似表示为：\n积分项：用矩形法数值积分近似代替连续积分。 微分项：用一阶后向差分近似代替连续微分。 离散化后的 PID 控制规律为：\n$$ u_k = K_p \\left[ e_k + \\frac{T}{T_i} \\sum_{j=0}^k e_j + T_d \\frac{e_k - e_{k-1}}{T} \\right] $$其中：\n$ u_k $：第 $ k $ 次采样时刻的控制量。 $ e_k $：第 $ k $ 次采样时刻的偏差。 $ e_{k-1} $：第 $ k-1 $ 次采样时刻的偏差。 $ K_p $：比例系数。 $ T_i $：积分时间。 $ T_d $：微分时间。 2.1.2 位置式 （全量式） PID 的数学表达式 位置式 PID 的数学表达式可以写成：\n$$ u_k = K_p e_k + K_i \\sum_{j=0}^k e_j + K_d (e_k - e_{k-1}) $$其中：\n$ K_i = \\frac{K_p T}{T_i} $：积分系数。 $ K_d = \\frac{K_p T_d}{T} $：微分系数。 2.1.3 位置式 PID 的特点 如果采样周期足够小，则前面两个公式的近似计算可以获得足够精确的结果，离散控制过程与连续过程十分接近。\n全量输出：位置式 PID 直接输出控制量的绝对值，因此每次输出都与过去的状态有关。 计算量大：由于需要对偏差进行累加，计算量较大。 风险：如果计算机出现故障，控制量的突变会导致执行机构的剧烈变化，可能引发生产事故。增量式PID可以避免这种现象。 2.2 增量式 PID 算法 2.2.1 增量式 PID 的定义 增量式 PID 是指数字控制器的输出是控制量的增量 $ \\Delta u_k $，而不是控制量的绝对值。增量式 PID 适用于执行机构需要增量控制的系统。\n2.2.2 增量式 PID 的推导 增量式 PID 可以通过位置式 PID 推导出来。首先，写出第 $ k-1 $ 次采样时刻的控制量：\n$$ u_{k-1} = K_p e_{k-1} + K_i \\sum_{j=0}^{k-1} e_j + K_d (e_{k-1} - e_{k-2}) $$然后将位置式 PID 的第 $ k $ 次控制量 $ u_k $ 与第 $ k-1 $ 次控制量 $ u_{k-1} $ 相减，得到增量式 PID 的表达式：\n$$ \\Delta u_k = u_k - u_{k-1} = K_p (e_k - e_{k-1}) + K_i e_k + K_d (e_k - 2e_{k-1} + e_{k-2}) $$进一步整理后，增量式 PID 的公式为：\n$$ \\Delta u_k = A e_k + B e_{k-1} + C e_{k-2} $$其中：\n$ A = K_p \\left(1 + \\frac{T}{T_i} + \\frac{T_d}{T}\\right) $ $ B = -K_p \\left(1 + \\frac{2T_d}{T}\\right) $ $ C = K_p \\frac{T_d}{T} $ 2.2.3 增量式 PID 的特点 增量输出：增量式 PID 输出的是控制量的增量，而不是绝对值。 计算量小：只需要当前和前两次的偏差值和唯一确定的$A$$B$$C$，计算量较小。 安全性高：即使计算机出现故障，控制量的变化也不会太大，避免了执行机构的剧烈变化。 2.2.4 增量式 PID 的递推公式 增量式 PID 可以通过递推公式实现位置式 PID 的控制：\n$$ u_k = u_{k-1} + \\Delta u_k $$这种递推公式在计算机控制中广泛应用。\n总结 为什么增量式 PID 在计算机故障时更稳定？ （1）不依赖历史误差的累积 在位置式 PID 中，积分项是对历史误差的累积：\nu(k)=Kpe(k)+Ki∑i=0ke(i)+Kd[e(k)−e(k−1)]u(k)=Kpe(k)+Kii=0∑k**e(i)+K**d[e(k)−e(k−1)]\n如果计算机故障导致历史误差数据丢失，积分项会突然变化，导致控制量 u(k)u(k) 发生剧烈波动。\n在增量式 PID 中，积分项只依赖于当前误差 e(k)e(k)，而不需要累积历史误差：\nΔu(k)=Kp[e(k)−e(k−1)]+Kie(k)+Kd[e(k)−2e(k−1)+e(k−2)]Δu(k)=K**p[e(k)−e(k−1)]+Kie(k)+K**d[e(k)−2e(k−1)+e(k−2)]\n即使计算机故障导致部分数据丢失，增量式 PID 也只影响当前时刻的控制量增量 Δu(k)Δu(k)，而不会导致控制量 u(k)u(k) 的剧烈变化。\n（2）增量输出的平滑性 增量式 PID 的输出是控制量的增量 Δu(k)Δu(k)，而不是绝对量 u(k)u(k)。即使 Δu(k)Δu(k) 发生突变，控制量的实际输出 u(k)u(k) 也只是在前一时刻的基础上增加或减少一个较小的量，因此不会出现大幅度变化。 （3）故障恢复能力强 如果计算机故障后恢复正常，增量式 PID 可以从当前状态继续运行，而不需要重新初始化积分项。这种特性使得增量式 PID 在故障恢复后能够快速回到正常工作状态。 增量式 PID 的其他优点 除了在计算机故障时的稳定性外，增量式 PID 还具有以下优点：\n无积分饱和问题： 位置式 PID 的积分项可能会因为误差的长期累积而导致积分饱和，而增量式 PID 的积分项只依赖于当前误差，因此不会出现积分饱和问题。 易于实现手动/自动切换： 增量式 PID 的输出是控制量的增量，因此可以方便地实现手动控制和自动控制之间的切换。 适合执行器带积分特性的系统： 对于执行器本身具有积分特性（如步进电机）的系统，增量式 PID 更容易实现控制。 特性 位置式 PID 增量式 PID 输出形式 控制量的绝对值 控制量的增量 计算量 大（需要累加所有偏差） 小（只需当前和前两次偏差） 安全性 低（故障时控制量突变） 高（故障时控制量变化小） 适用场景 需要精确控制位置的系统 需要增量控制的系统 2.3.1 凑试法 凑试法是一种通过逐步调整控制器参数（比例 $K_p$、积分 $T_i$、微分 $T_d$）来优化控制系统性能的方法。它的特点是按照“先比例（P）、再积分（I）、最后微分（D）”的顺序进行调节。下面我用通俗易懂的语言来解释这个过程：\n1. 什么是凑试法？ 凑试法是通过手动调整控制器的参数，观察系统的响应曲线，逐步找到最佳参数组合的方法。它的核心思想是：\n先调整比例作用 $K_p$，让系统快速响应。 然后加入积分作用 $T_i$，消除系统的稳态误差。 最后加入微分作用 $T_d$，抑制系统的超调和振荡。 2. 凑试法的步骤： 第一步：整定比例系数 $K_p$（纯比例控制） 将控制器的积分时间 $T_i$ 设为无穷大（$T_i = \\infty$），相当于关闭积分作用。 将微分时间 $T_d$ 设为零（$T_d = 0$），相当于关闭微分作用。 只保留比例作用 $K_p$，并按照经验设置一个初始值。 将系统投入运行，观察系统的响应曲线。 由小到大调整 $K_p$，直到系统的过渡过程曲线呈现出1/4衰减度（即每个波峰的幅度是前一个波峰的1/4）。此时的比例系数 $K_p$ 是一个比较合适的值。 第二步：引入积分作用 $T_i$（PI控制） 在第一步的基础上，将比例系数 $K_p$ 减小到原来的 5/6（即 $K_p = \\frac{5}{6} K_p$）。 引入积分作用，将积分时间 $T_i$ 从大到小逐步调整。 观察系统的响应曲线，直到系统的稳态误差被消除，同时过渡过程曲线仍然保持较好的动态性能。 第三步：引入微分作用 $T_d$（PID控制） 如果需要进一步优化系统性能，可以引入微分作用。 微分时间 $T_d$ 可以按照经验值设置，或者根据积分时间 $T_i$ 计算，通常取 $T_d = \\left( \\frac{1}{3} \\sim \\frac{1}{4} \\right) T_i$。 将 $T_d$ 由小到大逐步调整，观察系统的响应曲线，直到系统的超调和振荡被有效抑制。 3. 通俗理解： 你可以把控制系统想象成开车：\n比例作用 $K_p$：就像你控制方向盘的力度。如果力度太小，车子会偏离路线；如果力度太大，车子会来回摆动。凑试法就是找到一个合适的力度，让车子既不偏离路线，又不会过度摆动。 积分作用 $T_i$：就像你发现车子总是偏向一边，于是你慢慢调整方向盘，直到车子回到正轨。积分作用就是消除系统的“偏差”。 微分作用 $T_d$：就像你提前预判路况，轻轻调整方向盘，防止车子突然转向过度。微分作用就是抑制系统的“振荡”。 4. 注意事项： 1/4衰减度：这是凑试法的目标，表示系统的响应曲线在每个周期内衰减到前一个周期的1/4。这种响应既快速又稳定，适合大多数工业控制系统。 参数调整顺序：一定要按照“先P、再I、最后D”的顺序调整，否则可能会导致系统不稳定。 经验值：在实际应用中，初始参数和调整范围可以基于经验或系统特性进行设置。 总结： 凑试法是一种简单实用的控制器参数整定方法，通过逐步调整 $K_p$、$T_i$、$T_d$，最终让系统的响应既快速又稳定。虽然需要一定的经验和耐心，但它的灵活性和直观性使其在工业控制中广泛应用。\n临界比例法 1. 什么是临界比例法？ 临界比例法是通过调整控制器的参数（比例系数 $K_p$、积分时间 $T_i$、微分时间 $T_d$），使系统产生等幅振荡，然后根据振荡的特性来计算出最佳的控制器参数。\n2. 临界比例法的步骤： 第一步：设置初始参数 将控制器的积分时间 $T_i$ 调到最大（相当于关闭积分作用），微分时间 $T_d$ 设为零（关闭微分作用），只保留比例作用 $K_p$。 让系统在自动控制下运行一段时间，确保系统处于稳定状态。 第二步：增大比例系数 $K_p$，找到临界点 逐渐增大比例系数 $K_p$，直到系统开始出现等幅振荡（即系统的输出在某个值附近来回波动，且波动的幅度保持不变）。 记录下此时的临界比例系数 $K_u$ 和临界振荡周期 $T_u$（即两个波峰之间的时间间隔）。 第三步：计算控制器参数 根据 $K_u$ 和 $T_u$，使用经验公式计算出控制器的最佳参数 $K_p$、$T_i$ 和 $T_d$。 按照“先调 $K_p$，再调 $T_i$，最后调 $T_d$”的顺序，将控制器的参数设置到计算值上。 如果效果还不够理想，可以进一步微调。 3. 临界比例法的注意事项： 临界比例系数过大：有些系统的临界比例系数 $K_u$ 可能非常大，导致系统接近“开关控制”（即控制器输出要么最大，要么最小），这对工业生产不利，可能会造成设备频繁启停，影响生产。 无法产生等幅振荡：有些系统即使将比例系数 $K_p$ 调到最大，也无法产生等幅振荡。这时，可以将最大刻度值作为临界比例系数 $K_u$ 来进行参数整定。 4. 通俗理解： 你可以把控制系统想象成一个调节水流的阀门。比例系数 $K_p$ 就像是你调节阀门的力度：\n如果力度太小，水流的变化会很慢，系统反应迟钝。 如果力度太大，水流会来回波动，系统不稳定。 临界比例法就是找到一个刚好让水流开始等幅波动的力度（$K_u$），然后根据这个力度和波动的频率（$T_u$），计算出最佳的调节力度（$K_p$）、调节速度（$T_i$）和调节的提前量（$T_d$）。 通过这种方法，你可以让系统既快速响应，又不会过度波动，达到最佳的控制效果。\nZiegler-Nichols 法进行PID参数整定的基本原理 临界比例度法的步骤 临界比例度法通过调整比例增益 KpK**p，使系统产生等幅振荡（临界振荡），然后根据临界振荡的特性确定 PID 参数。\n步骤 1：仅使用比例控制 按临界比例法得到临界比例系数 $K_u$ 和临界振荡周期 $T_u$（即两个波峰之间的时间间隔）， 步骤 2：计算 PID 参数 根据 Z-N 法的推荐公式，计算 PID 控制器的参数：\n控制器类型 $ K_p $ $ T_i $ $ T_d $ P $ 0.5 \\cdot K_u $ - - PI $ 0.45 \\cdot K_u $ $ 0.85 \\cdot T_u $ - PID $ 0.6 \\cdot K_u $ $ 0.5 \\cdot T_u $ $ 0.12 \\cdot T_u $ 3. Z-N 法与增量式 PID 的结合 增量式 PID 的控制量增量公式为：\n$$ \\Delta u(k) = K_p[e(k) - e(k-1)] + \\frac{K_p}{T_i}e(k) + K_pT_d[e(k) - 2e(k-1) + e(k-2)] $$其中：\n$ K_i = \\frac{K_p}{T_i} $ 是积分系数。 $ K_d = K_pT_d $ 是微分系数。 使用 Z-N 法整定参数后，可以将 $ K_p $、$ T_i $、$ T_d $ 代入增量式 PID 公式中，实现控制器的设计。\n6. Z-N 法与增量式 PID 的结合示例 假设通过 Z-N 法得到以下参数：\n临界比例增益 $ K_{cr} = 10 $ 临界振荡周期 $ T_{cr} = 2 $ 秒 根据 Z-N 法的推荐公式，PID 参数为：\n$$ K_p = 0.6K_{u} = 6, \\\\ T_i = 0.5T_{u} = 1, \\\\ T_d = 0.125T_{u} = 0.25 $$因此，增量式 PID 的控制量增量公式为：\n$$ \\Delta u(k) = 6[e(k) - e(k-1)] + \\frac{6}{1}e(k) + 6 \\cdot 0.25 [e(k) - 2e(k-1) + e(k-2)] $$简化后得到：\n$$ \\Delta u(k) = 6[e(k) - e(k-1)] + 6e(k) + 1.5[e(k) - 2e(k-1) + e(k-2)] $$7. 总结 Z-N 法 是一种经典的 PID 参数整定方法，通过临界振荡实验确定 $ K_p $、$ T_i $、$ T_d $。 Z-N 法假设系统是线性的，对于非线性系统可能不适用。 增量式 PID 通过计算控制量的增量来调整输出，具有较强的鲁棒性和抗积分饱和能力。 将 Z-N 法与增量式 PID 结合，可以快速整定控制器参数，并提高系统的稳定性和可靠性。 采样周期 香农采样定律：采样频率必须至少是信号最高频率的两倍，否则信号会失真。 采样周期的选择： 响应快的系统（如流量、压力）选择较短的采样周期。 响应慢的系统（如温度、成分）选择较长的采样周期。 采样周期应远小于干扰信号的周期。 执行器响应慢时，采样周期可以适当延长。 计算机性能允许时，采样周期越短，控制效果越好。 对于滞后大的系统，采样周期通常为滞后时间的1/4～1/8。 ","date":"2024-11-23T00:00:00Z","image":"http://localhost:1313/p/%E6%B5%85%E6%9E%90pid/background_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/%E6%B5%85%E6%9E%90pid/","title":"浅析PID"},{"content":"MQTT（消息队列遥测传输协议） MQTT是轻量级的消息发布/订阅协议，设计用于资源受限的设备和低带宽、高延迟的网络环境。它已成为物联网领域的事实标准，广泛应用于智能家居、工业自动化等领域。\nmqtt比较简单，算是我入门物联网使用的第一种方式（协议）。从搭建mqtt服务器，协议原理，连接方式以及mqtt上位机编写，通过实操都有了一定了解了。\nMQTT服务器搭建（mosquitto） | Regen (regenm.github.io)\nesp8266连接服务器（基于mosquitto的mqtt server） | Regen (regenm.github.io)\nmqttSender | Regen (regenm.github.io)\nCoAP（受限应用协议） Coap（Constrained Application Protocol） 使用在资源受限的物联网设备上，\nCoap协议特点\nCOAP协议网络传输层由TCP改为UDP。 它基于REST，server的资源地址和互联网一样也有类似url的格式，客户端同样有POST，GET,PUT,DELETE方法来访问server，HTTP做了简化。 COAP是二进制格式的，HTTP是文本格式的，COAP比HTTP更加紧凑。 轻量化，COAP最小长度仅仅4B，一个HTTP的头都几十个B了。 支持可靠传输，数据重传，块传输。确保数据可靠到达。 支持IP多播，即可以同时向多个设备发送请求。 非长连接通信，适用于低功耗物联网场景 CoAP是为物联网设备设计的轻量级协议，基于REST架构，与HTTP类似，但更加节能和高效，适用于低功耗、受限网络的物联网设备。\nto be continued\nLoRaWAN LoRa和LoRaWAN的区别 LoRa：LoRa是一种物理层的调制技术，用于在设备之间传输无线电信号。它能够在不消耗大量电力的情况下，实现设备之间的长距离数据传输。LoRa的通信通常是点对点的，或者在某些场景下是点对多点的。 LoRaWAN：LoRaWAN是LoRa的网络层协议，用于管理LoRa设备如何在广域网中进行通信。它定义了设备如何与集中式网络服务器（通常通过网关）通信，从而实现设备数据的收集和处理。 1. LoRa： 定义：LoRa（Long Range）是一种调制技术，用于无线数据传输。它属于物理层（PHY），负责将数据编码成无线电信号，以便设备在长距离内进行低功耗通信。 作用：LoRa技术的主要优势是支持低功耗、长距离的通信，通常可以在几公里到几十公里的范围内工作，具体取决于环境和地理条件。 用途：LoRa用于设备之间的直接无线通信，它不涉及设备如何联网或管理通信的高级功能。 2. LoRaWAN： 定义：LoRaWAN（LoRa Wide Area Network）是基于LoRa技术的网络层协议，定义了设备如何在广域网中进行通信。它包括了数据传输的管理、设备与网络的互联，以及如何实现数据的加密、认证等高级功能。 作用：LoRaWAN管理LoRa设备与网关、服务器之间的通信，确保数据能够从设备安全地传输到网络服务器，并从服务器发送指令到设备。它定义了星型拓扑结构、设备的通信模式、数据传输的时间窗口等。 用途：LoRaWAN使得LoRa设备能够连接到互联网，实现大规模物联网应用中的设备管理和数据处理。 LoRaWAN协议用于LoRa设备之间的通信，支持长距离、低功耗的无线通信。它在智能城市、农业监控和远程传感应用中得到广泛采用。\nto be continued\nIPv6和6LoWPAN IPv6的普及为每个物联网设备提供了一个唯一的IP地址，解决了地址匮乏问题。6LoWPAN（IPv6 over Low-Power Wireless Personal Area Networks）使得IPv6能够在低功耗、低速率的无线网络中使用，支持大规模物联网部署。\nto be continued\nThread： Thread是一种为智能家居和建筑自动化设计的低功耗无线协议，基于IPv6，提供了更好的安全性、可靠性和可扩展性。它兼容现有的IP网络，并支持数百个设备的互联。\nto be continued\nZigbee 特点：低功耗、短距离、基于IEEE 802.15.4标准的无线网络协议。 应用场景：适用于家庭自动化、楼宇控制、传感器网络等应用。 优点：低功耗，支持网状网络（Mesh Network），具有较强的自愈能力和扩展性。 to be continued\nZ-Wave 特点：低功耗、短距离、专为智能家居设计的无线通信协议。 应用场景：广泛应用于家庭自动化系统，如灯光控制、门锁、安全系统。 优点：低功耗，良好的互操作性，支持家庭网络的点对点通信。 to be continued\nBluetooth Low Energy（BLE） 特点：低功耗、短距离、蓝牙4.0及以上版本的特性。 应用场景：适用于短距离、低功耗的设备，如可穿戴设备、医疗设备、智能家居。 优点：低功耗，广泛支持，适合需要定期传输小数据量的设备。 to be continued\nNB-IoT（Narrowband IoT） 特点：低功耗广域网技术，基于蜂窝网络。 应用场景：适用于广域覆盖和低数据速率的物联网应用，如智能计量、资产追踪、智慧城市。 优点：深度覆盖，支持海量设备连接，电池寿命长。 to be continued\nSigfox 特点：超窄带、低功耗广域网技术。 应用场景：适用于低数据传输速率和低功耗的应用，如资产跟踪、环境监测、智能城市。 优点：全球覆盖，超低功耗，成本低，适合大规模部署。 to be continued\n6LoWPAN（IPv6 over Low-Power Wireless Personal Area Networks） 特点：将IPv6引入低功耗无线网络，适用于资源受限的设备。 应用场景：适用于需要与互联网通信的物联网设备，如智能家居、工业自动化。 优点：支持IP地址的直接分配，便于与现有互联网基础设施集成。 to be continued\nWi-Fi 特点：基于IEEE 802.11标准，提供高速、短距离无线通信。 应用场景：适用于需要高带宽、连续供电的物联网设备，如智能摄像头、家庭自动化设备。 优点：高速数据传输，广泛应用，易于部署。 to be continued\nCellular (LTE-M, NB-IoT, 5G) 特点：基于蜂窝网络的物联网通信协议，提供广域覆盖和高带宽。 应用场景：适用于需要广域覆盖和高可靠性的应用，如车联网、远程监控、物流追踪。 优点：广域覆盖，支持移动性，高带宽，适合大规模物联网部署。 仅供参考，可能有误\n","date":"2024-11-23T00:00:00Z","image":"http://localhost:1313/p/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/background_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/%E7%89%A9%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE%E5%9F%BA%E7%A1%80/","title":"物联网协议基础"},{"content":"第一章：Python基础与快速入门 Python 是一门跨平台、开源、免费的解释型高级动态编程语言。\npython 同时支持伪编译将 Python 源程序转换为字节码来优化程序和提高运行速度。\n支持使用 py2exe、pyinstaller 或 cx_Freeze 工具将 Python 程序转换为二进制可执行文件。\nPython 支持命令式编程（How to do）、函数式编程（What to do），完全支持面向对象程序设计\n注：这里所谓的命令式编程和函数式编程其实很好理解，下面的例子：\n命令式编程：\n1 2 3 4 5 6 7 8 # 初始化变量 count = 0 # 命令式地执行一系列操作 for i in range(10): count += i # 修改状态 print(count) # 输出结果 函数式编程：\n1 2 3 4 5 6 7 8 9 # 定义一个函数来计算两个数的和 def add(a, b): return a + b # 使用这个函数来计算3和5的和 result = add(3, 5) # 打印结果 print(result) # 输出: 8 胶水语言：可以把多种不同语言编写的程序融合到一起实现无缝拼接，更好地发挥不同语言和工具的优势，满足不同应用领域的需求。\nPython 几个重要的网站：\nhttps://www.python.org/\nhttps://www.python.org/doc/\nhttp://bugs.python.org/\nhttps://hackerone.com/python\nhttp://stackoverflow.com/questions/tagged/python\n这里忽略了 python 的安装与环境的配置，我使用的 Jupyter Notebook 进行 python 程序的编写。\n基础知识 Python 对象模型 对象是 python 中最基本的概念，在 python 中处理的一切都是对象。\n包含许多内置对象可直接使用，如数字、字符串、列表、del 等；\n非内置对象需要导入模块才能使用，如正弦函数 sin (x)，随机数产生函数 random ( ) 等。\n对象类型 类型名称 示例 简要说明 数字 int, float, complex 1234, 3.14, 1.3e5, 3+4j 数字大小没有限制，内置支持复数及其运算 字符串 str ‘swfu’, “I’m student”, ”’Python ”’, r’abc’, R’bcd’ 使用单引号、双引号、三引号作为定界符，以字母 r 或 R 引导的表示原始字符串 字节串 bytes b’hello world’ 以字母 b 引导，可以使用单引号、双引号、三引号作为定界符 列表 list [1, 2, 3]，[‘a’, ‘b’, [‘c’, 2]] 所有元素放在一对方括号中，元素之间使用逗号分隔，其中的元素可以是任意类型 字典 dict {1:’food’ ,2:’taste’, 3:’import’} 所有元素放在一对大括号中，元素之间使用逗号分隔，元素形式为 “键: 值” 元组 tuple (2, -5, 6), (3,) 不可变，所有元素放在一对圆括号中，元素之间使用逗号分隔，如果元组中只有一个元素的话，后面的逗号不能省略 集合 set frozenset {‘a’, ‘b’, ‘c’} 所有元素放在一对大括号中，元素之间使用逗号分隔，元素不允许重复 ; 另外，set 是可变的，而 frozenset 是不可变的 字符串（string） 定义：字符串是由 Unicode 字符组成的序列，用于处理文本数据。\n特性\n可以包含各种语言的字符。 不可变，即创建后不能更改其中的元素。 在 Python 3 中，所有的字符串默认都是 Unicode 字符串，所以前缀 u 或 U 不再需要。不过，仍然可以通过前缀 u 或 U 来表示一个 Unicode 字符串（例如 u\u0026quot;Hello\u0026quot;），但这在 Python 3 中并不是必需的。 用途：字符串通常用于表示和处理人类可读的文本信息，如文字、数字、符号等。\n字节串（bytes） 定义：字节串是由 0~255 范围内的整数（即 8 位字节）构成的序列，用于在程序中处理二进制数据。\n特性\n可以包含 ASCII 字符或其他编码的字节。 不可变，即一旦创建了一个字节串，就不能修改它。 在 Python 中，可以通过前缀 b 或 B 来表示一个字节串（例如 b\u0026quot;Hello\u0026quot;）。 用途：字节串通常用于处理非文本数据，如文件内容、网络数据、图像、音频等二进制数据。\n主要区别 编码方式：字符串使用 Unicode 编码，可以包含任何语言的字符；而字节串使用 bytes 编码，通常包含 ASCII 字符或其他特定编码的字节。 存储与表示：字符串以文本形式存储和表示，便于人类阅读和编辑；字节串则以二进制形式存储和表示，更适合计算机处理和传输。 用途差异：字符串主要用于处理文本信息；而字节串则主要用于处理二进制数据，如文件读写、网络通信等场景。 转换方法 字符串转字节串：可以使用字符串的.encode() 方法将其编码为字节串。例如，string.encode('utf-8') 会将字符串 string 编码为 UTF-8 格式的字节串。 字节串转字符串：可以使用字节串的.decode() 方法将其解码为字符串。例如，bytes_data.decode('utf-8') 会将 UTF-8 格式的字节串 bytes_data 解码为字符串。 对象类型 类型名称 示例 简要说明 布尔型 bool True, False 逻辑值，关系运算符、成员测试运算符、同一性测试运算符组成的表达式的值一般为 True 或 False 空类型 NoneType None 空值 异常 Exception、ValueError、TypeError Python 内置大量异常类，分别对应不同类型的异常 文件 f = open(‘data.dat’, ‘rb’) open 是 Python 内置函数，使用指定的模式打开文件，返回文件对象 其他可迭代对象 生成器对象、range 对象、zip 对象、enumerate 对象、map 对象、filter 对象等等 具有惰性求值的特点，除 range 对象之外，其他对象中的元素只能看一次 编程单元 函数（使用 def 定义） 类（使用 class 定义） 模块（类型为 module） 类和函数都属于可调用对象，模块用来集中存放函数、类、常量或其他对象 Python 变量 在 Python 中，不需事先声明变量名及其类型，直接赋值即可创建各种类型的对象变量。这一点适用于 Python 任意类型的对象。\n在 cpp 中，变量在声明时就需要声明变量的类型，而在 python 中则是直接给变量赋值。\nPython 属于强类型编程语言，Python 解释器会根据赋值或运算来自动推断变量类型。Python 还是一种动态类型语言，变量的类型也是可以随时变化的。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; x = 3 \u0026gt;\u0026gt;\u0026gt; print(type(x)) #type():查看变量类型 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = \u0026#39;Hello world.\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(type(x)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; isinstance(3, int) #isinstance():测试对象是否是某个类型的实例 True 如果变量出现在赋值运算符或复合赋值运算符（例如 +=、*= 等等）的左边则表示创建变量或修改变量的值，否则表示引用该变量的值\n字符串和元组属于不可变序列，不能通过下标的方式来修改其中的元素值，试图修改元组中元素的值时会抛出异常。\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; x = (1,2,3) \u0026gt;\u0026gt;\u0026gt; x[1] = 5 Traceback (most recent call last): File \u0026#34;\u0026lt;pyshell#7\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; x[1] = 5 TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment python 中允许多个变量指向同一个值\n1 2 3 4 5 6 x = 3 y = x print(id(x)) print(id(y)) 140729233032040 140729233032040 当修改其中一个变量值后，其内存地址将会变化，但并不影响另一变量\n1 2 3 4 5 x+=6 print(id(x)) print(id(y)) 140729233032424 140729233032040 Python 采用的是基于值的内存管理方式，如果为不同变量赋值为相同值，这个值在内存中只有一份，多个变量指向同一块内存地址。\n1 2 3 4 5 6 7 8 9 x = 3 y = 3 print(id(x)) print(id(y)) 140729233032040 140729233032040 x = [1, 1, 1, 1] id(x[0]) == id(x[1]) True 变量名必须以字母或下划线开头，但以下划线开头的变量在 Python 中有特殊含义；\n变量名中不能有空格以及标点符号（括号、引号、逗号、斜线、反斜线、冒号、句号、问号等）；\n不能使用关键字作变量名，可以导入 keyword 模块后使用 print (keyword.kwlist) 查看所有 Python 关键字 (33 个)；\n1 2 3 import keyword print(keyword.kwlist) [\u0026#39;False\u0026#39;, \u0026#39;None\u0026#39;, \u0026#39;True\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;as\u0026#39;, \u0026#39;assert\u0026#39;, \u0026#39;async\u0026#39;, \u0026#39;await\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;continue\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;elif\u0026#39;, \u0026#39;else\u0026#39;, \u0026#39;except\u0026#39;, \u0026#39;finally\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;lambda\u0026#39;, \u0026#39;nonlocal\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;or\u0026#39;, \u0026#39;pass\u0026#39;, \u0026#39;raise\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;try\u0026#39;, \u0026#39;while\u0026#39;, \u0026#39;with\u0026#39;, \u0026#39;yield\u0026#39;] 注（下划线的含义）：\n单下划线 _：\n在交互式环境中，_ 表示上一个表达式的结果。 在循环或迭代中，_ 通常用作一个占位符，表示某个值会被忽略。 1 2 for _ in range(5): print(\u0026#34;Hello, World!\u0026#34;) 双下划线 __：\n类的属性名如果以双下划线开头且不以双下划线结尾（例如，__foo），这会触发名称改写（name mangling）。这意味着该属性会在类被继承时通过特定的方式被重命名，以避免子类意外覆盖父类的属性。 1 2 3 4 5 6 7 8 9 class MyClass: def __init__(self): self.__secret = \u0026#34;hidden\u0026#34; class MySubClass(MyClass): def __init__(self): super().__init__() self.__secret = \u0026#34;not hidden\u0026#34; print(self._MyClass__secret) # 访问父类的隐藏属性 双下划线前缀和后缀 __xxx__：\n这种命名方式通常用于特殊方法或魔术方法（magic methods），这些方法具有特定的含义，并由 Python 解释器在特定情况下调用。例如，__init__ 用于初始化对象，__str__ 用于定义对象的字符串表示等。 1 2 3 4 5 6 class MyClass: def __init__(self, name): self.name = name def __str__(self): return f\u0026#34;MyClass with name {self.name}\u0026#34; 单下划线前缀 _xxx：\n通常用于表示变量或方法是 “受保护的” 或 “内部使用的”，这是一种约定俗成的命名习惯，用于指示这些变量或方法不应该被类的外部直接访问。然而，这并不会引起 Python 解释器的任何强制限制，只是表明了一种使用意图。 1 2 3 class MyClass: def _internal_method(self): print(\u0026#34;This is an internal method.\u0026#34;) 不建议****使用系统内置的模块名、类型名或函数名以及已导入的模块名及其成员名作变量名，这将会改变其类型和含义，可以通过 dir (builtins) 查看所有内置模块、类型和函数；\n变量名对英文字母的****大小写敏感，例如 student 和 Student 是不同的变量。\nPython 中的变量并不直接存储值，而是存储了值的内存地址或者引用，这也是变量类型随时可以改变的原因。\n赋值语句的执行过程是：首先把等号右侧表达式的值计算出来，然后在内存中寻找一个位置把值存放进去，最后创建变量并指向这个内存地址。\nPython 具有自动内存管理功能，对于没有任何变量指向的值，Python 自动将其删除。Python 会跟踪所有的值，并自动删除不再有变量指向的值。\n显式使用 del 命令删除不需要的值或显式关闭不再需要访问的资源，仍是一个好的习惯，同时也是一个优秀程序员的基本素养之一。\nPython 的数字类型 三类：整数类型、浮点类型与复数类型\n整数类型\n・十进制整数如，0、-1、9、123\n・十六进制整数，需要 16 个数字 0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f 来表示整数，必须以 0x 开头，如 0x10、0xfa、0xabcdef\n・八进制整数，只需要 8 个数字 0、1、2、3、4、5、6、7 来表示整数，必须以 0o 开头，如 0o35、0o11\n・二进制整数，只需要 2 个数字 0、1 来表示整数，必须以 0b 开头如，0b101、0b100\n浮点数类型：浮点数****又称小数\nü15.0、0.37、-11.2、1.2e2、314.15e-2\nPython 内置支持复数类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026gt;\u0026gt;\u0026gt; a = 3+4j \u0026gt;\u0026gt;\u0026gt; b = 5+6j \u0026gt;\u0026gt;\u0026gt; c = a+b \u0026gt;\u0026gt;\u0026gt; c (8+10j) \u0026gt;\u0026gt;\u0026gt; c.real #查看复数实部 8.0 \u0026gt;\u0026gt;\u0026gt; c.imag #查看复数虚部 10.0 \u0026gt;\u0026gt;\u0026gt; a.conjugate() #返回共轭复数 (3-4j) \u0026gt;\u0026gt;\u0026gt; a*b #复数乘法 (-9+38j) \u0026gt;\u0026gt;\u0026gt; a/b #复数除法 (0.6393442622950819+0.03278688524590165j) Python 3.6.x 开始支持在数字中间位置使用单个下划线作为分隔来提高数字的可读性，类似于数学上使用逗号作为千位分隔符。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 1_000_000 1000000 \u0026gt;\u0026gt;\u0026gt; 1_2_3_4 1234 \u0026gt;\u0026gt;\u0026gt; 1_2 + 3_4j (12+34j) \u0026gt;\u0026gt;\u0026gt; 1_2.3_45 12.345 字符串 n 用单引号、双引号或三引号界定的符号系列称为字符串\nn 单引号、双引号、三单引号、三双引号可以互相嵌套，用来表示复杂字符串\n例如： __ \u0026lsquo;__ abc \u0026rsquo; 、 \u0026lsquo;123\u0026rsquo; 、 \u0026rsquo; 中国 \u0026rsquo; 、 \u0026ldquo;Python\u0026rdquo; 、\u0026lsquo;\u0026lsquo;\u0026lsquo;Tom said, \u0026ldquo;Let\u0026rsquo;s go\u0026rdquo;\u0026rsquo;\u0026rsquo;\u0026rsquo;\n字符串属于不可变序列\n空字符串表示为” 或 “”\n三引号”’或””” 表示的字符串可以换行，支持排版较为复杂的字符串；三引号还可以在程序中表示较长的注释。\n字符串的拼接 字符串之间可以通过 + 或 * 进行连接\n加法操作 (+) 将两个字符串连接成为一个新的字符串\n乘法操作 (*) 生成一个由其本身字符串重复连接而成的字符串\nlen () 函数能否返回一个字符串的长度\n字符串的转义 转义字符 含义 转义字符 含义 \\b 退格，把光标移动到前一列位置 \\ 一个斜线\\ \\f 换页符 \\’ 单引号’ \\n 换行符 \\” 双引号” \\r 回车 \\ooo 3位八进制数对应的字符 \\t 水平制表符 \\xhh 2位十六进制数对应的字符 \\v 垂直制表符 \\uhhhh 4位十六进制数表示的Unicode字符 字符串界定符前面加字母 r 或 R 表示原始字符串，其中的特殊字符不 进行转义，但字符串的最后一个字符不能是 \\。\n・原始字符串主要用于正则表达式、文件路径或者 URL 的场合。\n运算符和表达式 运算符 功能说明 + 算术加法，列表、元组、字符串合并与连接，正号 – 算术减法，集合差集，相反数 ***** 算术乘法，序列重复 / 真除法 // 求整商，但如果操作数中有实数的话，结果为实数形式的整数 % 求余数，字符串格式化 ** 幂运算 \u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=、==、!= （值）大小比较，集合的包含关系比较 or，and, not 逻辑或、逻辑与、逻辑非 in 成员测试 is 对象同一性测试，即测试是否为同一个对象或内存地址是否相同 、^、\u0026amp;、\u0026laquo;、\u0026raquo;、~ 位或、位异或、位与、左移位、右移位、位求反 \u0026amp;、|、^、- 集合交集、并集、对称差集，差集 加法 + 运算符除了用于算术加法外，还可用于列表、元组、字符串的连接，但不支持不同类型的对象之间相加或连接。\n乘法 运算符不仅可以用于 数值乘法 ，还可以用于列表、字符串、元组等类型__\n当列表、字符串或元组等类型变量与整数进行“ *” 运算时，表示 对内容进行重复 并返回重复后的新对象。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 2.0 * 3 #浮点数与整数相乘 6.0 \u0026gt;\u0026gt;\u0026gt; (3+4j) * 2 #复数与整数相乘 (6+8j) \u0026gt;\u0026gt;\u0026gt; (3+4j) * (3-4j) #复数与复数相乘 (25+0j) \u0026gt;\u0026gt;\u0026gt; \u0026#34;a\u0026#34; * 10 #字符串重复 \u0026#39;aaaaaaaaaa\u0026#39; 除法 Python 中的除法有两种， “ /” 和“ //” 分别表示除法和整除运算 。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; 3 / 5 0.6 \u0026gt;\u0026gt;\u0026gt; 3 // 5 0 \u0026gt;\u0026gt;\u0026gt; 3.0 / 5 0.6 \u0026gt;\u0026gt;\u0026gt; 3.0 // 5 0.0 \u0026gt;\u0026gt;\u0026gt; 13 // 10 1 \u0026gt;\u0026gt;\u0026gt; -13 // 10 -2 求余 % 运算符除去可用于字符串格式化之外，也可对整数和浮点数计算余数。\n・由于浮点数的精确度影响，计算结果可能略有误差。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; 3.1 % 2 1.1 \u0026gt;\u0026gt;\u0026gt; 6.3 % 2.1 2.0999999999999996 \u0026gt;\u0026gt;\u0026gt; 6 % 2 0 \u0026gt;\u0026gt;\u0026gt; -17 % 4 3 #余数与%右侧的运算数符号一致 \u0026gt;\u0026gt;\u0026gt; 17 % -4 -3 #(17-(-3))能被(-4)整除 \u0026gt;\u0026gt;\u0026gt; 5.7 % 4.8 0.9000000000000004 关系型运算符 关系运算符 可以连用 ，一般用于同类型对象之间值的大小比较，或者测试集合之间的包含关系\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; 1 \u0026lt; 3 \u0026lt; 5 #等价于1 \u0026lt; 3 and 3 \u0026lt; 5 True \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hello\u0026#39; \u0026gt; \u0026#39;world\u0026#39; #比较字符串大小 False \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hello\u0026#39; \u0026gt; 3 #字符串和数字不能比较 TypeError: unorderable types: str() \u0026gt; int() 成员测试运算符 成员测试运算符in用于 成员测试 ・即测试一个对象是否为另一个对象的元素。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 5 in range(1, 10, 1) #range()是用来生成指定范围数字的内置函数 True \u0026gt;\u0026gt;\u0026gt; \u0026#39;abc\u0026#39; in \u0026#39;abcdefg\u0026#39; #子字符串测试 True \u0026gt;\u0026gt;\u0026gt; for i in (3, 5, 7): #循环，成员遍历 print(i, end=\u0026#39;\\t\u0026#39;) 3\t5\t7\t位运算符 位运算符只能用于整数，其内部执行过程为：首先将整数转换为二进制数，然后右对齐，必要的时候左侧补 0，按位进行运算，最后再把计算结果转换为十进制数字返回\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 3 \u0026lt;\u0026lt; 2 #把3左移2位 12 \u0026gt;\u0026gt;\u0026gt; 3 \u0026amp; 7 #位与运算 3 \u0026gt;\u0026gt;\u0026gt; 3 | 8 #位或运算 11 \u0026gt;\u0026gt;\u0026gt; 3 ^ 5 #位异或运算 6 集合的交集、并集、对称差集 等运算借助于 位运算符 来实现\n而 差集 则使用 减号运算符 实现\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} | {3, 4, 5} #并集，自动去除重复元素 {1, 2, 3, 4, 5} \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} \u0026amp; {3, 4, 5} #交集 {3} \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} ^ {3, 4, 5} #对称差集 {1, 2, 4, 5} \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} - {3, 4, 5} #差集 {1, 2} and or and 和 or 具有 惰性求值 特点，只计算必须计算的表达式\n1 2 \u0026gt;\u0026gt;\u0026gt; 3\u0026gt;5 and a\u0026gt;3 False 注意，此时并没有定义变量 a，and 要两者都对返回对，而第一位的 3\u0026gt;5 已经判断是错的了，这里直接返回错，不会再对后面的 a\u0026gt;3 进行执行。\n1 2 \u0026gt;\u0026gt;\u0026gt; 3\u0026gt;5 or a\u0026gt;3 NameError: name \u0026#39;a\u0026#39; is not defined 3\u0026gt;5 的值为 False，所以需要计算后面表达式。\n1 2 \u0026gt;\u0026gt;\u0026gt; 3\u0026lt;5 or a\u0026gt;3 True 3\u0026lt;5 的值为 True，不需要计算后面表达式。这里是与 and 类似的惰性，or 只要两者中有一个是正确的，则返回正确，这里的 3\u0026lt;5 是对的，or 的代码将不会执行。\n这里比较让人迷惑的是下面这个程序：\n1 2 3 a = 1 a == 1 or (a+1) == 2 print(a) 这里返回的结果是 1，因为 or 后面的程序没有执行。\n1 2 \u0026gt;\u0026gt;\u0026gt; 3 and 5 5 and 是将最后一个计算的表达式的值作为整个表达式的值。\n1 2 3 and 5\u0026gt;2 True or 也类似\n1 2 \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt; 2 or 4 4 比较特殊的是 is not，它只能返回 true 或者 false\n1 2 \u0026gt;\u0026gt;\u0026gt; 3 is not 5 True Python 中 单个任何类型的对象或常数 属于合法表达式，使用 运算符连接的变量和常量以及函数调用的任意组合 也属于 合法的表达式 特殊说明 逗号并不是运算符，只是一个普通分隔符\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; x = 3, 5 \u0026gt;\u0026gt;\u0026gt; x (3, 5) \u0026gt;\u0026gt;\u0026gt; 3==3, 5 (True, 5) 逗号（,）在 Python 中用于创建元组（tuple）。当你使用逗号分隔多个值或表达式时，Python 会将这些值或表达式组合成一个元组。\nPython 不支持 ++ 和–运算符，虽然在形式上有时似乎可这样用，但实际上是另外的含义\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; i = 3 \u0026gt;\u0026gt;\u0026gt; ++i 3 #正正得正 \u0026gt;\u0026gt;\u0026gt; i++ #Python不支持++运算符，语法错误 SyntaxError: invalid syntax \u0026gt;\u0026gt;\u0026gt; --i #负负得正 3 \u0026gt;\u0026gt;\u0026gt; -(-i) #与--i等价 3 常用内置函数 内置函数不需要导入任何模块即可使用\n执行下面的命令可以列出所有内置函数\n1 dir (__builtins__) 函数 功能简要说明 abs(x) 返回数字 x 的绝对值或复数 x 的模 all(iterable) 如果对于可迭代对象中所有元素 x 都等价于 True，也就是对于所有元素 x 都有 bool (x) 等于 True，则返回 True。对于空的可迭代对象也返回 True any(iterable) 只要可迭代对象 iterable 中存在元素 x 使得 bool (x) 为 True，则返回 True。对于空的可迭代对象，返回 False ascii(obj) 把对象转换为 ASCII 码表示形式，必要的时候使用转义字符来表示特定的字符 bin(x) 把整数 x 转换为二进制串表示形式 bool(x) 返回与 x 等价的布尔值 True 或 False bytes(x) 生成字节串，或把指定对象 x 转换为字节串表示形式 callable(obj) 测试对象 obj 是否可调用。类和函数是可调用的，包含__call__() 方法的类的对象也是可调用的 compile() 用于把 Python 代码编译成可被 exec () 或 eval () 函数执行的代码对象 complex(real, [imag]) 返回复数 chr(x) 返回 Unicode 编码为 x 的字符 函数 功能简要说明 delattr(obj, name) 删除属性，等价于 del obj.name dir(obj) 返回指定对象或模块 obj 的成员列表，如果不带参数则返回当前作用域内所有标识符 divmod(x, y) 返回包含整商和余数的元组 ((x-x% y)/y, x% y) enumerate(iterable[, start]) 返回包含元素形式为 (0, iterable [0]), (1, iterable [1]), (2, iterable [2]), … 的迭代器对象 eval(s[, globals[, locals]]) 计算并返回字符串 s 中表达式的值 exec(x) 执行代码或代码对象 x exit() 退出当前解释器环境 filter(func, seq) 返回 filter 对象，其中包含序列 seq 中使得单参数函数 func 返回值为 True 的那些元素，如果函数 func 为 None 则返回包含 seq 中等价于 True 的元素的 filter 对象 float(x) 把整数或字符串 x 转换为浮点数并返回 frozenset([x])) 创建不可变的集合对象 getattr(obj, name[, default]) 获取对象中指定属性的值，等价于 obj.name，如果不存在指定属性则返回 default 的值，如果要访问的属性不存在并且没有指定 default 则抛出异常 函数 功能简要说明 globals() 返回包含当前作用域内全局变量及其值的字典 hasattr(obj, name) 测试对象 obj 是否具有名为 name 的成员 hash(x) 返回对象 x 的哈希值，如果 x 不可哈希则抛出异常 help(obj) 返回对象 obj 的帮助信息 hex(x) 把整数 x 转换为十六进制串 id(obj) 返回对象 obj 的标识（内存地址） input ([提示]) 显示提示，接收键盘输入的内容，返回字符串 int(x[, d]) 返回实数（float）、分数（Fraction）或高精度实数（Decimal）x 的整数部分，或把 d 进制的字符串 x 转换为十进制并返回，d 默认为十进制 isinstance(obj, class-or-type-or-tuple) 测试对象 obj 是否属于指定类型（如果有多个类型的话需要放到元组中）的实例 iter(…) 返回指定对象的可迭代对象 len(obj) 返回对象 obj 包含的元素个数，适用于列表、元组、集合、字典、字符串以及 range 对象和其他可迭代对象 函数 功能简要说明 list([x])、set([x])、tuple([x])、dict([x]) 把对象 x 转换为列表、集合、元组或字典并返回，或生成空列表、空集合、空元组、空字典 locals() 返回包含当前作用域内局部变量及其值的字典 map(func, *iterables) 返回包含若干函数值的 map 对象，函数 func 的参数分别来自于 iterables 指定的每个迭代对象， max(x)、 min(x) 返回可迭代对象 x 中的最大值、最小值，要求 x 中的所有元素之间可比较大小，允许指定排序规则和 x 为空时返回的默认值 next(iterator[, default]) 返回可迭代对象 x 中的下一个元素，允许指定迭代结束之后继续迭代时返回的默认值 oct(x) 把整数 x 转换为八进制串 open(name[, mode]) 以指定模式 mode 打开文件 name 并返回文件对象 ord(x) 返回 1 个字符 x 的 Unicode 编码 pow(x, y, z=None) 返回 x 的 y 次方，等价于 x ** y 或 (x ** y) % z print(value, …, sep=’ ‘, end=’\\n’, file = sys. stdout, flush=False) 基本输出函数 quit() 退出当前解释器环境 range([start,] end [, step] ) 返回 range 对象，其中包含左闭右开区间 [start,end) 内以 step 为步长的整数 函数 功能简要说明 repr(obj) 返回对象 obj 的规范化字符串表示形式，对于大多数对象有 eval (repr (obj))==obj reversed(seq) 返回 seq（可以是列表、元组、字符串、range 以及其他可迭代对象）中所有元素逆序后的迭代器对象 round (x [, 小数位数]) 对 x 进行四舍五入，若不指定小数位数，则返回整数 sorted(iterable, key=None, reverse=False) 返回排序后的列表，其中 iterable 表示要排序的序列或迭代对象，key 用来指定排序规则或依据，reverse 用来指定升序或降序。该函数不改变 iterable 内任何元素的顺序 str(obj) 把对象 obj 直接转换为字符串 sum(x, start=0) 返回序列 x 中所有元素之和，返回 start+sum (x) type(obj) 返回对象 obj 的类型 zip(seq1 [, seq2 […]]) 返回 zip 对象，其中元素为 (seq1 [i], seq2 [i], …) 形式的元组，最终结果中包含的元素个数取决于所有参数序列或可迭代对象中最短的那个 重点： 输入函数：input\\( \\)\n・可输入数字、字符串和其它任意类型对象， 返回结果都是字符串 。\n**输出函数：**print () 函数进行输出。\nbin ()、oct ()、hex () 用来将整数转换为二进制、八进制和十六进制形式，这三个函数都要求参数必须为整数。\nint() 用来把实数转换为整数，或把数字字符串按指定进制转换为十进制数。\neval\\(\u003c__ __字符串__ __\u003e\\) 函数能够 以 Python 表达式的方式解析并执行字符串 ，将返回结果输出\nrange() 语法格式为range \\(\\[start,\\] end \\[, step\\] \\) ， 返回具有 惰性求值特点的 __range对象 __ ，其中包含 左闭右开区间 [ start,end ) 内以step为步长的整数 。\nrange 对象，其中包含左闭右开区间 [start,end) 内以 step 为步长的整数。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; range(5) #start默认为0，step默认为1 range(0, 5) \u0026gt;\u0026gt;\u0026gt; list(_) [0, 1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; list(range(1, 10, 2)) #指定起始值和步长 [1, 3, 5, 7, 9] \u0026gt;\u0026gt;\u0026gt; list(range(9, 0, -2)) #步长为负数时，start应比end大 [9, 7, 5, 3, 1] ord() 和 chr () 是一对功能相反的函数： ord() 用来返回单个字符的序数或 Unicode 码，而 chr () 则用来返回某序数对应的字符\nstr () 则直接将其任意类型参数转换为字符串。\nmax ()、min ()、sum () 这三个内置函数分别用于计算列表、元组或其他可迭代对象中所有元素最大值、最小值以及所有元素之和\n内置函数 type () 和 isinstance () 可以判断数据类型。\nsorted () 对列表、元组、字典、集合或其他可迭代对象进行排序并返回新列表。\nzip()函数用来把多个可迭代对象中的元素压缩到一起，返回一个可迭代的 zip对象 ，其中每个元素都是包含原来的多个可迭代对象对应位置上元素的元组 ，如同拉拉链一样 。\nzip() 函数用于将可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。\n1 2 3 \u0026gt;\u0026gt;\u0026gt; x = zip(\u0026#39;abcd\u0026#39;, \u0026#39;1234\u0026#39;) \u0026gt;\u0026gt;\u0026gt; list(x) [(\u0026#39;a\u0026#39;, \u0026#39;1\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;2\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;3\u0026#39;), (\u0026#39;d\u0026#39;, \u0026#39;4\u0026#39;)] zip (*) 是解压\n内置函数filter()将一个单参数函数作用到一个序列上，返回该序列中使得该函数返回值为True的那些元素组成的 filter对象 ，如果指定函数为None，则返回序列中等价于True的元素。\n1 2 3 \u0026gt;\u0026gt;\u0026gt; seq = [\u0026#39;foo\u0026#39;, \u0026#39;x41\u0026#39;, \u0026#39;?!\u0026#39;, \u0026#39;***\u0026#39;] \u0026gt;\u0026gt;\u0026gt; list(filter(str.isalnum, seq)) [\u0026#39;foo\u0026#39;, \u0026#39;x41\u0026#39;] enumerate () 函数用来枚举可迭代对象中的元素，返回可迭代的 enumerate 对象，其中每个元素都是包含索引和值的元组。\nmap、filter、enumerate、zip等对象 不仅具有惰性求值的特点 ，还有另外一个特点： 访问过的元素不可再次访问 。\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; x = map(str, range(10)) \u0026gt;\u0026gt;\u0026gt; list(x) [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;] \u0026gt;\u0026gt;\u0026gt; list(x) [] \u0026gt;\u0026gt;\u0026gt; x = map(str, range(10)) \u0026gt;\u0026gt;\u0026gt; \u0026#39;2\u0026#39; in x True \u0026gt;\u0026gt;\u0026gt; \u0026#39;2\u0026#39; in x False 对象的删除 reversed () 对可迭代对象（生成器对象和具有惰性求值特性的 zip、map、filter、enumerate 等类似对象除外）进行翻转（首尾交换）并返回可迭代的 reversed 对象。\nPython 具有 自动内存管理功能 ， Python 解释器会跟踪所有的值，一旦发现某个值不再有任何变量指向，将会自动删除该值。\n显式释放自己申请的资源是程序员的好习惯之一，也是程序员素养的重要体现之一。\ndel 命令 ：显式删除对象并解除与值之间的指向关系。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; y = 3 \u0026gt;\u0026gt;\u0026gt; z = y \u0026gt;\u0026gt;\u0026gt; print(y) 3 \u0026gt;\u0026gt;\u0026gt; del y #删除对象 \u0026gt;\u0026gt;\u0026gt; print(y) NameError: name \u0026#39;y\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; print(z) 3 \u0026gt;\u0026gt;\u0026gt; del z \u0026gt;\u0026gt;\u0026gt; print(z) NameError: name \u0026#39;z\u0026#39; is not defined del 命令无法删除元组或字符串中的元素，只可以删除整个元组或字符串 因为这两者均属于不可变序列。\n模块导入 Python默认安装仅包含部分基本或核心模块，用户可安装大量的 扩展模块 ，pip是管理模块的重要工具。\n在Python启动时，仅加载了很少的一部分模块，在需要时由程序员显式地加载（可能需要先安装）其他模块。\n减小运行的压力，仅加载真正需要的模块和功能，且具有很强的可扩展性 。\n可以使用sys.modules.items()显示所有预加载模块的相关信息。\n1 2 3 4 5 6 7 8 9 10 import 模块名 from 模块名 import 对象名[ as 别名] from math import * 例如： \u0026gt;\u0026gt;\u0026gt; from math import sin \u0026gt;\u0026gt;\u0026gt; sin(3) 0.1411200080598672 \u0026gt;\u0026gt;\u0026gt; from math import sin as f \u0026gt;\u0026gt;\u0026gt; f(3) 0.141120008059867 重新导入一个模块：在 3.x 中，需要使用 imp 模块的 reload 函数 导入模块时的文件搜索顺序\n当前文件夹 sys.path 变量指定的文件夹 可以使用 sys 模块的 path 变量查看 python 导入模块时搜索模块的路径，也可以向其中 append 自定义的目录以扩展搜索路径。 优先导入 pyc 文件 如果相应的 pyc 文件与 py 文件时间不相符，则导入 py文件并重新编译该模块。 如需导入多个模块，建议顺序如下：\n标准库 成熟的第三方扩展库 自己开发的库 Python文件 py ： Python 源文件，由 Python 解释器负责解释执行。 pyw ： Python 源文件，常用于图形界面程序文件。 pyc ： Python 字节码文件，无法使用文本编辑器直接查看其内容，可用 于隐藏 Python 源代码和提高运行速度。 对于Python模块，第一次被导入时将被编译成字节码的形式，并在以后再次导入时优先使用“.pyc”文件，以提高模块的加载和运行速度。 对于非模块文件，直接执行时并不生成“.pyc”文件，但可使用py_compile模块的compile()函数进行编译以提高加载和运行速度。 Python还提供了compileall模块，其中包含compile_dir()、compile_file()和compile_path()等方法，用来支持批量Python源程序文件的编译。 pyd ： 一般是由其他语言编写并编译的二进制文件，常用于实现某些软 件工具的 Python 编程接口插件或 Python 动态链接库。 主要参考课堂ppt总结，仅供参考，可能有误\n","date":"2024-11-02T00:00:00Z","image":"http://localhost:1313/p/python%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A11/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:1313/p/python%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A11/","title":"Python语言与系统设计(1)"},{"content":"动态规划（Dynamic Programming） 动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。\n动态规划的核心思想就是穷举求最值，列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」。\n首先，明确「状态」-\u0026gt; 明确「选择」 -\u0026gt; 定义 dp 数组/函数的含义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 自顶向下递归的动态规划 def dp(状态1, 状态2, ...): for 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...)) return result # 自底向上迭代的动态规划 # 初始化 base case dp[0][0][...] = base case # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 子矩阵的最大和问题 以LeetCode面试题 17.24. 最大子矩阵举例\n给定一个正整数和负整数组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。返回一个子矩阵左上角的行号和列号，右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。\n我们将二维转化为一维，对于矩阵的每一列，我们将其加在一起，成为了一维上的一个数，二维矩阵的和转化为了一维数组的和，如下图。\n转化为求最大子序列和之后，假设给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。我们该如何解决呢？\n1、状态定义：dp[i]为以nums[i]结尾的最大子序和。\n2、状态转移方程：对于nums[i]有两种情况:一种是和前一个位置的子序列连着。$dp[i]=dp[i-1]+nums[i]$。第二种是以自己独立门户，从自己开始$dp[i]=nums[i]$。取其中最大值,可得状态转移方程为$dp[i]=max( dp[i-1] + nums[i] , nums[i] )$。\n3、basecase:$dp[0]=nums[0]$。\n观察发现，dp[i]只与dp[i-1]和nums[i]有关，所有我们可以将空间复杂度降到O(1) 同时对于$dp[i]=max(dp[i-1]+nums[i],nums[i])$,两种情况都加了nums[i]，只是前面多加了dp[i-1]，所有很容易推出，当dp[i-1]\u0026lt;0时，后者大，反之前者大\n问题迎刃而解，题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /** * @author: Juncker chan * @date: 2024.10.25 * @details: 子矩阵的最大和问题 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int getMaxMatrixSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int maxsum = INT_MIN; int dp_i; int maxRow = matrix.size(); int maxCol = matrix[0].size(); vector\u0026lt;int\u0026gt; b(maxCol, 0); //记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维 int row,col;//临时记录左上角行列坐标 vector\u0026lt;int\u0026gt; pos(4);//记录左上角和右下角最终坐标 for (int i = 0; i \u0026lt; maxRow; i++) { //以i为上边，从上而下扫描 b.assign(maxCol, 0); //每次更换子矩形上边，就要清空b，重新计算每列的和 //子矩阵的下边往下移动变长，从i到maxROw-1， for (int j = i; j \u0026lt; maxRow; j++) { //已转换为求连续最大子序列和，一下就相当于求一次最大子序列和 dp_i = 0; for (int k = 0; k \u0026lt; maxCol; k++) { b[k] += matrix[j][k]; //我们只是不断增加其高，也就是下移矩阵下边，所有这个矩阵每列的和只需要加上新加的哪一行的元素 if (dp_i \u0026gt; 0) { dp_i += b[k]; } else { dp_i = b[k]; //新起一个点时保存这个点为临时左上角坐标 row=i; col=k; } if(dp_i\u0026gt;maxsum) { maxsum=dp_i; //更新最大子矩阵后更新最终左上角和右下角坐标 pos[0]=row; pos[1]=col; pos[2]=j; pos[3]=k; } } } } cout\u0026lt;\u0026lt;pos[0]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos[1]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos[2]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos[3]\u0026lt;\u0026lt;endl; return maxsum; } }; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; matrix = { {0, -2, -7, 0}, {9, 2, -6, 2}, {-4, 1, -4, 1}, {-1, 8, 0, -2} }; Solution sol; int maxSum = sol.getMaxMatrixSum(matrix); cout \u0026lt;\u0026lt; \u0026#34;子矩阵中和的最大值是: \u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return 0; } 回溯算法（DFS） 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：\n1 2 3 4 5 6 7 8 9 10 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。\nN皇后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 /** * @author: Juncker chan * @date: 2024.10.24 * @details: n皇后问题 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; bool isValid(vector\u0026lt;string\u0026gt; \u0026amp;board, int row, int col) { int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i \u0026lt;= row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) { return false; } } // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) { return false; } } // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) { return false; } } return true; } // 路径：board 中小于 row 的那些行都已经成功放置了皇后 // 选择列表：第 row 行的所有列都是放置皇后的选择 // 结束条件：row 超过 board 的最后一行 void backTrack(vector\u0026lt;string\u0026gt; \u0026amp;board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return; } int max_col = board[row].size(); for (int col = 0; col \u0026lt; max_col; col++) { if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = \u0026#39;Q\u0026#39;; backTrack(board, row + 1); board[row][col] = \u0026#39;.\u0026#39;; // 撤销选择 } } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { vector\u0026lt;string\u0026gt; board(n, string(n, \u0026#39;.\u0026#39;)); backTrack(board, 0); return res; } }; int main() { Solution solution; int n; cout \u0026lt;\u0026lt; \u0026#34;输入N: \u0026#34;; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; results = solution.solveNQueens(n); cout \u0026lt;\u0026lt; \u0026#34;可能解如下:\u0026#34; \u0026lt;\u0026lt; endl; for (vector\u0026lt;string\u0026gt; \u0026amp;arrangement : results) { for (string \u0026amp;row : arrangement) { cout \u0026lt;\u0026lt; row \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } return 0; } 动态规划的三个需要明确的点就是「状态」「选择」和「base case」，其实就对应着走过的「路径」，当前的「选择列表」和「结束条件」。\n广搜算法（BFS） 单向BFS BFS问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离。\n这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少，如果加上这个迷宫带「传送门」可以瞬间传送的条件呢？比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？\n本质上看这些问题都没有区别，就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质。\n算法框架如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int BFS(Node start, Node target) { queue\u0026lt;Node\u0026gt; q; set\u0026lt;Node\u0026gt; visited; q.push(start); visited.insert(start); while (!q.empty()) { int sz = q.size(); for (int i = 0; i \u0026lt; sz; i++) { Node cur = q.front(); q.pop(); if (cur == target) return step; for (Node x : cur.adj()) { if (visited.count(x) == 0) { q.push(x); visited.insert(x); } } } } // 如果走到这里，说明在图中没有找到目标节点 } BFS 的核心数据结构：cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。\n双向BFS 传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。不过双向 BFS 也有局限，因为你必须知道终点在哪里，如下图：\n无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的，只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点。\n解开密码锁的最少次数 LeetCode752.打开转盘锁\n分析题目，首先要思考设计一个算法，穷举所有可能的密码组合，其次才是考虑deadends 和 target 的限制**\n总共有 4 个位置，每个位置可以向上转，也可以向下转，共8种可能。比如说从 \u0026quot;0000\u0026quot; 开始，转一次，可以穷举出 \u0026quot;1000\u0026quot;, \u0026quot;9000\u0026quot;, \u0026quot;0100\u0026quot;, \u0026quot;0900\u0026quot;... 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能\u0026hellip;\n这可以抽象成一幅图，每个节点有 8 个相邻的节点，又让你求最短距离，成功转化为BFS问题。\n限制条件呢？只需要两个以哈希表为底层实现的无序集合记录visited和deads就可以了。\n题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public: int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { // 记录需要跳过的死亡密码 unordered_set\u0026lt;string\u0026gt; deads(deadends.begin(), deadends.end()); // 记录已经穷举过的密码，防止走回头路 unordered_set\u0026lt;string\u0026gt; visited; queue\u0026lt;string\u0026gt; q; // 从起点开始启动广度优先搜索 int step = 0; q.push(\u0026#34;0000\u0026#34;); visited.insert(\u0026#34;0000\u0026#34;); while (!q.empty()) { int sz = q.size(); // 将当前队列中的所有节点向周围扩散 for (int i = 0; i \u0026lt; sz; i++) { string cur = q.front(); q.pop(); // 判断是否到达终点 if (deads.count(cur)) continue; if (cur == target) return step; // 将一个节点的未遍历相邻节点加入队列 for (int j = 0; j \u0026lt; 4; j++) { string up = plusOne(cur, j); if (!visited.count(up)) { q.push(up); visited.insert(up); } string down = minusOne(cur, j); if (!visited.count(down)) { q.push(down); visited.insert(down); } } } // 在这里增加步数 step++; } // 如果穷举完都没找到目标密码，那就是找不到了 return -1; } // 将 s[j] 向上拨动一次 string plusOne(string s, int j) { s[j] = s[j] == \u0026#39;9\u0026#39; ? \u0026#39;0\u0026#39; : s[j] + 1; return s; } // 将 s[i] 向下拨动一次 string minusOne(string s, int j) { s[j] = s[j] == \u0026#39;0\u0026#39; ? \u0026#39;9\u0026#39; : s[j] - 1; return s; } }; 二分查找（BinarySearch） 最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。以下为最基础框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int binarySearch(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size() - 1; while (...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u0026lt; target) { left = ... } else if (nums[mid] \u0026gt; target) { right = ... } } } 小细节：$left + (right - left) / 2$ 就和 $(left + right) / 2$ 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。\n最基本的二分查找算法：\n1 2 3 4 5 6 7 因为我们初始化 right = nums.length - 1 所以决定了我们的「搜索区间」是 [left, right] 所以决定了 while (left \u0026lt;= right) 同时也决定了 left = mid+1 和 right = mid-1 因为我们只需找到一个 target 的索引即可 所以当 nums[mid] == target 时可以立即返回 寻找左侧边界的二分查找：\n1 2 3 4 5 6 7 8 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧右侧边界以锁定左侧边界 寻找右侧边界的二分查找：\n1 2 3 4 5 6 7 8 9 10 11 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最右侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧左侧边界以锁定右侧边界 又因为收紧左侧边界时必须 left = mid + 1 所以最后无论返回 left 还是 right，必须减一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 int binary_search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size()-1; while(left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回 return mid; } } // 直接返回 return -1; } int left_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size()-1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定左侧边界 right = mid - 1; } } // 判断 target 是否存在于 nums 中 if (left \u0026lt; 0 || left \u0026gt;= nums.size()) { return -1; } // 判断一下 nums[left] 是不是 target return nums[left] == target ? left : -1; } int right_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size()-1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定右侧边界 left = mid + 1; } } // 由于 while 的结束条件是 right == left - 1，且现在在求右边界 // 所以用 right 替代 left - 1 更好记 if (right \u0026lt; 0 || right \u0026gt;= nums.size()) { return -1; } return nums[right] == target ? right : -1; } 模拟与密码类问题 Morse Mismatches Problem UVA508：Morse Mismatches Problem\n密码题中的模拟题，题目很长其实不算难，使用两个以哈希表为底层的字典存储映射即可，注释很详细。主要流程就是逐个匹配单词计算最小差异，根据最小差异的不同if_else出各种结果就行了。\n题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 /** * @author: Juncker chan * @date: 2024.10.28 * @details: Morse Mismatches Problem **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; map\u0026lt;char, string\u0026gt; morse_map; // 字符到摩尔斯电码的映射 map\u0026lt;string, string\u0026gt; word_dict; // 单词及其摩尔斯电码表示的字典 // 计算两个摩尔斯电码字符串 morse_input 和 morse_code 之间的差异 // 如果它们完全相同，返回0；如果 morse_input 是 morse_code 的前缀，返回长度差异；否则返回 INT_MAX int calculate_diff(string\u0026amp; morse_input, string\u0026amp; morse_code) { if (morse_input == morse_code) return 0; // 完全匹配 if (morse_input.size() \u0026gt; morse_code.size()) return INT_MAX; // 如果 `morse_input` 更长，不可能是前缀 if (morse_input == morse_code.substr(0, morse_input.size())) return morse_code.size() - morse_input.size(); // 前缀匹配 return INT_MAX; // 没有匹配 } // 找到与给定摩尔斯电码 `morse_input` 最接近的匹配单词 string find_best_match(string\u0026amp; morse_input) { string best_match = \u0026#34;\u0026#34;; // 存储最接近的匹配单词 int min_diff = INT_MAX; // 最小差异初始化为 \u0026#34;无穷大\u0026#34; for (map\u0026lt;string, string\u0026gt;::iterator it = word_dict.begin(); it != word_dict.end(); ++it) { int diff = calculate_diff(morse_input, it-\u0026gt;second); // 计算当前摩尔斯电码的差异 // 如果已经发生两次完全匹配，返回 \u0026#34;!\u0026#34; if (diff == 0 \u0026amp;\u0026amp; min_diff == 0 \u0026amp;\u0026amp; best_match.back() != \u0026#39;!\u0026#39;) { best_match += \u0026#34;!\u0026#34;; return best_match; } // 如果找到更接近或相同的匹配，更新 best_match if (diff \u0026lt;= min_diff) best_match = it-\u0026gt;first; min_diff = min(diff, min_diff); // 更新最小差异 } if (min_diff \u0026gt; 0) best_match += \u0026#34;?\u0026#34;; // 如果不是完全匹配，追加 \u0026#34;?\u0026#34; return best_match; } int main() { string morse_code, character; vector\u0026lt;string\u0026gt; results; // 存储结果 // 读取字符到摩尔斯电码的映射 while (cin \u0026gt;\u0026gt; character \u0026amp;\u0026amp; character != \u0026#34;*\u0026#34;) { cin \u0026gt;\u0026gt; morse_code; morse_map[character[0]] = morse_code; // 存储每个字符的摩尔斯电码 } // 构建单词及其摩尔斯电码表示的字典 while (cin \u0026gt;\u0026gt; morse_code \u0026amp;\u0026amp; morse_code != \u0026#34;*\u0026#34;) { for (char ch : morse_code) word_dict[morse_code] += morse_map[ch]; // 将单词中的每个字符转换为摩尔斯电码 } // 读取摩尔斯电码输入并处理，存储结果 while (cin \u0026gt;\u0026gt; morse_code \u0026amp;\u0026amp; morse_code != \u0026#34;*\u0026#34;) { results.push_back(find_best_match(morse_code)); // 存储每个结果 } // 在输入完全读取后打印所有结果 for (string\u0026amp; result : results) { cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } return 0; } 总结与时空复杂度 BFS与DFS DFS 也可以找最短路径，但是时间复杂度相对BFS高很多。DFS 实际上是靠递归的堆栈记录走过的路径，你要找到最短路径，肯定得把二叉树中所有树杈都探索完才能对比出最短的路径有多长，而 BFS 借助队列做到一次一步「齐头并进」，是可以在不遍历完整棵树的条件下找到最短距离的。\nBFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。\n以处理二叉树问题为例，假设给你的这个二叉树是满二叉树，节点数为 $N$，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是$ O(logN)$。\n但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 $N/2$，用 Big O 表示的话也就是 $O(N)$。\n由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。\n仅供参考，可能有误\n","date":"2024-10-26T00:00:00Z","image":"http://localhost:1313/p/%E7%AE%97%E6%B3%95%E6%B8%A9%E6%95%85%E7%AC%94%E8%AE%B0/stl_hu16550555255445278498.png","permalink":"http://localhost:1313/p/%E7%AE%97%E6%B3%95%E6%B8%A9%E6%95%85%E7%AC%94%E8%AE%B0/","title":"算法温故笔记"},{"content":"相关资料链接: 九月大人的博客\nyikai-blog\nrobocup2D官网\nRoboCup 2D 常用函数简明含义 函数名称 功能说明 dribble(angle, speed) 控制球员带球移动。angle表示带球方向，speed表示带球速度（如DRIBBLE_FAST、DRIBBLE_SLOW等）。 kickTo(targetPosition, speed) 球员向目标位置（targetPosition）踢球，speed指定踢球的速度。 leadingPass(teammate, power) 向最近的队友传球，teammate是要传球的目标队友，power表示传球力度。 getNrInSetInCircle(set, circle) 计算指定半径的圆圈内（circle）特定对象集合（set，如对手或队友）的数量。例如用来判断7米范围内是否有对手球员。 getClosestInSetTo(set, position) 获取距离指定位置（position）最近的特定对象集合（set）中的对象，例如找到离当前球员最近的队友或对手。 isOpponentAtAngle(angleMin, angleMax) 判断在给定的角度范围内是否有对方球员。常用于决定是否在某个方向射门或传球。 getGlobalPosition(object) 获取场上某个对象（球员、对手、球等）的全局坐标位置（X, Y坐标）。 getBallPos() 获取球的当前位置坐标。 moveToPos(position, speed) 移动球员到指定的position（坐标位置），并以speed指定的速度执行移动。 isBallKickable() 判断当前球是否在球员的控制范围内（即球员是否可以踢球）。 kickBallCloseToBody(angle) 控制球员以指定的angle（角度）把球围绕身体转动。 intercept(timeout) 尝试在指定时间内抢断球（通常用在防守场景）。 turnNeckToObject(object) 让球员将头（视角）转向指定的object（如球或对方球员），通常用于跟踪球的位置。 getPlayerNumber() 返回当前球员的编号（如2号、10号等），不同球员编号对应不同策略。例如10号通常为前锋，会有更多进攻行为。 getTeammateNumber() 获取指定队友的编号，用于传球决策时判断目标球员是否为特定队友。 getPosOpponentGoal() 获取对方球门的位置，通常用于判断进攻方向或射门目标。 shootToGoalex(object) 指定球员向对方球门射门，通常由接近球门的前锋使用。 getBallSpeedMax() 获取当前球员能踢球的最大速度。 getDirection() 计算某个目标相对于当前球员的方向（角度），例如计算球门方向或队友位置的方向。 isInTheirPenaltyArea(position) 判断某个位置是否位于对方禁区内，常用于决定射门或传球策略。 putCommandInQueue(command) 将指令（command）放入执行队列，确保该操作能够在下一次循环中执行。 Circle(center, radius) 创建一个以center为中心，radius为半径的圆，用于计算范围内的球员数量或球的距离。 Line::makeLineFromPositionAndAngle(position, angle) 根据给定的position和angle生成一条直线，通常用于计算球的运动轨迹或球员的移动路径。 isOffsideUs() 判断是否处于本方越位模式，适用于进攻方的越位规则判断。 isCornerKickUs() 判断是否处于本方角球模式。 isOwnSideOpponentMost() 判断己方半场的对手人数是否多于对方半场的对手人数。常用于判断防守或进攻策略。 getSecondClosestInSetTo(set, object) 获取距离指定object最近的第二个对象（通常是球员），用于策略决策，例如传球或防守。 仅供参考，可能有误\n","date":"2024-10-19T00:00:00Z","image":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","title":"机器人技术(1): 常用函数"},{"content":"相关资料链接: 决策树-维基百科\n深入浅出理解决策树算法（一）-核心思想\n深入浅出理解决策树算法（二）-ID3算法与C4.5算法\n深刻理解决策树-动手计算ID3算法\n机器学习——使用ID3算法从原理到实际举例理解决策树\n基于信息论的三种决策树算法 划分数据集的最大原则是：使无序的数据变的有序。 如果一个训练数据中有20个特征，那么选取哪个做划分依据？这就必须采用量化的方法来判断，量化划分方法有多重，其中一项就是“信息论度量信息分类”。基于信息论的决策树算法有ID3 、C4.5和 CART等算法，其中C4.5和CART两种算法从ID3算法中衍生而来。此处仅记录ID3算法。\nID3算法（Iterative Dichotomiser 3 迭代二叉树3代）是一个由Ross Quinlan发明的用于决策树的算法。\n这个算法是建立在奥卡姆剃刀的基础上：越是小型的决策树越优于大的决策树（简单理论）。尽管如此，该算法也不是总是生成最小的树形结构。而是一个启发式算法。\n这个ID3算法可以归纳为以下几点：\n使用所有没有使用的属性并计算与之相关的样本熵值 选取其中熵值最小的属性 生成包含该属性的节点 理论公式 某个分类的信息 $$ l(x_i) = -\\log_2 P(x_i) $$这里\\(p(x_i)\\)是选择该分类的概率。\n熵 在信息论与概率统计中，熵是表示随机变量不确定性的度量。熵定义为信息的期望值，因此熵的计算方法如下：\n$$ H = -\\sum_{i=1}^{n} P(x_i) \\log_2 P(x_i) $$ 这里 \\( n \\) 是分类的数目。\n经验熵 熵中的概率由数据估计（特别是最大似然估计）得到。在 \\( |D| \\) 样本容量（样本个数）下，设有 \\( K \\) 个类 \\( C_k \\), \\( k = 1,2,3,…,K \\)，\\( |C_k| \\) 为属于类 \\( C_k \\) 的样本个数，得到其表达式如下：\n$$ H(D) = -\\sum_{k=1}^{K} \\frac{|C_k|}{|D|} \\log_2 \\frac{|C_k|}{|D|} $$条件熵 在已知随机变量 \\( X \\) 的条件下随机变量 \\( Y \\) 的不确定性，即在随机变量 \\( X \\) 给定的条件下随机变量 \\( Y \\) 的条件熵 \\( H(Y|X) \\)，定义为 \\( X \\) 给定条件下 \\( Y \\) 的条件概率分布的熵对 \\( X \\) 的数学期望：\n$$ H(Y|X) = \\sum_{i=1}^{n} p_i H(Y|X=x_i) $$信息增益 集合 \\( D \\) 的经验熵 \\( H(D) \\) 与特征 \\( A \\) 给定条件下 \\( D \\) 的经验条件熵 \\( H(D|A) \\) 之差：\n$$ g(D,A) = H(D) - H(D|A) $$实战(第四次作业题) 序号 是否有其他选择 饿否 价格 餐馆类型 餐馆顾客人数 等待时间 (分钟) 决策：是否等待 1 是 是 $$$ 法式 有人 0-10 是 2 是 是 $ 中餐 客满 30-60 否 3 否 否 $ 快餐 有人 0-10 是 4 是 是 $ 中餐 客满 10-30 是 5 是 否 $$$ 法式 客满 \u0026gt;60 否 6 否 是 $$ 意大利式 有人 0-10 是 7 否 否 $ 快餐 无人 0-10 否 8 否 是 $$ 中餐 有人 0-10 是 9 否 否 $ 快餐 客满 \u0026gt;60 否 10 是 是 $$$ 意大利式 客满 10-30 否 11 是 否 $ 中餐 无人 0-10 否 12 否 是 $ 快餐 客满 30-60 是 算法步骤 计算数据集中决策属性“是否等待”的熵（Entropy）。 对每个特征计算其信息增益（Information Gain），选择信息增益最大的特征作为根节点。 对选中的特征划分子数据集，递归地对每个子数据集继续构造子树，直到每个子集中的样本都属于同一类别，或者没有更多特征可以用来分裂。 生成最终的决策树。 第一层计算实例 我们首先要计算整体数据集的熵，然后逐个计算每个特征的信息增益：\n整体数据集经验熵计算： 有6个样例决策为是，6个样例决策为否。\n标签 YES NO 汇总 样本数 6 6 12 概率值 6/12 6/12 12/12 $$ Entropy(S) = -\\left(\\frac{6}{12}\\log_2\\frac{6}{12}\\right) - \\left(\\frac{6}{12}\\log_2\\frac{6}{12}\\right) = 1 $$经验熵计算完了，现在，我们要计算每个特征的条件熵，以及对应的信息增益，并对信息增益进行排序，选择增益最大的特征作为第一个分裂点进行分裂。\n1.特征“是否有其他选择”的信息增益： 这个特征包含两个属性取值，是和否\n是否有其他选择 YES NO 样本数 是 2 4 6 否 4 2 6 $$ Entropy(S_{是}) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$$$ Entropy(S_{否}) = -\\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.780 $$信息增益计算： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{6}{12} \\times 0.918 + \\frac{6}{12} \\times 0.780\\right) ≈ 0.151 $$ “是否有其他选择”这个特征的信息增益计算结束了，现在，我们需要对其他特征应用相同的计算方法，计算出剩余每个特征的信息增益。\n2.特征“饿否”的信息增益： 这个特征包含两个属性取值，是和否\n饿否 YES NO 样本数 是 5 2 7 否 1 4 5 $$ Entropy(S_{是}) = -\\left(\\frac{5}{7}\\log_2\\frac{5}{7}\\right) - \\left(\\frac{2}{7}\\log_2\\frac{2}{7}\\right) ≈ 0.863 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{5}\\log_2\\frac{1}{5}\\right) - \\left(\\frac{4}{5}\\log_2\\frac{4}{5}\\right) ≈ 0.722 $$信息增益计算： $$ Gain(Decision, 饿否) = 1 - \\left(\\frac{7}{12} \\times 0.863 + \\frac{5}{12} \\times 0.722\\right) ≈ 0.1958 $$ 3.特征\u0026quot;价格”的信息增益： 这个特征包含三个属性取值，$和$$和$$$\n价格 YES NO 样本数 $ 3 4 7 $$ 2 0 2 $$$ 1 2 3 $$ Entropy(S_{\\$}) = -\\left(\\frac{3}{7}\\log_2\\frac{3}{7}\\right) - \\left(\\frac{4}{7}\\log_2\\frac{4}{7}\\right) ≈ 0.985 $$$$ Entropy(S_{\\$$}) = -\\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) - \\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) = 0 $$\n如果类的实例数为0，而实例总数为n，则需要计算*-(0/n) .log2(0/n)，*定义0*log2*0=0，熵只依赖于X的分布，与X的取值无关。这里，log(0）将等于-∞, 我们不能计算0次∞。这是决策树应用程序中经常出现的一种特殊情况。 $$ Entropy(S_{\\$$$}) = -\\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) ≈ 0.918 $$ 信息增益计算： $$ Gain(Decision, 价格) = 1 - \\left(\\frac{7}{12} \\times 0.985 + \\frac{2}{12} \\times 0+\\frac{3}{12} \\times 0.918\\right) ≈ 0.1959 $$\n4.特征“餐馆类型”的信息增益： 这个特征包含四个属性取值，法式和中餐和快餐和意大利式。\n餐馆类型 YES NO 样本数 法式 1 1 2 中餐 1 3 4 快餐 2 2 4 意大利式 1 1 2 $$ Entropy(S_{法}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{中}) = -\\left(\\frac{1}{4}\\log_2\\frac{1}{4}\\right) - \\left(\\frac{3}{4}\\log_2\\frac{3}{4}\\right) ≈ 0.811 $$$$ Entropy(S_{快}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{意}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$信息增益计算： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{2}{12} \\times 1 + \\frac{4}{12} \\times 0.811 + \\frac{4}{12} \\times 1+ \\frac{2}{12} \\times 1\\right) ≈ 0.063 $$ 5.特征“餐馆顾客人数”的信息增益： 这个特征包含三个属性取值，无人和有人和客满。\n餐馆顾客人数 YES NO 样本数 无人 0 2 2 有人 4 0 4 客满 2 4 6 $$ Entropy(S_{无人}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$$$ Entropy(S_{有人}) = -\\left(\\frac{4}{4}\\log_2\\frac{4}{4}\\right) - \\left(\\frac{0}{4}\\log_2\\frac{0}{4}\\right) = 0 $$$$ Entropy(S_{客满}) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$信息增益计算： $$ Gain(Decision, 餐馆顾客人数) = 1 - \\left(\\frac{2}{12} \\times 0 + \\frac{4}{12} \\times 0+\\frac{6}{12} \\times 0.918\\right) ≈ 0.541 $$ 6.特征“等待时间(分钟)”的信息增益： 这个特征包含四个属性取值，0-10和10-30和30-60和\u0026gt;60。\n等待时间(分钟) YES NO 样本数 0-10 4 2 6 10-30 1 1 2 30-60 1 1 2 \u0026gt;60 0 2 2 $$ Entropy(S_{0-10}) = -\\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) - \\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) ≈ 0.918 $$$$ Entropy(S_{10-30}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{\u003e60}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$信息增益计算： $$ Gain(Decision, 等待时间) = 1 - \\left(\\frac{6}{12} \\times 0.918 + \\frac{2}{12} \\times 1 + \\frac{2}{12} \\times 1+ \\frac{2}{12} \\times 0\\right) ≈ 0.2077 $$ 第二层分裂决策 Feature Gain 排名 餐馆顾客人数 0.541 1 等待时间(分钟) 0.2077 2 价格 0.1959 3 饿否 0.1958 4 是否有其他选择 0.1951 5 餐馆类型 0.063 6 第一层分裂的特征确定后就要根据分裂的结果，进行第二层的分裂，同第一层，也是需要计算每个子集的经验熵 + 条件熵。\n数据集第一步被餐馆顾客人数这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。\n通过对所有特征的信息增益进行比较，选择信息增益最高的特征作为决策节点，继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-无人(有人) 分支 在无人这个分支上，标签全部是no，也就是已经彻底的完成了分裂了，这个就可以作为叶子节点，无需继续分裂。在有人这个分支上，标签全部是yes，这个也可以作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 客满 是 否 $$$ 法式 \u0026gt;60 否 客满 否 否 $ 快餐 \u0026gt;60 否 客满 是 是 $$$ 意大利式 10-30 否 客满 否 是 $ 快餐 30-60 是 该子集中有 2 个样例决策为是，4 个样例决策为否。\n1.整体数据集经验熵计算： $$ Entropy(S) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$现在我们对剩下的特征重新计算信息增益。\n1. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 3 4 否 1 1 2 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{4}\\log_2\\frac{1}{4}\\right) - \\left(\\frac{3}{4}\\log_2\\frac{3}{4}\\right) ≈ 0.811 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$信息增益： $$ Gain(Decision, 是否有其他选择) = 0.918 - \\left(\\frac{4}{6} \\times 0.811 + \\frac{2}{6} \\times 1\\right) ≈ 0.0207 $$2. 特征“饿否”的信息增益 饿否 YES NO 样本数 是 2 2 4 否 0 2 2 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{否}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$信息增益： $$ Gain(Decision, 饿否) = 0.918 - \\left(\\frac{4}{6} \\times 1 + \\frac{2}{6} \\times 0\\right) ≈ 0.2513 $$3. 特征“价格”的信息增益 价格 YES NO 样本数 $ 2 2 4 $$$ 0 2 2 计算条件熵： $$ Entropy(S_{\\$}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{\\$$$}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$\n信息增益： $$ Gain(Decision, 价格) = 0.918 - \\left(\\frac{4}{6} \\times 1 + \\frac{2}{6} \\times 0\\right) ≈ 0.2513 $$4. 特征“餐馆类型”的信息增益 餐馆类型 YES NO 样本数 中餐 1 1 2 快餐 1 1 2 法式 0 1 1 意大利式 0 1 1 计算条件熵： $$ Entropy(S_{中餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{快餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{法式})=Entropy(S_{意大利式})=0 $$信息增益： $$ Gain(Decision, 餐馆类型) = 0.918 - \\left(\\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 1 + \\frac{1}{6} \\times 0 + \\frac{1}{6} \\times 0\\right)≈ 0.2511 $$5. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 1 2 30-60 1 1 2 \u0026gt;60 0 2 2 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{\u003e60}) = 0 $$信息增益： $$ Gain(Decision, 等待时间) = 0.918 - \\left(\\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 0 \\right) ≈ 0.2513 $$ 第三层分裂决策 Feature Gain 排名 饿否 0.2513 1 等待时间(分钟) 0.2513 1 价格 0.2513 1 餐馆类型 0.2511 4 是否有其他选择 0.0207 5 第三层也是需要计算每个子集的经验熵 + 条件熵。此时前三的信息增益一致，选任意一个即可。\n数据集第一步被餐馆饿否这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。\n通过对所有特征的信息增益进行比较，选择信息增益最高的特征作为决策节点，继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-否 分支 在否这个分支上，标签全部是no，也就是已经彻底的完成了分裂了，非常纯，这个就可以作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满|饿否-是 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 客满 是 是 $$$ 意大利式 10-30 否 客满 否 是 $ 快餐 30-60 是 此子集中有 2 个样例决策为是，2 个样例决策为否。\n1.整体数据集经验熵计算： 该子集的经验熵为： $$ Entropy(S) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$ 现在我们对剩余特征重新计算信息增益。\n2. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 2 3 否 1 0 1 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) ≈ 0.918 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{1}\\log_2\\frac{1}{1}\\right) = 0 $$信息增益： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{3}{4} \\times 0.918 + \\frac{1}{4} \\times 0\\right) ≈ 0.311 $$2. 特征“价格”的信息增益 价格 YES NO 样本数 $ 2 1 3 $$$ 0 1 1 计算条件熵： $$ Entropy(S_{\\$}) = -\\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) - \\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) ≈ 0.918 $$$$ Entropy(S_{\\$$$}) = 0 $$\n信息增益： $$ Gain(Decision, 价格) = 1 - \\left(\\frac{3}{4} \\times 0.918 + \\frac{1}{4} \\times 0\\right) ≈ 0.311 $$3. 特征“餐馆类型”的信息增益 餐馆类型 YES NO 样本数 中餐 1 1 2 快餐 1 0 1 意大利式 0 1 1 计算条件熵： $$ Entropy(S_{中餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{快餐}) = Entropy(S_{意大利式}) = 0 $$信息增益： $$ Gain(Decision, 餐馆类型) = 1 - \\left(\\frac{2}{4} \\times 1 + \\frac{1}{4} \\times 0 + \\frac{1}{4} \\times 0\\right) = 0.5 $$4. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 1 2 30-60 1 1 2 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 信息增益： $$ Gain(Decision, 等待时间) = 1 - 1 = 0 $$ 第四层分裂决策 Feature Gain 排名 餐馆类型 0.5 1 价格 0.311 2 是否有其他选择 0.2513 3 等待时间(分钟) 0 4 数据集第一步被餐馆餐馆类型这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-是|餐馆类型-快餐(意大利式) 分支 在快餐个分支上，标签全部是yes，意大利式分支上全是no，非常纯，作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满|饿否-是|餐馆类型-中餐 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 此分支中有 1 个样例决策为是，1 个样例决策为否。\n1. 整体数据集经验熵计算 该子集的经验熵为： $$ Entropy(S) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 现在我们对剩余特征重新计算信息增益。\n2. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 1 2 否 0 0 0 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 因为是否有其他选择没有有效的分裂，信息增益为0。\n3. 特征“价格”的信息增益 价格 YES NO 样本数 $ 1 1 2 计算条件熵： $$ Entropy(S_{\\$}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 价格也没有带来有效分裂，信息增益为0。\n4. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 0 1 30-60 0 1 1 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = 0 $$ 信息增益： $$ Gain(Decision, 等待时间) = 1 - 0 = 1 $$ 第五层分裂决策 Feature Gain 排名 等待时间(分钟) 1 1 价格 0 2 是否有其他选择 0 2 数据集第一步被餐馆等待时间这个特征分裂成两个节点，现在需要对每个节点计算下一步的分裂特征。继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-是|餐馆类型-中餐|等待时间-1030(3060) 分支 在10-30分支上，标签全部是yes，30-60分支上全是no，非常纯，无需继续分裂。\n至此，最终决策树已构建。\n最终决策树结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . └─顾客人数 ├─客满 │ └─饿否 │ ├─否-\u0026gt;no │ └─是 │ └─餐馆类型 │ ├─中餐 │ │ └─等待时间 │ │ ├─10~30-\u0026gt;yes │ │ └─30~60-\u0026gt;no │ ├─快餐-\u0026gt;yes │ └─意大利式-\u0026gt;no ├─无人-\u0026gt;no └─有人-\u0026gt;yes ![](机器人决策树 P1.png)\n仅供参考，可能有误\n","date":"2024-10-19T00:00:00Z","image":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF2-%E5%85%B8%E5%9E%8B%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95id3/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF2-%E5%85%B8%E5%9E%8B%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95id3/","title":"机器人技术(2): 典型决策树学习算法ID3"},{"content":"c++基础题目（1） 题目列表 1. 以下说法中正确的是（ ）。 答案：C 选项 A. 基类的私有成员在派生类的对象中不可访问，也不占内存空间 B. 封装性指的是将不同类型的相关数据组合在一起，作为一个整体进行处理 C. 在面向对象的程序设计中，结构化程序设计方法仍有着重要作用 D. 多态性指的是对象的状态会根据运行时要求自动变化 易错解释 A. 错误。基类的私有成员在派生类中不可访问，但仍然占用内存空间。 B. 错误。封装性指的是将数据和操作数据的方法绑定在一起，形成一个独立的单位。 D. 错误。多态性指的是同一接口可以有不同的实现形式。 2. 执行以下程序后，输出的结果是（ ）。 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a=4,b=5; float c=b/a; cout\u0026lt;\u0026lt;c\u0026lt;\u0026lt;endl; return 0; } 答案：D 选项 A. 1.25 B. 0 C. 1.3 D. 1 易错解释 A. 错误。b/a 是整数除法，结果为1，再转换为浮点数仍然是1.0。 B. 错误。整数除法的结果不可能是0。 C. 错误。b/a 的结果为1，而不是1.3。 3. 以下描述不正确的是（ ）。 答案：B 选项 A. break语句在一层循环体中可出现多次 B. break语句可用在if语句中，它可使执行的流程跳出当前的if语句 C. break语句可用在循环体中，它将是执行的流程跳出本层循环 D. break语句可用在switch语句中，它使执行的流程跳出当前switch语句 易错解释 B. 错误。break 语句不能用于跳出 if 语句，只能用于跳出循环或 switch 语句。 4. 以下描述不正确的是（ ）。** 答案：A 选项 A. 相同类型的指针之间可以相互赋值 B. 指针中存放的实际上是内存单元的地址 C. 可以在指针定义的同时对其进行初始化 易错解释 A. 错误。相同类型的指针之间可以相互赋值，但不同类型的指针之间不能直接赋值，需要进行类型转换。 5. 以下说法中正确的是（ ）。 答案：C 选项 A. 当动态分配内存失败时，系统会立刻崩溃，因此一定要慎用new B. C++语言只能用new和delete用于动态内存分配和释放的函数 C. 动态分配的内存空间也可以被初始化 D. 当系统内存不够时，会自动回收不再使用的内存单元，因此程序中不必用delete释放内存空间 易错解释 A. 错误。动态分配内存失败时，new 会抛出异常或返回 nullptr，但不会导致系统崩溃。 B. 错误。C++ 中除了 new 和 delete，还可以使用 malloc 和 free 进行动态内存管理。 D. 错误。C++ 不提供自动垃圾回收机制，必须手动释放内存。 6. 以下说法中不正确的是（ ）。 答案：C 选项 A. 构造函数可以对静态数据成员进行初始化 B. 构造函数可以重载 C. 构造函数不可以设置默认参数 D. 构造函数可以在说明类变量时自动执行 易错解释 C. 错误。构造函数可以设置默认参数，这样在创建对象时可以省略部分参数。 7. 以下说法中不正确的是（ ）。 答案：A 选项 A. 公有继承时基类中的private成员在派生类中仍是private的 B. 保护继承时基类中的public成员在派生类中是protected的 C. 公有继承时基类中的public成员在派生类中仍是public的 D. 私有继承时基类中的public成员在派生类中是private的 易错解释 A. 错误。公有继承时，基类中的 private 成员在派生类中不可访问，而不是保持 private。 8. 以下说法中不正确的是（ ）。 答案：B 选项 A. 如果类A是类B的友元，那么类A的所有成员函数都是类B的友元 B. 如果类A是类B的友元，那么类B也是类A的友元 C. 如果函数fun()被说明为类A的友元，那么在fun()中可以访问类A的私有成员 D. 友元关系不能被继承 易错解释 B. 错误。友元关系是单向的，类A是类B的友元，并不意味着类B也是类A的友元。 9. 以下程序的输出结果是（ ）。 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { int a=5; int *pa=\u0026amp;a; int \u0026amp;b=a; b++; cout\u0026lt;\u0026lt;(*pa)++\u0026lt;\u0026lt;endl; return 0; } 答案：C 选项 A. 7 B. 5 C. 6 D. 8 易错解释 A. 错误。b++ 后 a 的值变为6，(*pa)++ 输出6，然后 a 的值变为7。 B. 错误。b++ 后 a 的值变为6，(*pa)++ 输出6。 D. 错误。b++ 后 a 的值变为6，(*pa)++ 输出6，然后 a 的值变为7。 10. 以下程序的输出结果是（ ）。 1 2 3 4 5 6 7 8 9 10 11 12 #include \u0026lt;iostream\u0026gt; void fun(int x, int \u0026amp;y) { int t=x; x=y; y=t; } int main() { int a[2]={100,142}; fun(a[1],a[0]); std::cout\u0026lt;\u0026lt;a[0]\u0026lt;\u0026lt;\u0026#34;,\u0026#34;\u0026lt;\u0026lt;a[1]\u0026lt;\u0026lt;std::endl; return 0; } 答案：D\n选项\nA. 100,100 B. 100,142 C. 142,100 D. 142,142 易错解释\na[0]变成a[1]，a[1]不变。\n11. 有如下说明： int a[10]={1,2,3,4,5,6,7,8,9,10},*p=a; 则数值为9的表达式是（ ）。 答案：C 选项 A. *p+=9 B. p+8 *C. (p+8) D. *p+9 易错解释 A. 错误。*p+=9 会使 p 指向的值增加9，结果为10。 B. 错误。p+8 返回指针，而不是值。 D. 错误。*p+9 会使 p 指向的值加9，结果为10。 12. 下列语句中，正确的是（ ）。 答案：B 选项 A. char Str=\u0026ldquo;Anhui-hefei\u0026rdquo;; *B. char Str=\u0026ldquo;Anhui-hefei\u0026rdquo;; C. char Str[10]=\u0026ldquo;Anhui-hefei\u0026rdquo;; D. char Str[11]=\u0026ldquo;Anhui-hefei\u0026rdquo;; 易错解释 A. 错误。char Str=\u0026quot;Anhui-hefei\u0026quot;; 应该使用字符数组或指针。 C. 错误。char Str[10]=\u0026quot;Anhui-hefei\u0026quot;; 字符串长度超过数组长度。 D. 错误。char Str[11]=\u0026quot;Anhui-hefei\u0026quot;; 字符串长度超过数组长度。 13. 以下说法中正确的是（ ）。 答案：B 选项 A. 从流中获取数据的操作称为插入操作，向流中添加数据的操作称为提取操作 B. 与键盘、屏幕、打印机和通信端口的交互都可以通过流类来实现 C. 输出流有一个名为open的成员函数，其作用是生成一个新的流对象 D. cin是一个预定义的输入流类 易错解释 A. 错误。从流中获取数据的操作称为提取操作，向流中添加数据的操作称为插入操作。 C. 错误。open 是文件流的成员函数，用于打开文件。 D. 错误。cin 是预定义的输入流对象，而不是类。 14. 执行语句序列 int n; cin\u0026gt;\u0026gt;n; switch(n) { case 1: case 2:cout\u0026lt;\u0026lt;'5'; case 3: case 4:cout\u0026lt;\u0026lt;'6';break; default:cout\u0026lt;\u0026lt;'7'; } 时，若键盘输入1，则输出结果是（ ）。 答案：C 选项 A. 5 B. 6 C. 56 D. 7 易错解释 A. 错误。case 1 和 case 2 没有 break，会继续执行 case 3 和 case 4。 B. 错误。case 1 和 case 2 没有 break，会继续执行 case 3 和 case 4。 D. 错误。case 1 和 case 2 没有 break，会继续执行 case 3 和 case 4。 15. 以下程序的输出结果是（ ）。 1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; using namespace std; int main() { cout.fill(\u0026#39;*\u0026#39;); cout.width(8); cout.fill(\u0026#39;$\u0026#39;); cout \u0026lt;\u0026lt; 123 \u0026lt;\u0026lt; endl; return 0; } 答案：B 选项 A. *****123 B. $$$$$123 C. 123$$$$$ D. 123***** 易错解释 A. 错误。cout.fill('$') 设置填充字符为 $。 C. 错误。cout.width(8) 设置输出宽度为8，不足部分用 $ 填充。 D. 错误。cout.fill('$') 设置填充字符为 $。 16. 以下说法中不正确的是（ ）。 答案：C 选项 A. 面向对象是从现实世界中客观存在的事物出发来构造软件系统的 B. 面向对象方法中使用了一些面向过程方法中没有的概念 C. 面向对象方法替代了过程化程序设计方法 D. 面向对象程序设计方法要使用面向对象的程序设计语言 易错解释 C. 错误。面向对象方法并没有完全替代过程化程序设计方法，两者各有适用场景。 17. 以下说法中不正确的是（ ）。 答案：A 选项 A. 使用sizeof运算符可以求得某种类型和某个变量在内存中占的字节数，不能求得某个表达式的类型在内存中所占的字节数 B. 没有参数的两个函数是不能重载的 C. 在C++程序中，变量值是可以改变的，变量的地址值是不能改变的 D. 开关语句中各个case和default出现的前后次序不影响执行结果 易错解释 A. 错误。sizeof 运算符可以用于求得表达式的类型在内存中所占的字节数。 18. 以下说法中不正确的是（ ）。 答案：B 选项 A. 动态联编是函数联编的一种方式，它是在运行时来选择联编函数的 B. 函数重载和运算符重载都属于动态联编 C. 动态联编又可称为动态多态性，是通过虚函数实现的 D. 抽象类中至少应该有一个纯虚函数 易错解释 B. 错误。函数重载和运算符重载属于静态联编，而不是动态联编。 19. 已知：B类是A类的公有继承的派生类，以下说法中不正确的是（ ）。 答案：A 选项 A. A类的对象就是B类的对象 B. B类对象可以给A类对象赋值 C. B类对象的地址值可以给A类对象指针赋值 D. B类对象可以给A类对象引用赋值 易错解释 A. 错误。A类的对象不是B类的对象，但B类的对象可以被视为A类的对象。 20. 以下说法中正确的是（ ）。 答案：C 选项 A. 字符串常量与字符常量的区别仅表现在定义形式上的不同，一个用双撇号，另一个用单撇号 B. 增1和减1运算符不仅可以作用在变量上，也可以作用在表达式上 C. C++程序中，通常使用const来定义符号常量，定义时必须指出类型 D. 关系运算符可以用来比较两个字符的大小，也可以比较两个字符串的大小 易错解释 A. 错误。字符串常量和字符常量不仅在定义形式上不同，它们的类型和用途也不同。 B. 错误。增1和减1运算符只能作用在变量上，不能作用在表达式上。 D. 错误。关系运算符可以比较两个字符的大小，但不能直接比较两个字符串的大小，需要使用字符串比较函数。 21. 已知：int swap(int \u0026amp;a,int \u0026amp;b), x=10, y=20; 下列调用 swap() 函数的语句中，编译不会报错的是（ ）。 答案：C 选项 A. swap(\u0026amp;x,\u0026amp;y); B. swap(x+2,y+5); C. swap(x,y); D. swap(x++,++y); 易错解释 A. 错误。\u0026amp;x 和 \u0026amp;y 是指针，而 swap 函数需要引用参数。 B. 错误。x+2 和 y+5 是临时表达式，不能作为引用参数。 D. 错误。x++ 和 ++y 是带有副作用的表达式，不能作为引用参数。 22. void Set(A\u0026amp;a); 是类A中一个成员函数的说明，其中 A\u0026amp;a 的含义是（ ）。 答案：A 选项 A. 类A的对象引用a作该函数的参数 B. 类A的对象a的地址值作函数的参数 C. 表达式变量A与变量a按位与作函数参数 D. 指向类A对象指针a作函数参数 易错解释 B. 错误。A\u0026amp;a 是引用，而不是指针。 C. 错误。按位与操作与函数参数无关。 D. 错误。A\u0026amp;a 是引用，而不是指针。 23. 以下说法中不正确的是（ ）。 答案：B 选项 A. 运算符重载是通过对已有的运算符重新定义操作功能来实现的，它是C++语言多态性的一种表现 B. 如果类模板的模板类型参数有多个，除第1个模板类型参数前使用关键字class，其余的模板类型参数前都不使用关键字class C. 虚函数有继承性，基类中说明的虚函数只要在它的派生类中与它名字相同的，一定是虚函数 D. 一个抽象类中可以包含有多个纯虚函数，一个派生类中也可以包含多个虚函数 易错解释 B. 错误。类模板的每个模板类型参数前都可以使用 class 或 typename 关键字。 24. 以下程序的输出结果是（ ）。 1 2 3 4 5 6 7 8 #include \u0026lt;iostream\u0026gt; #define MAX(x,y) (x)\u0026gt;(y)?(x):(y) void main() { typedef int IN; IN a(3), b(4), c; c = MAX(a, b) * 2; std::cout \u0026lt;\u0026lt; c \u0026lt;\u0026lt; std::endl; } 答案：C 选项 A. 6 B. 12 C. 8 D. 7 易错解释 A. 错误。MAX(a, b) 返回4，乘以2得8。 B. 错误。MAX(a, b) 返回4，乘以2得8。 D. 错误。MAX(a, b) 返回4，乘以2得8。 25. 以下程序的输出结果是（ ）。 1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; void main() { int a(10); while (--a) { if (a == 5) break; std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; } } 答案：B 选项 A. 9 8 7 6 B. 9 8 7 C. 7 D. 9 8 7 6 5 易错解释 A. 错误。当 a 为5时，break 退出循环，不输出5。 C. 错误。输出的是9、8、7。 D. 错误。当 a 为5时，break 退出循环，不输出5。 26. 以下说法中不正确的是（ ）。 答案：C 选项 A. 定义派生类可用关键字class或struct B. 定义派生类时要指出派生类的类名和基类的类名 C. 定义派生类时一定要给出继承方式，不能默认 D. 定义派生类时，类体中给出派生类的成员 易错解释 C. 错误。在定义派生类时，如果未指定继承方式，默认为私有继承（private）。 27. 以下程序的输出结果是（ ）。 答案：A\n代码\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream\u0026gt; void main() { char s[] = \u0026#34;bhy543kpm345\u0026#34;; for (int i = 0; s[i] != \u0026#39;\\0\u0026#39;; i++) { if (s[i] \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; s[i] \u0026lt;= \u0026#39;z\u0026#39;) continue; std::cout \u0026lt;\u0026lt; s[i]; } std::cout \u0026lt;\u0026lt; std::endl; } 选项\nA. 543345 B. bhykpm C. bhy543kpm345 D. bhy543 28. 以下说法中正确的是（ ）。 答案：B 选项 A. 没有返回值的函数不能设置为内联函数 B. 字符指针是指向字符串的指针，可以用字符串常量给字符指针赋值 C. 外部类变量与外部静态类变量的作用域是相同的 D. 定义一个数组没有对它进行初始化，则该数组的元素值都是无意义的 易错解释 A. 错误。没有返回值的函数可以设置为内联函数。 C. 错误。外部类变量和外部静态类变量的作用域不同。 D. 错误。未初始化的数组元素值是未定义的，但不一定无意义。 29. 以下说法中不正确的是（ ）。 答案：C 选项 A. 用来给数组进行初始化的初始值表内的数据项的个数必须小于等于数组元素个数 B. C++程序中，通常使用const来定义符号常量，定义时必须指出类型 C. 移位运算符在移位操作中，无论左移还是右移，对移出的空位一律补0 D. 数组某维的大小可以用常量表达式，不可用变量名 易错解释 C. 错误。右移运算符在移位操作中，对于有符号数，移出的空位补符号位；对于无符号数，移出的空位补0。 30. 以下程序的输出结果是（ ）。 答案：B\n1 2 3 4 5 6 7 8 9 #include \u0026lt;iostream.h\u0026gt; void main() { int a(10); while (--a) { if (a == 5) break; if (a % 2 == 0 \u0026amp;\u0026amp; a % 3 == 0) continue; std::cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; std::endl; } } 选项\nA. 9 8 7 6 B. 9 8 7 C. 7 D. 9 8 7 6 5 31. 下列关于C++的说法中，正确的是（ ）。 答案：C 选项 A. C++对于大小写不敏感 B. C++属于解释性语言 C. 任何合法的C语言程序都是合法的C++程序 D. C++支持封装与继承，但是不支持多态 易错解释 A. 错误。C++是大小写敏感的。 B. 错误。C++是编译型语言。 D. 错误。C++支持封装、继承和多态。 32. 下列哪项关键词属于C++所有但是C语言没有的（）。 答案：B 选项 A. extern B. virtual C. and D. goto 易错解释 A. extern 是C和C++都有的关键字。 C. and 是C++的别名，C语言中没有。 D. goto 是C和C++都有的关键字。 33. 有如下枚举类型的定义，下面说法错误的是哪一项( )。 答案：C\n代码\n1 enum fruit {hotdog, apple = 4, beef, orange}; 选项\nA. fruit c = hotdog; 则c的值为0 B. fruit c = apple; 则c的值为4 C. fruit c = beef; 则c的值为2 D. fruit c = orange; 则c的值为6 易错解释\nC. 错误。beef 的值应该是5，因为 apple 被显式赋值为4，beef 是下一个枚举值，所以是5。 34. 下面所述的四段代码，不能够完成遍历二叉树的是哪一项（打印二叉树所有节点仅一次）（ ）。 答案：B\n代码\n1 2 3 4 5 struct BiTree { int data; struct BiTree* left; struct BiTree* right; }; 选项\nA.\n1 2 3 4 5 6 void traversal(struct BiTree *node) { if (node == NULL) return; traversal(node-\u0026gt;right); std::cout \u0026lt;\u0026lt; node-\u0026gt;data \u0026lt;\u0026lt; std::endl; traversal(node-\u0026gt;left); } B.\n1 2 3 4 5 6 7 8 9 10 11 void traversal(struct BiTree node) { if (node == NULL) return; std::stack\u0026lt;BiTree\u0026gt; s; s.push(node); while (!s.empty()) { s.pop(); std::cout \u0026lt;\u0026lt; s.top()-\u0026gt;data \u0026lt;\u0026lt; std::endl; if (s.top()-\u0026gt;right) s.push(s.top()-\u0026gt;right); if (s.top()-\u0026gt;left) s.push(s.top()-\u0026gt;left); } } C.\n1 2 3 4 5 6 7 8 9 10 11 12 void traversal(struct BiTree *node) { if (node == NULL) return; std::stack\u0026lt;BiTree*\u0026gt; s; s.push(node); while (!s.empty()) { auto top = s.top(); s.pop(); std::cout \u0026lt;\u0026lt; top-\u0026gt;data \u0026lt;\u0026lt; std::endl; if (top-\u0026gt;right) s.push(top-\u0026gt;right); if (top-\u0026gt;left) s.push(top-\u0026gt;left); } } D.\n1 2 3 4 5 6 7 8 9 10 11 12 void traversal(struct BiTree *node) { if (node == NULL) return; std::queue\u0026lt;BiTree*\u0026gt; q; q.push(node); while (!q.empty()) { auto front = q.front(); q.pop(); std::cout \u0026lt;\u0026lt; front-\u0026gt;data \u0026lt;\u0026lt; std::endl; if (front-\u0026gt;right) q.push(front-\u0026gt;right); if (front-\u0026gt;left) q.push(front-\u0026gt;left); } } 易错解释\nB. 错误。这段代码中，s.pop() 后再使用 s.top() 会导致未定义行为。 35. 设计一个队列，以链表存储队列的元素。假设队首指针为head，队尾指针为tail，现指针p指向的元素即将入队，请写出正确的入队代码？（） 答案：D 选项 A. head = p, head = head-\u0026gt;next; B. p-\u0026gt;next = head-\u0026gt;next, head = p; C. tail-\u0026gt;next = p, tail = p; D. tail-\u0026gt;next = p, p-\u0026gt;next = NULL, tail = p; 36. 若是x为4，y为9，则(~x)^y的结果是（ ）。 答案：C 选项 A. 1 B. 10 C. 13 D. -14 易错解释 C. 正确。~4 的二进制表示为 11111101（假设8位），9 的二进制表示为 00001001，两者异或结果为 11110100，即十进制的13。 37. 下面关于C++函数的说法中，错误的选项是（ ）。 答案：A 选项 A. 函数由函数名称、返回类型、参数、函数体组成，缺一不可 B. 函数声明时参数类型不可省，参数名称不是必要的 C. 有的函数可能没有return关键字 D. C++可以在定义函数时，设置默认参数值 易错解释 A. 错误。函数可以没有参数，也可以没有返回类型（如void函数）。 38. 定义了如下所示的test1类和它的子类test2，下列选项说法错误的是（ ）。 答案：C\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 class test1 { std::string name; public: std::string language; protected: float grade; }; class test2 : public test1 { public: char gender; void fun() { std::cout \u0026lt;\u0026lt; gender \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; language \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; grade \u0026lt;\u0026lt; std::endl; } }; 选项\nA. fun()函数中变量gender可以正常输出 B. fun()函数中变量language可以正常输出 C. fun()函数中变量name可以正常输出 D. fun()函数中变量grade可以正常输出 易错解释\nC. 错误。name 是私有成员，无法在派生类中直接访问。 39. 下列C++程序实现了使用迭代器访问并输出数组vec的元素，空白处应该补充的代码是（ ）。 答案：A\n代码\n1 2 3 4 5 std::vector\u0026lt;int\u0026gt;::iterator v = vec.begin(); while (v != vec.end()) { // 空白处 ++v; } 选项\n*A. std::cout \u0026laquo; v \u0026laquo; std::endl; B. std::cout \u0026laquo; v \u0026laquo; std::endl; C. std::cout \u0026laquo; \u0026amp;v \u0026laquo; std::endl; D. 其他选项均可以 易错解释\nA. 正确。*v 解引用迭代器，获取元素值。 40. 关于下列几行C++代码，说法正确的是（ ）。 答案：B\n代码\n1 2 3 4 std::string c1 = \u0026#34;a\u0026#34;; std::string c2 = \u0026#34;b\u0026#34;; char c3 = \u0026#39;c\u0026#39;; char c4 = \u0026#39;d\u0026#39;; 选项\nA. 直接输出c1 + c2的结果是195 B. 直接输出c3 + c4 的结果是199 C. 直接输出c1 + c3 的结果是196 D. 其他选项说法均错误 易错解释\nB. 正确。c3 和 c4 的ASCII码分别为99和100，相加结果为199。 41. C++STL的核心不包括以下哪个选项（ ）。 答案：C 选项 A. 迭代器 B. 算法 C. 指针 D. 容器 易错解释 C. 错误。指针不属于STL的核心部分。 42. 关于下列C++代码的时间复杂度与空间复杂度的说法，正确的是（ ）。 答案：A\n代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 struct node { int x, time; }; int solve(int N, std::vector\u0026lt;node\u0026gt;\u0026amp; A) { std::stack\u0026lt;node\u0026gt; s; int res = 0; for (int i = N - 1; i \u0026gt;= 0; i--) { int time = 0; while (!s.empty() \u0026amp;\u0026amp; A[i].x \u0026gt; s.top().x) { time = std::max(s.top().time, time + 1); s.pop(); } s.push({A[i], time}); res = std::max(res, time); } return res; } 选项\nA. 时间复杂度为O(N)，空间复杂度为O(N) B. 时间复杂度为O(2N)，空间复杂度为O(N) C. 时间复杂度为O(N^2)，空间复杂度为O(N/2) D. 时间复杂度为O(logN)，空间复杂度为O(N/2) 易错解释\nA. 正确。每个元素最多入栈和出栈一次，时间复杂度为O(N)。 43. 下列关于C++常用标准库的一些说法，错误的是哪一项（）。 答案：D 选项 A. cout控制输出精度需要使用std::setprecision B. 标准错误流cerr属于标准输出流的一部分 C. 字符串截取函数substr()属于std::string D. 一个C++工程里不可以有两个或多个命名空间 易错解释 D. 错误。一个C++工程中可以有多个命名空间。 44. 假定输入的字符串中只包含字母和@号，请编写程序，将字符串中的前导@符全部移到字符串的尾部。例如：字符串中的内容为：@@@@ab@CD@G@@@,移动后，字符串中的内容为：ab@CD@G@@@@@@@。在编写程序时，不得使用C++语言提供的字符串函数。（输入的字符串不含空格，且字符串长度不大于1000） 答案：略\n输入样例1：\n1 @@@@ab@CD@G@@@ 输出样例1：\n1 ab@CD@G@@@@@@@ 输入样例2：\n1 abc@d 输出样例2：\n1 abc@d 45. 编写程序，从键盘上输入两个正整数，较大的数为m和较小的数为n,根据以下公式求P的值，并输出。(m和n为大于0且小于等于30的整数） 答案：略\n输入样例1：\n1 12 8 输出样例1：\n1 495 输入样例2：\n1 27 30 输出样例2：\n1 4060 46. 定义了N×N的二维数组，数组元素（整数）通过键盘输入，请编写程序，求出数组周边元素的和值，并输出。（2\u0026lt;=N\u0026lt;=100) 答案：略\n输入样例1：\n1 2 3 4 5 6 5 0 1 2 7 9 1 9 7 4 5 2 3 8 3 1 4 5 6 8 2 5 9 1 4 1 输出样例1：\n1 60 输入样例2：\n1 2 3 4 3 -3 2 0 1 2 3 -3 -2 -1 输出样例2：\n1 -1 仅供参考，可能有误\n","date":"2024-10-18T00:00:00Z","image":"http://localhost:1313/p/c-%E5%9F%BA%E7%A1%80/stl_hu16550555255445278498.png","permalink":"http://localhost:1313/p/c-%E5%9F%BA%E7%A1%80/","title":"c++基础"},{"content":"#STL常用算法函数及其参数简明含义 供快速回顾（常用函数摘自HFUT ICPC讲义P21） find\n功能：在范围 [first, last) 中查找值为 val 的第一个元素。 参数： InIt first, InIt last：输入迭代器，指定搜索范围。 const T\u0026amp; val：需要查找的值。 find_if\n功能：在范围 [first, last) 中查找第一个满足谓词 pr 的元素。 参数： InIt first, InIt last：输入迭代器。 Pred pr：一元谓词函数，返回布尔值。 count\n功能：计算范围 [first, last) 中等于 val 的元素个数。 参数： InIt first, InIt last：输入迭代器。 const T\u0026amp; val：待计数的值。 count_if\n功能：计算范围 [first, last) 中满足谓词 pr 的元素个数。 参数： InIt first, InIt last：输入迭代器。 Pred pr：一元谓词函数。 copy\n功能：将范围 [first, last) 中的元素复制到 x 开始的位置。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器，复制的目标位置。 swap\n功能：交换两个变量 x 和 y 的值。 参数： T\u0026amp; x, T\u0026amp; y：需要交换的两个变量。 swap_ranges\n功能：交换两个范围 [first, last) 和从 x 开始的元素。 参数： FwdIt1 first, FwdIt1 last：第一个范围的迭代器。 FwdIt2 x：第二个范围的起始迭代器。 replace\n功能：将范围 [first, last) 中等于 vold 的元素替换为 vnew。 参数： FwdIt first, FwdIt last：输入迭代器。 const T\u0026amp; vold, const T\u0026amp; vnew：旧值和新值。 replace_if\n功能：将范围 [first, last) 中满足谓词 pr 的元素替换为 val。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：一元谓词函数。 const T\u0026amp; val：替换的值。 generate\n功能：用生成器 g 生成的值填充范围 [first, last)。 参数： FwdIt first, FwdIt last：输入迭代器。 Gen g：生成器函数。 generate_n\n功能：用生成器 g 生成的值填充从 first 开始的 n 个元素。 参数： OutIt first：输出迭代器。 Dist n：生成元素的数量。 Gen g：生成器函数。 remove\n功能：删除范围 [first, last) 中等于 val 的元素，并返回新范围的末尾迭代器。 参数： FwdIt first, FwdIt last：输入迭代器。 const T\u0026amp; val：需要删除的值。 remove_if\n功能：删除范围 [first, last) 中满足谓词 pr 的元素，并返回新范围的末尾迭代器。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：一元谓词函数。 remove_copy\n功能：将范围 [first, last) 中不等于 val 的元素复制到 x 开始的地方。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器。 const T\u0026amp; val：待删除的值。 remove_copy_if\n功能：将范围 [first, last) 中不满足谓词 pr 的元素复制到 x 开始的位置。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器。 Pred pr：一元谓词函数。 unique\n功能：删除范围 [first, last) 中相邻的重复元素。 参数： FwdIt first, FwdIt last：输入迭代器。 unique (带谓词)\n功能：删除范围 [first, last) 中相邻满足谓词 pr 的重复元素。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：二元谓词函数。 reverse\n功能：反转范围 [first, last) 中的元素。 参数： BidIt first, BidIt last：双向迭代器。 reverse_copy\n功能：将范围 [first, last) 中的元素反转后复制到 x 开始的位置。 参数： BidIt first, BidIt last：双向迭代器。 OutIt x：输出迭代器。 partition\n功能：将范围 [first, last) 中满足谓词 pr 的元素放在不满足谓词的元素之前。 参数： BidIt first, BidIt last：双向迭代器。 Pred pr：一元谓词函数。 stable_partition\n功能：与 partition 类似，但保留相对顺序。 参数： FwdIt first, FwdIt last：前向迭代器。 Pred pr：一元谓词函数。 sort\n功能：对范围 [first, last) 中的元素进行升序排序。 参数： RanIt first, RanIt last：随机访问迭代器。 sort (带谓词)\n功能：按照谓词 pr 对范围 [first, last) 中的元素排序。 参数： RanIt first, RanIt last：随机访问迭代器。 Pred pr：二元谓词函数。 stable_sort\n功能：稳定排序范围 [first, last) 中的元素，保留相等元素的相对顺序。 参数： BidIt first, BidIt last：双向迭代器。 stable_sort (带谓词)\n功能：按照谓词 pr 稳定排序。 参数： BidIt first, BidIt last：双向迭代器。 Pred pr：二元谓词函数。 nth_element\n功能：对范围 [first, last) 进行部分排序，使得 nth 处的元素位于其最终位置。 参数： RanIt first, RanIt nth, RanIt last：随机访问迭代器。 binary_search\n功能：判断范围 [first, last) 中是否存在值 val。 参数： FwdIt first, FwdIt last：前向迭代器。 const T\u0026amp; val：要查找的值。 binary_search (带谓词)\n功能：根据谓词 pr 判断范围 [first, last) 中是否存在值 val。 参数： FwdIt first, FwdIt last：前 向迭代器。 - const T\u0026amp; val：要查找的值。 - Pred pr：二元谓词函数。\nmerge\n功能：将两个已排序的范围合并到一个新的范围中。 参数： InIt1 first1, InIt1 last1：第一个范围的输入迭代器。 InIt2 first2, InIt2 last2：第二个范围的输入迭代器。 OutIt x：输出迭代器。 merge (带谓词)\n功能：根据谓词 pr 将两个已排序范围合并。 参数： InIt1 first1, InIt1 last1：第一个范围的输入迭代器。 InIt2 first2, InIt2 last2：第二个范围的输入迭代器。 OutIt x：输出迭代器。 Pred pr：二元谓词函数。 max\n功能：返回 x 和 y 中较大的那个。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 max (带谓词)\n功能：根据谓词 pr 返回较大的值。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 Pred pr：二元谓词函数。 min\n功能：返回 x 和 y 中较小的那个。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 min (带谓词)\n功能：根据谓词 pr 返回较小的值。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 Pred pr：二元谓词函数。 仅供参考，可能有误\n","date":"2024-10-18T00:00:00Z","image":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF1-stl/stl_hu16550555255445278498.png","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF1-stl/","title":"程序设计艺术(1): STL"},{"content":"Hugo 是用 Go 实现的博客工具，采用 Markdown 进行文章编辑，自动生成静态站点文件，支持丰富的主题配置，也可以通过 js 嵌入像是评论系统等插件，高度定制化。除了 Hugo 外， 还有 Jekyll(github page默认)、Gatsby、Hexo、Ghost 等选择，实现和使用都差不多，可以根据自己的偏好进行选择。\n安装 Hugo 在ubuntu24.04 LTS环境下到 Hugo Releases 下载对应的deb包(注意安装extend版本，许多第三方主题需要extend依赖)，安装完成后，使用以下命令进行验证：\n1 hugo version 创建 Hugo 网站 通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了，如希望生成到 /path/to/site 路径：\n1 $ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n1 $ cd /path/to/site 站点目录结构：\n1 2 3 4 5 6 7 8 9 . ├── archetypes: default.md是生成博文的模版 ├── assets # 存放被 Hugo Pipes 处理的文件 ├── content # 存放markdown文件作为博文内容 ├── data # 存放 Hugo 处理的数据 ├── layouts # 存放布局文件 ├── static # 存放静态文件 图片 CSS JS文件 ├── themes: 存放不同的主题 └── config.toml: 博客配置文件支持 JSON YAML TOML 三种格式配置文件 创建文章 创建一个 about 页面：\n1 $ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下：\n1 2 3 4 5 6 7 8 +++ date = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;about\u0026#34; +++ 正文内容 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。\n创建第一篇文章，放到 content/post 目录，方便之后生成聚合页面。\n1 $ hugo new post/first.md 打开编辑 content/post/first.md ：\n1 2 3 4 5 6 7 8 9 10 11 --- date: \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; title: \u0026#34;first\u0026#34; --- ### Hello Hugo 1. aaa 1. bbb 1. ccc 注意此项为可选步骤，跳过可直接copy他人主题\n配置主题 当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目的github仓库，一般人气多的主题都会有很详细的安装及配置说明。\n传统方式使用的是将原主题仓库 fork 到自己的账户，并使用 git submodule 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。\n1 2 3 cd cita-site/#进入网站工程根目录 git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack#笔者所用主题为stack，此行与你所选主题有关 然后在根目录下的 config.toml文件中添加新的一行:\n1 theme = \u0026#34;your_theme\u0026#34; 此时大多数主题仓库提供example文件，你可以拷贝至你的工程根目录下，主要是content与config文件，之后就能进行下一步，如有问题建议查看主题提供的参考手册。\n生成网页 为了查看生成的博客的效果，我们在本地编辑调试时可以通过 hugo server 命令进行本地实时调试预览，无须每次都重新生成。在bash中运行以下命令，即我们可以通过浏览器 http://localhost:1313/ 地址访问我们的本地预览网页。\n1 hugo server 但此时只能在本地访问，如果想发布到 Github Pages ， 还需要借助 GithubPages 工具。\nGithub Pages部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io （coderzh替换为你的github用户名）。站点目录config.toml中baseURL要换成自己建立的仓库，如baseURL = “https://cita-777.github.io/\u0026quot;\n在站点根目录执行 Hugo 命令生成最终页面：\n1 $ hugo --theme=hyde --baseURL=\u0026#34;http://coderzh.github.io/\u0026#34; 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。\n1 2 3 4 5 6 $ cd public $ git init $ git remote add origin https://github.com/coderzh/coderzh.github.io.git $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master 浏览器里访问：http://coderzh.github.io/\n注意必须只上传public中的所有文件，若无法使用密钥则使用ssh鉴定身份(git remote set-url origin git@github.com:cita-777/cita-777.github.io.git)，目前github默认主分支为main，建议设置里改为master\n后续修改网页 对content和config进行自行随意修改后需要重新上传至github仓库同步更新。切记不要随意手动删除public文件让Hugo重新生成再尝试push，因为这会将public内的.git一起删除，你将需要重新配置git并且链接至远程仓库，当你使用hugo server命令在本地生存并预览网站后，Hugo会自动生成新的public文件，包含你对网站所作的所有新更改，而且你在static文件管理资源时所进行的增加与删除，public中只会进行增加而不会删除，本意是很好的，这是一种非破坏性修改。所以如果你有用不上的资源，记得在public文件内手动删除来减少空间占用，所以你只需要朴实无华的push即可，参考命令如下：\n1 2 3 4 5 6 hugo server -D ctrl + c #关闭本地server cd public #进入public文件内 git add -A #提交all变动 git commit -m \u0026#34;修改/更新了xxx\u0026#34; git push -u origin master #push到远程仓库 (进阶)Github Action 自动发布 通过前面的操作我们可以手动发布我们的静态文件，但还是有以下弊端：\n发布步骤还是比较繁琐，本地调试后还需要切换到 public/ 目录进行上传 无法对博客 .md 源文件进行备份与版本管理 因此，我们需要简单顺滑的方式来进行博客发布，首先我们初始化博客源文件的仓库，如我的仓库为 pseudoyu/yu-blog。\n因为我们的博客基于 GitHub 与 GitHub Pages，可以通过官方提供的 GitHub Action 进行 CI 自动发布，下面我会进行详细讲解。GitHub Action 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。\n配置在仓库目录 .github/workflows 下，以 .yml 为后缀。我的 GitHub Action 配置为 pseudoyu/yu-blog deploy.yml，自动发布示例配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: pseudoyu/pseudoyu.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} on 表示 GitHub Action 触发条件，我设置了 push、workflow_dispatch 和 schedule 三个条件：\npush，当这个项目仓库发生推送动作后，执行 GitHub Action workflow_dispatch，可以在 GitHub 项目仓库的 Action 工具栏进行手动调用 schedule，定时执行 GitHub Action，如我的设置为北京时间每天早上执行，主要是使用一些自动化统计 CI 来自动更新我博客的关于页面，如本周编码时间，影音记录等，如果你不需要定时功能，可以删除这个条件 jobs 表示 GitHub Action 中的任务，我们设置了一个 build 任务，runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。我们的 build 任务包含了 Checkout、Setup Hugo、Build Web 和 Deploy Web 四个主要步骤，其中 run 是执行的命令，uses 是 GitHub Action 中的一个插件，我们使用了 peaceiris/actions-hugo@v2 和 peaceiris/actions-gh-pages@v3 这两个插件。其中 Checkout 步骤中 with 中配置 submodules 值为 true 可以同步博客源仓库的子模块，即我们的主题模块。\n首先需要将上述 deploy.yml 中的 EXTERNAL_REPOSITORY 改为自己的 GitHub Pages 仓库，如我的设置为 pseudoyu/pseudoyu.github.io。\n因为我们需要从博客仓库推送到外部 GitHub Pages 仓库，需要特定权限，要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。\n","date":"2024-10-06T00:00:00Z","image":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu9262121530157302112.jpg","permalink":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/","title":"Hugo+Github Pages搭建静态网站作为个人博客(1)"},{"content":"上一篇博客中重点于Hugo的使用，这一篇着重于以Stack主题为例进行博客撰写。\nStack is a simple card-style Hugo theme designed for Bloggers. Here are some of the features: Stack 是一个简单的卡片式 Hugo 主题，专为 Blogger 设计。以下是一些功能：\nResponsive images support 响应式图像支持 Lazy load images 延迟加载图像 Dark mode 深色模式 Local search 本地搜索 PhotoSwipe integration 照片滑动集成 Archive page template 存档页面模板 Full native JavaScript, no jQuery or any other frameworks are used 完全原生 JavaScript，不使用 jQuery 或任何其他框架 No CSS framework, keep it simple and minimal 没有 CSS 框架，保持简单和最小化 Properly cropped thumbnails 正确裁剪的缩略图 Subsection support 分段支持 Table of contents 目录 Hugo网站文件结构 网站根目录下面的文件夹目录树一般如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 . ├── archetypes │ └── default.md ├── hugo.yaml # 网站配置文件 ├── content # 站点内的内容都在这里 │ ├── categories # “分类”页面的首页 │ │ └── Test # “分类”页面下的一个分类页面 │ ├── page # 显示在网站主页左侧边栏菜单的选项 │ │ ├── about # 左侧边栏菜单中的“关于”页面 │ │ ├── archives # 左侧边栏菜单中的“归档”页面 │ │ ├── links # 左侧边栏菜单中的“链接”页面 │ │ └── search # 左侧边栏菜单中的“搜索”页面 │ └── post # 用户写的帖子都放在这里，每个子文件夹对应一个帖子 │ ├── chinese-test │ ├── emoji-support │ ├── markdown-syntax │ ├── math-typesetting │ ├── placeholder-text │ └── rich-content ├── data ├── layouts ├── LICENSE ├── README.md ├── resources │ └── _gen │ ├── assets │ └── images ├── static # 放用户自定义字体、用户头像、网站小图标等 └── themes # 放各种主题 └── hugo-theme-stack # stack主题 ├── archetypes ├── assets #里面有个img存放头像图片位置 ├── config.yaml #stack主题的配置文件，优先级低于上面的网站配置文件 ├── data ├── debug.sh ├── exampleSite ├── go.mod ├── i18n #多语言支持包 ├── images #网站示例的截图存放位置 ├── layouts ├── LICENSE ├── netlify.toml ├── README.md └── theme.toml 主要修改主题内和网站内的config.yaml，具体含义可见官方手册。\n此外，上面没有显示的是网站根目录下的private文件夹和public文件夹。\npublic文件夹会在运行hugo -D部署网站时生成，是暴露给外界的文件夹，网站上页面的HTML文件都会由Hugo生成并放在public文件夹下。public文件夹内不要放置任何包含用户信息的敏感文件！ private文件夹可以由用户创建，这里我们用它来存放网站的SSL证书。 关于网站根目录下各文件夹，更详细的说明可参见Hugo官方文档。\n配置文件夹config Hugo支持两种配置方式：\n一种是直接在网站根目录的.config文件中配置 另一种是在网站根目录下创建config文件夹，配置放在config文件夹内 第二种配置方式支持将不同的配置项分开放在不同的文件中，相比第一种配置方式可以让配置项的条理更加清晰，因此我们这里选择第二种配置方式。参考配置目录结构如下所示：\n1 2 3 4 5 6 7 8 config └── _default ├── config.yaml ├── languages.yaml ├── menu.en.yaml ├── menu.zh-cn.yaml ├── params.en.yaml └── params.zh-cn.yaml 关于Hugo的配置，更详细的说明可参考官方文档。\n[附录1]主题内config.yaml各参数简明含义 Module (模块设置)\nhugoVersion\n: 定义Hugo版本要求。\nextended: 设置为true表示需要Hugo的扩展版本（支持SCSS和其他高级功能）。 min: 需要的最低Hugo版本为0.87.0。 Params (参数设置)\nmainSections: 定义主要的内容部分，这里是post，也就是文章部分。 featuredImageField: 文章中用于展示特色图片的字段名称，默认为image。 rssFullContent: RSS中是否提供文章的完整内容，true表示是。 Favicon (网站图标)\nfavicon: 设置网站的favicon路径，如果有一个favicon.ico，可以设置为/favicon.ico。 Footer (页脚)\nsince: 页脚中显示的年份（通常是网站开始的年份），这个字段为空，可以填入年份，如“2024”。 customText: 页脚自定义文本，当前为空，可以填写你想显示的内容。 Date Format (日期格式)\npublished: 发布日期的显示格式，这里格式为Jan 02, 2006。 lastUpdated: 最后更新日期的显示格式，这里包括日期和时间。 Sidebar (侧边栏)\ncompact: 是否使用紧凑布局，false表示不使用紧凑布局。\nemoji: 表情符号，可以为空或者自定义一个表情符号显示在侧边栏上。\nsubtitle: 侧边栏的副标题，当前为空，可以添加文字。\navatar\n: 头像设置。\nenabled: 是否显示头像，true表示显示。 local: true表示头像从本地文件加载。 src: 头像的路径为img/avatar.png。 Article (文章设置)\nheadingAnchor: 设置是否在标题旁边显示锚点，false表示不显示。\nmath: 是否支持数学公式，false表示不支持。\ntoc: 目录设置，true表示显示文章目录。\nreadingTime: 是否显示阅读时间，true表示显示。\nlicense\n: 文章版权设置。\nenabled: 是否启用版权声明，false表示不启用。 default: 默认的版权声明，当前设置为“Creative Commons BY-NC-SA 4.0”，但没有启用。 Comments (评论系统)\nenabled: 是否启用评论，false表示不启用。 provider: 默认评论提供者是disqus。 配置了多个评论系统，包括disqusjs, utterances, beaudar, remark42, vssue等。每个评论系统都有自己的设置项，例如Disqus、GitHub Issues（通过utterances）、Beaudar等。这些可以根据需要选择，并填入相关参数，如API密钥、仓库名称等。 Widgets (小工具)\nhomepage: 主页上的小工具列表，当前为空，也就是说默认没有显示任何小工具。 page: 页面上的小工具列表，当前为空。 OpenGraph (社交分享卡片)\ntwitter\n: 配置Twitter分享卡片。\nsite: 填写你的Twitter用户名。 card: 卡片类型，这里是summary_large_image，表示大图片的分享卡片。 DefaultImage (默认图片)\nopengraph\n: 配置默认图片的设置。\nenabled: 是否启用OpenGraph图片，false表示不启用。 local: 图片是否为本地图片，false表示不是本地图片。 src: 默认图片的路径。 ColorScheme (颜色主题)\ntoggle: 是否允许用户切换颜色主题（比如暗黑模式），true表示启用切换功能。 default: 默认颜色主题，这里是auto，表示根据用户系统的设置自动切换。 ImageProcessing (图片处理)\ncover: 是否启用封面图片处理，true表示启用。 content: 是否启用内容图片处理，true表示启用。 [附录2]官方示例提供的根目录内hugo.yaml各参数简明含义 基本信息\nbaseurl: 网站的基础URL。 languageCode: 默认语言代码，例如en-us表示英语（美国）。 theme: 使用的主题，在这里是hugo-theme-stack。 title: 网站的标题。 copyright: 网站的版权声明。 语言支持\nDefaultContentLanguage: 设置默认的语言为英语（en）。 hasCJKLanguage: 如果网站主要使用中文、日文或韩文等CJK（中日韩）语言，这个值应设为true，用于正确处理文章摘要和字数统计。 languages: 你可以为网站配置多语言支持。在这个例子中，网站支持英语（en）、中文简体（zh-cn）和阿拉伯语（ar）。每种语言可以有独立的标题和描述。 服务设置\ndisqus: 用于网站评论的服务，Disqus是一个流行的评论系统。如果要启用评论，需要更改为你自己的网站短名称。 googleAnalytics: 如果你使用Google Analytics（谷歌分析）进行流量统计，可以在这里填入你的追踪ID。 分页和永久链接\npagination: 设置分页大小为3，也就是说每页显示3篇文章。 permalinks: 自定义文章和页面的永久链接结构。例如，文章会显示为/p/:slug/。 页面参数\nparams: 包含各种网站布局、显示和功能的配置。比如文章是否显示数学公式、阅读时间、许可信息等。 评论功能\ncomments: 你可以选择不同的评论提供者（如Disqus、Utterances、Gitalk等），通过填入相关的配置信息来启用评论。 菜单和小工具\nmenu: 自定义网站菜单和社交链接。这里包括GitHub和Twitter的社交图标链接。 widgets: 配置主页和页面上的小工具，例如搜索栏、文章归档、标签云等。 其他配置\nopengraph: 配置网站在社交平台（如Twitter）的分享卡片。 colorScheme: 配置网站的颜色模式（自动、浅色或深色）。 imageProcessing: 图片处理选项，例如封面图片和内容图片。 相关内容\nrelated: 配置文章之间的相关性推荐，基于标签和分类等条件。 Markdown 渲染\nmarkup: 配置如何处理Markdown内容，例如表格、代码高亮、目录等。 两篇附录仅供参考，可能有错误\n","date":"2024-10-06T00:00:00Z","image":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu9262121530157302112.jpg","permalink":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/","title":"Hugo+Github Pages搭建静态网站作为个人博客(2)"},{"content":"长沙 宣城 合肥 桂林 ","date":"2024-10-06T00:00:00Z","image":"http://localhost:1313/p/tim-cnt-1/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/tim-cnt-1/","title":"TIM -\u003e CNT= -1"}]