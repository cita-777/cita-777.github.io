[{"content":"第一章：Python基础与快速入门 Python 是一门跨平台、开源、免费的解释型高级动态编程语言。\npython 同时支持伪编译将 Python 源程序转换为字节码来优化程序和提高运行速度。\n支持使用 py2exe、pyinstaller 或 cx_Freeze 工具将 Python 程序转换为二进制可执行文件。\nPython 支持命令式编程（How to do）、函数式编程（What to do），完全支持面向对象程序设计\n注：这里所谓的命令式编程和函数式编程其实很好理解，下面的例子：\n命令式编程：\n1 2 3 4 5 6 7 8 # 初始化变量 count = 0 # 命令式地执行一系列操作 for i in range(10): count += i # 修改状态 print(count) # 输出结果 函数式编程：\n1 2 3 4 5 6 7 8 9 # 定义一个函数来计算两个数的和 def add(a, b): return a + b # 使用这个函数来计算3和5的和 result = add(3, 5) # 打印结果 print(result) # 输出: 8 胶水语言：可以把多种不同语言编写的程序融合到一起实现无缝拼接，更好地发挥不同语言和工具的优势，满足不同应用领域的需求。\nPython 几个重要的网站：\nhttps://www.python.org/\nhttps://www.python.org/doc/\nhttp://bugs.python.org/\nhttps://hackerone.com/python\nhttp://stackoverflow.com/questions/tagged/python\n这里忽略了 python 的安装与环境的配置，我使用的 Jupyter Notebook 进行 python 程序的编写。\n基础知识 Python 对象模型 对象是 python 中****最基本的概念，在 python 中处理的一切都是对象。\n包含许多内置对象可直接使用，如数字、字符串、列表、del 等；\n非内置对象需要导入模块才能使用，如正弦函数 sin (x)，随机数产生函数 random ( ) 等。\n对象类型 类型名称 示例 简要说明 数字 int, float, complex 1234, 3.14, 1.3e5, 3+4j 数字大小没有限制，内置支持复数及其运算 字符串 str ‘swfu’, “I’m student”, ”’Python ”’, r’abc’, R’bcd’ 使用单引号、双引号、三引号作为定界符，以字母 r 或 R 引导的表示原始字符串 字节串 bytes b’hello world’ 以字母 b 引导，可以使用单引号、双引号、三引号作为定界符 列表 list [1, 2, 3]，[‘a’, ‘b’, [‘c’, 2]] 所有元素放在一对方括号中，元素之间使用逗号分隔，其中的元素可以是任意类型 字典 dict {1:’food’ ,2:’taste’, 3:’import’} 所有元素放在一对大括号中，元素之间使用逗号分隔，元素形式为 “键**:** 值” 元组 tuple (2, -5, 6), (3,) 不可变，所有元素放在一对圆括号中，元素之间使用逗号分隔，如果元组中只有一个元素的话，后面的逗号不能省略 集合 set frozenset {‘a’, ‘b’, ‘c’} 所有元素放在一对大括号中，元素之间使用逗号分隔，元素不允许重复 ; 另外，set 是可变的，而 frozenset 是不可变的 字符串（string） 定义：字符串是由 Unicode 字符组成的序列，用于处理文本数据。\n特性\n：\n可以包含各种语言的字符。 不可变，即创建后不能更改其中的元素。 在 Python 3 中，所有的字符串默认都是 Unicode 字符串，所以前缀 u 或 U 不再需要。不过，仍然可以通过前缀 u 或 U 来表示一个 Unicode 字符串（例如 u\u0026quot;Hello\u0026quot;），但这在 Python 3 中并不是必需的。 用途：字符串通常用于表示和处理人类可读的文本信息，如文字、数字、符号等。\n字节串（bytes） 定义：字节串是由 0~255 范围内的整数（即 8 位字节）构成的序列，用于在程序中处理二进制数据。\n特性\n：\n可以包含 ASCII 字符或其他编码的字节。 不可变，即一旦创建了一个字节串，就不能修改它。 在 Python 中，可以通过前缀 b 或 B 来表示一个字节串（例如 b\u0026quot;Hello\u0026quot;）。 用途：字节串通常用于处理非文本数据，如文件内容、网络数据、图像、音频等二进制数据。\n主要区别 编码方式：字符串使用 Unicode 编码，可以包含任何语言的字符；而字节串使用 bytes 编码，通常包含 ASCII 字符或其他特定编码的字节。 存储与表示：字符串以文本形式存储和表示，便于人类阅读和编辑；字节串则以二进制形式存储和表示，更适合计算机处理和传输。 用途差异：字符串主要用于处理文本信息；而字节串则主要用于处理二进制数据，如文件读写、网络通信等场景。 转换方法 字符串转字节串：可以使用字符串的.encode() 方法将其编码为字节串。例如，string.encode('utf-8') 会将字符串 string 编码为 UTF-8 格式的字节串。 字节串转字符串：可以使用字节串的.decode() 方法将其解码为字符串。例如，bytes_data.decode('utf-8') 会将 UTF-8 格式的字节串 bytes_data 解码为字符串。 对象类型 类型名称 示例 简要说明 布尔型 bool True, False 逻辑值，关系运算符、成员测试运算符、同一性测试运算符组成的表达式的值一般为 True 或 False 空类型 NoneType None 空值 异常 Exception、ValueError、TypeError Python 内置大量异常类，分别对应不同类型的异常 文件 f = open(‘data.dat’, ‘rb’) open 是 Python 内置函数，使用指定的模式打开文件，返回文件对象 其他可迭代对象 生成器对象、range 对象、zip 对象、enumerate 对象、map 对象、filter 对象等等 具有惰性求值的特点，除 range 对象之外，其他对象中的元素只能看一次 编程单元 函数（使用 def 定义） 类（使用 class 定义） 模块（类型为 module） 类和函数都属于可调用对象，模块用来集中存放函数、类、常量或其他对象 Python 变量 在 Python 中，不需事先声明变量名及其类型，直接赋值即可创建各种类型的对象变量。这一点适用于 Python 任意类型的对象。\n在 cpp 中，变量在声明时就需要声明变量的类型，而在 python 中则是直接给变量赋值。\nPython 属于强类型编程语言，Python 解释器会根据赋值或运算来自动推断变量类型。Python 还是一种动态类型语言，变量的类型也是可以随时变化的。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; x = 3 \u0026gt;\u0026gt;\u0026gt; print(type(x)) #type():查看变量类型 \u0026lt;class \u0026#39;int\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; x = \u0026#39;Hello world.\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(type(x)) \u0026lt;class \u0026#39;str\u0026#39;\u0026gt; \u0026gt;\u0026gt;\u0026gt; isinstance(3, int) #isinstance():测试对象是否是某个类型的实例 True 如果变量出现在赋值运算符或复合赋值运算符（例如 +=、*= 等等）的左边则表示创建变量或修改变量的值，否则表示引用该变量的值\n字符串和元组属于不可变序列，不能通过下标的方式来修改其中的元素值，试图修改元组中元素的值时会抛出异常。\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; x = (1,2,3) \u0026gt;\u0026gt;\u0026gt; x[1] = 5 Traceback (most recent call last): File \u0026#34;\u0026lt;pyshell#7\u0026gt;\u0026#34;, line 1, in \u0026lt;module\u0026gt; x[1] = 5 TypeError: \u0026#39;tuple\u0026#39; object does not support item assignment python 中允许多个变量指向同一个值\n1 2 3 4 5 6 x = 3 y = x print(id(x)) print(id(y)) 140729233032040 140729233032040 当修改其中一个变量值后，其内存地址将会变化，但并不影响另一变量\n1 2 3 4 5 x+=6 print(id(x)) print(id(y)) 140729233032424 140729233032040 Python 采用的是基于值的内存管理方式，如果为不同变量赋值为相同值，这个值在内存中只有一份，多个变量指向同一块内存地址。\n1 2 3 4 5 6 7 8 9 x = 3 y = 3 print(id(x)) print(id(y)) 140729233032040 140729233032040 x = [1, 1, 1, 1] id(x[0]) == id(x[1]) True 变量名必须以字母或下划线开头，但以下划线开头的变量在 Python 中有特殊含义；\n变量名中不能有空格以及标点符号（括号、引号、逗号、斜线、反斜线、冒号、句号、问号等）；\n不能使用关键字作变量名，可以导入 keyword 模块后使用 print (keyword.kwlist) 查看所有 Python 关键字 (33 个)；\n1 2 3 import keyword print(keyword.kwlist) [\u0026#39;False\u0026#39;, \u0026#39;None\u0026#39;, \u0026#39;True\u0026#39;, \u0026#39;and\u0026#39;, \u0026#39;as\u0026#39;, \u0026#39;assert\u0026#39;, \u0026#39;async\u0026#39;, \u0026#39;await\u0026#39;, \u0026#39;break\u0026#39;, \u0026#39;class\u0026#39;, \u0026#39;continue\u0026#39;, \u0026#39;def\u0026#39;, \u0026#39;del\u0026#39;, \u0026#39;elif\u0026#39;, \u0026#39;else\u0026#39;, \u0026#39;except\u0026#39;, \u0026#39;finally\u0026#39;, \u0026#39;for\u0026#39;, \u0026#39;from\u0026#39;, \u0026#39;global\u0026#39;, \u0026#39;if\u0026#39;, \u0026#39;import\u0026#39;, \u0026#39;in\u0026#39;, \u0026#39;is\u0026#39;, \u0026#39;lambda\u0026#39;, \u0026#39;nonlocal\u0026#39;, \u0026#39;not\u0026#39;, \u0026#39;or\u0026#39;, \u0026#39;pass\u0026#39;, \u0026#39;raise\u0026#39;, \u0026#39;return\u0026#39;, \u0026#39;try\u0026#39;, \u0026#39;while\u0026#39;, \u0026#39;with\u0026#39;, \u0026#39;yield\u0026#39;] 注（下划线的含义）：\n单下划线 _：\n在交互式环境中，_ 表示上一个表达式的结果。 在循环或迭代中，_ 通常用作一个占位符，表示某个值会被忽略。 1 2 for _ in range(5): print(\u0026#34;Hello, World!\u0026#34;) 双下划线 __：\n类的属性名如果以双下划线开头且不以双下划线结尾（例如，__foo），这会触发名称改写（name mangling）。这意味着该属性会在类被继承时通过特定的方式被重命名，以避免子类意外覆盖父类的属性。 1 2 3 4 5 6 7 8 9 class MyClass: def __init__(self): self.__secret = \u0026#34;hidden\u0026#34; class MySubClass(MyClass): def __init__(self): super().__init__() self.__secret = \u0026#34;not hidden\u0026#34; print(self._MyClass__secret) # 访问父类的隐藏属性 双下划线前缀和后缀 __xxx__：\n这种命名方式通常用于特殊方法或魔术方法（magic methods），这些方法具有特定的含义，并由 Python 解释器在特定情况下调用。例如，__init__ 用于初始化对象，__str__ 用于定义对象的字符串表示等。 1 2 3 4 5 6 class MyClass: def __init__(self, name): self.name = name def __str__(self): return f\u0026#34;MyClass with name {self.name}\u0026#34; 单下划线前缀 _xxx：\n通常用于表示变量或方法是 “受保护的” 或 “内部使用的”，这是一种约定俗成的命名习惯，用于指示这些变量或方法不应该被类的外部直接访问。然而，这并不会引起 Python 解释器的任何强制限制，只是表明了一种使用意图。 1 2 3 class MyClass: def _internal_method(self): print(\u0026#34;This is an internal method.\u0026#34;) 不建议****使用系统内置的模块名、类型名或函数名以及已导入的模块名及其成员名作变量名，这将会改变其类型和含义，可以通过 dir (builtins) 查看所有内置模块、类型和函数；\n变量名对英文字母的****大小写敏感，例如 student 和 Student 是不同的变量。\nPython 中的变量并不直接存储值，而是存储了值的内存地址或者引用，这也是变量类型随时可以改变的原因。\n赋值语句的执行过程是：首先把等号右侧表达式的值计算出来，然后在内存中寻找一个位置把值存放进去，最后创建变量并指向这个内存地址。\nPython 具有自动内存管理功能，对于没有任何变量指向的值，Python 自动将其删除。Python 会跟踪所有的值，并自动删除不再有变量指向的值。\n显式使用 del 命令删除不需要的值或显式关闭不再需要访问的资源，仍是一个好的习惯，同时也是一个优秀程序员的基本素养之一。\nPython 的数字类型 三类：整数类型、浮点类型与复数类型\n整数类型\n・十进制整数如，0、-1、9、123\n・十六进制整数，需要 16 个数字 0、1、2、3、4、5、6、7、8、9、a、b、c、d、e、f 来表示整数，必须以 0x 开头，如 0x10、0xfa、0xabcdef\n・八进制整数，只需要 8 个数字 0、1、2、3、4、5、6、7 来表示整数，必须以 0o 开头，如 0o35、0o11\n・二进制整数，只需要 2 个数字 0、1 来表示整数，必须以 0b 开头如，0b101、0b100\n浮点数类型：浮点数****又称小数\nü15.0、0.37、-11.2、1.2e2、314.15e-2\nPython 内置支持复数类型\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u0026gt;\u0026gt;\u0026gt; a = 3+4j \u0026gt;\u0026gt;\u0026gt; b = 5+6j \u0026gt;\u0026gt;\u0026gt; c = a+b \u0026gt;\u0026gt;\u0026gt; c (8+10j) \u0026gt;\u0026gt;\u0026gt; c.real #查看复数实部 8.0 \u0026gt;\u0026gt;\u0026gt; c.imag #查看复数虚部 10.0 \u0026gt;\u0026gt;\u0026gt; a.conjugate() #返回共轭复数 (3-4j) \u0026gt;\u0026gt;\u0026gt; a*b #复数乘法 (-9+38j) \u0026gt;\u0026gt;\u0026gt; a/b #复数除法 (0.6393442622950819+0.03278688524590165j) Python 3.6.x 开始支持在数字中间位置使用单个下划线作为分隔来提高数字的可读性，类似于数学上使用逗号作为千位分隔符。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 1_000_000 1000000 \u0026gt;\u0026gt;\u0026gt; 1_2_3_4 1234 \u0026gt;\u0026gt;\u0026gt; 1_2 + 3_4j (12+34j) \u0026gt;\u0026gt;\u0026gt; 1_2.3_45 12.345 字符串 n 用单引号、双引号或三引号界定的符号系列称为字符串\nn 单引号、双引号、三单引号、三双引号可以互相嵌套，用来表示复杂字符串\n例如： ‘abc‘、‘123’、‘中国‘、“Python”****、”’Tom said, “Let’s go””’\n字符串属于不可变序列\n空字符串表示为” 或 “”\n三引号”’或””” 表示的字符串可以换行，支持排版较为复杂的字符串；三引号还可以在程序中表示较长的注释。\n字符串的拼接 字符串之间可以通过 + 或 * 进行连接\n加法操作 (+) 将两个字符串连接成为一个新的字符串\n乘法操作 (*) 生成一个由其本身字符串重复连接而成的字符串\nlen () 函数能否返回一个字符串的长度\n字符串的转义 转义字符 含义 转义字符 含义 \\b 退格，把光标移动到前一列位置 \\ 一个斜线 \\ \\f 换页符 *’* 单引号’ \\n 换行符 *”* 双引号” \\r 回车 \\ooo 3 位八进制数对应的字符 \\t 水平制表符 \\xhh 2 位十六进制数对应的字符 \\v 垂直制表符 ****uhhhh 4 位十六进制数表示的 Unicode 字符 字符串界定符前面加字母 r 或 R 表示原始字符串，其中的特殊字符不 进行转义，但字符串的最后一个字符不能是 \\。\n・原始字符串主要用于正则表达式、文件路径或者 URL 的场合。\n运算符和表达式 运算符 功能说明 + 算术加法，列表、元组、字符串合并与连接，正号 – 算术减法，集合差集，相反数 ***** 算术乘法，序列重复 / 真除法 // 求整商，但如果操作数中有实数的话，结果为实数形式的整数 % 求余数，字符串格式化 ** 幂运算 \u0026lt;、\u0026lt;=、\u0026gt;、\u0026gt;=、==、!= （值）大小比较，集合的包含关系比较 or，and, not 逻辑或、逻辑与、逻辑非 in 成员测试 is 对象同一性测试，即测试是否为同一个对象或内存地址是否相同 、^、\u0026amp;、\u0026laquo;、\u0026raquo;、~ 位或、位异或、位与、左移位、右移位、位求反 \u0026amp;、|、^、- 集合交集、并集、对称差集，差集 加法 + 运算符除了用于算术加法外，还可用于列表、元组、字符串的连接，但不支持不同类型的对象之间相加或连接。\n乘法 ***** 运算符不仅可以用于数值乘法，还可以用于列表、字符串、元组等****类型\n当列表、字符串或元组等类型变量与整数进行 “*” 运算时，表示对内容进行重复并返回重复后的新对象。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 2.0 * 3 #浮点数与整数相乘 6.0 \u0026gt;\u0026gt;\u0026gt; (3+4j) * 2 #复数与整数相乘 (6+8j) \u0026gt;\u0026gt;\u0026gt; (3+4j) * (3-4j) #复数与复数相乘 (25+0j) \u0026gt;\u0026gt;\u0026gt; \u0026#34;a\u0026#34; * 10 #字符串重复 \u0026#39;aaaaaaaaaa\u0026#39; 除法 Python 中的除法有两种，“/” 和 “//” 分别表示除法和整除运算。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; 3 / 5 0.6 \u0026gt;\u0026gt;\u0026gt; 3 // 5 0 \u0026gt;\u0026gt;\u0026gt; 3.0 / 5 0.6 \u0026gt;\u0026gt;\u0026gt; 3.0 // 5 0.0 \u0026gt;\u0026gt;\u0026gt; 13 // 10 1 \u0026gt;\u0026gt;\u0026gt; -13 // 10 -2 求余 n**%** 运算符除去可用于字符串格式化之外**，也可对整数和浮点数计算余数。**\n・由于浮点数的精确度影响，计算结果可能略有误差。\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; 3.1 % 2 1.1 \u0026gt;\u0026gt;\u0026gt; 6.3 % 2.1 2.0999999999999996 \u0026gt;\u0026gt;\u0026gt; 6 % 2 0 \u0026gt;\u0026gt;\u0026gt; -17 % 4 3 #余数与%右侧的运算数符号一致 \u0026gt;\u0026gt;\u0026gt; 17 % -4 -3 #(17-(-3))能被(-4)整除 \u0026gt;\u0026gt;\u0026gt; 5.7 % 4.8 0.9000000000000004 关系型运算符 关系运算符可以连用，一般用于同类型对象之间值的大小比较，或者测试集合之间的包含关系\n1 2 3 4 5 6 \u0026gt;\u0026gt;\u0026gt; 1 \u0026lt; 3 \u0026lt; 5 #等价于1 \u0026lt; 3 and 3 \u0026lt; 5 True \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hello\u0026#39; \u0026gt; \u0026#39;world\u0026#39; #比较字符串大小 False \u0026gt;\u0026gt;\u0026gt; \u0026#39;Hello\u0026#39; \u0026gt; 3 #字符串和数字不能比较 TypeError: unorderable types: str() \u0026gt; int() 成员测试运算符 成员测试运算符 in 用于****成员测试\n・即测试一个对象是否为另一个对象的元素。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 5 in range(1, 10, 1) #range()是用来生成指定范围数字的内置函数 True \u0026gt;\u0026gt;\u0026gt; \u0026#39;abc\u0026#39; in \u0026#39;abcdefg\u0026#39; #子字符串测试 True \u0026gt;\u0026gt;\u0026gt; for i in (3, 5, 7): #循环，成员遍历 print(i, end=\u0026#39;\\t\u0026#39;) 3\t5\t7\t位运算符 位运算符只能用于整数，其内部执行过程为：首先将整数转换为二进制数，然后右对齐，必要的时候左侧补 0，按位进行运算，最后再把计算结果转换为十进制数字返回\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; 3 \u0026lt;\u0026lt; 2 #把3左移2位 12 \u0026gt;\u0026gt;\u0026gt; 3 \u0026amp; 7 #位与运算 3 \u0026gt;\u0026gt;\u0026gt; 3 | 8 #位或运算 11 \u0026gt;\u0026gt;\u0026gt; 3 ^ 5 #位异或运算 6 集合的交集、并集、****对称差集等运算借助于位运算符来实现\n而差集则使用减号运算符实现\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} | {3, 4, 5} #并集，自动去除重复元素 {1, 2, 3, 4, 5} \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} \u0026amp; {3, 4, 5} #交集 {3} \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} ^ {3, 4, 5} #对称差集 {1, 2, 4, 5} \u0026gt;\u0026gt;\u0026gt; {1, 2, 3} - {3, 4, 5} #差集 {1, 2} and or and 和 or 具有惰性求值特点，只计算必须计算的****表达式\n1 2 \u0026gt;\u0026gt;\u0026gt; 3\u0026gt;5 and a\u0026gt;3 False 注意，此时并没有定义变量 a，and 要两者都对返回对，而第一位的 3\u0026gt;5 已经判断是错的了，这里直接返回错，不会再对后面的 a\u0026gt;3 进行执行。\n1 2 \u0026gt;\u0026gt;\u0026gt; 3\u0026gt;5 or a\u0026gt;3 NameError: name \u0026#39;a\u0026#39; is not defined 3\u0026gt;5 的值为 False，所以需要计算后面表达式。\n1 2 \u0026gt;\u0026gt;\u0026gt; 3\u0026lt;5 or a\u0026gt;3 True 3\u0026lt;5 的值为 True，不需要计算后面表达式。这里是与 and 类似的惰性，or 只要两者中有一个是正确的，则返回正确，这里的 3\u0026lt;5 是对的，or 的代码将不会执行。\n这里比较让人迷惑的是下面这个程序：\n1 2 3 a = 1 a == 1 or (a+1) == 2 print(a) 这里返回的结果是 1，因为 or 后面的程序没有执行。\n1 2 \u0026gt;\u0026gt;\u0026gt; 3 and 5 5 and 是将最后一个计算的表达式的值作为整个表达式的值。\n1 2 3 and 5\u0026gt;2 True or 也类似\n1 2 \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt; 2 or 4 4 比较特殊的是 is not，它只能返回 true 或者 false\n1 2 \u0026gt;\u0026gt;\u0026gt; 3 is not 5 True Python 中单个任何类型的对象或常数属于合法表达式，使用运算符连接的变量和常量以及函数调用的任意组合也属于合法的表达式\n特殊说明 逗号并不是运算符，只是一个普通分隔符\n1 2 3 4 5 \u0026gt;\u0026gt;\u0026gt; x = 3, 5 \u0026gt;\u0026gt;\u0026gt; x (3, 5) \u0026gt;\u0026gt;\u0026gt; 3==3, 5 (True, 5) 逗号（,）在 Python 中用于创建元组（tuple）。当你使用逗号分隔多个值或表达式时，Python 会将这些值或表达式组合成一个元组。\nPython 不支持 ++ 和–运算符，虽然在形式上有时似乎可这样用，但实际上是另外的含义\n1 2 3 4 5 6 7 8 9 \u0026gt;\u0026gt;\u0026gt; i = 3 \u0026gt;\u0026gt;\u0026gt; ++i 3 #正正得正 \u0026gt;\u0026gt;\u0026gt; i++ #Python不支持++运算符，语法错误 SyntaxError: invalid syntax \u0026gt;\u0026gt;\u0026gt; --i #负负得正 3 \u0026gt;\u0026gt;\u0026gt; -(-i) #与--i等价 3 常用内置函数 内置函数不需要导入任何模块即可使用\n执行下面的命令可以列出所有内置函数\n1 2 3 4 5 dir (__builtins__) 函数 功能简要说明 abs(x) 返回数字 x 的绝对值或复数 x 的模 all(iterable) 如果对于可迭代对象中所有元素 x 都等价于 True，也就是对于所有元素 x 都有 bool (x) 等于 True，则返回 True。对于空的可迭代对象也返回 True any(iterable) 只要可迭代对象 iterable 中存在元素 x 使得 bool (x) 为 True，则返回 True。对于空的可迭代对象，返回 False ascii(obj) 把对象转换为 ASCII 码表示形式，必要的时候使用转义字符来表示特定的字符 bin(x) 把整数 x 转换为二进制串表示形式 bool(x) 返回与 x 等价的布尔值 True 或 False bytes(x) 生成字节串，或把指定对象 x 转换为字节串表示形式 callable(obj) 测试对象 obj 是否可调用。类和函数是可调用的，包含__call__() 方法的类的对象也是可调用的 compile() 用于把 Python 代码编译成可被 exec () 或 eval () 函数执行的代码对象 complex(real, [imag]) 返回复数 chr(x) 返回 Unicode 编码为 x 的字符 函数 功能简要说明 delattr(obj, name) 删除属性，等价于 del obj.name dir(obj) 返回指定对象或模块 obj 的成员列表，如果不带参数则返回当前作用域内所有标识符 divmod(x, y) 返回包含整商和余数的元组 ((x-x% y)/y, x% y) enumerate(iterable[, start]) 返回包含元素形式为 (0, iterable [0]), (1, iterable [1]), (2, iterable [2]), … 的迭代器对象 eval(s[, globals[, locals]]) 计算并返回字符串 s 中表达式的值 exec(x) 执行代码或代码对象 x exit() 退出当前解释器环境 filter(func, seq) 返回 filter 对象，其中包含序列 seq 中使得单参数函数 func 返回值为 True 的那些元素，如果函数 func 为 None 则返回包含 seq 中等价于 True 的元素的 filter 对象 float(x) 把整数或字符串 x 转换为浮点数并返回 frozenset([x])) 创建不可变的集合对象 getattr(obj, name[, default]) 获取对象中指定属性的值，等价于 obj.name，如果不存在指定属性则返回 default 的值，如果要访问的属性不存在并且没有指定 default 则抛出异常 函数 功能简要说明 globals() 返回包含当前作用域内全局变量及其值的字典 hasattr(obj, name) 测试对象 obj 是否具有名为 name 的成员 hash(x) 返回对象 x 的哈希值，如果 x 不可哈希则抛出异常 help(obj) 返回对象 obj 的帮助信息 hex(x) 把整数 x 转换为十六进制串 id(obj) 返回对象 obj 的标识（内存地址） input ([提示]) 显示提示，接收键盘输入的内容，返回字符串 int(x[, d]) 返回实数（float）、分数（Fraction）或高精度实数（Decimal）x 的整数部分，或把 d 进制的字符串 x 转换为十进制并返回，d 默认为十进制 isinstance(obj, class-or-type-or-tuple) 测试对象 obj 是否属于指定类型（如果有多个类型的话需要放到元组中）的实例 iter(…) 返回指定对象的可迭代对象 len(obj) 返回对象 obj 包含的元素个数，适用于列表、元组、集合、字典、字符串以及 range 对象和其他可迭代对象 函数 功能简要说明 list([x])、set([x])、tuple([x])、dict([x]) 把对象 x 转换为列表、集合、元组或字典并返回，或生成空列表、空集合、空元组、空字典 locals() 返回包含当前作用域内局部变量及其值的字典 map(func, *iterables) 返回包含若干函数值的 map 对象，函数 func 的参数分别来自于 iterables 指定的每个迭代对象， max(x)、 min(x) 返回可迭代对象 x 中的最大值、最小值，要求 x 中的所有元素之间可比较大小，允许指定排序规则和 x 为空时返回的默认值 next(iterator[, default]) 返回可迭代对象 x 中的下一个元素，允许指定迭代结束之后继续迭代时返回的默认值 oct(x) 把整数 x 转换为八进制串 open(name[, mode]) 以指定模式 mode 打开文件 name 并返回文件对象 ord(x) 返回 1 个字符 x 的 Unicode 编码 pow(x, y, z=None) 返回 x 的 y 次方，等价于 x ** y 或 (x ** y) % z print(value, …, sep=’ ‘, end=’\\n’, file = sys. stdout, flush=False) 基本输出函数 quit() 退出当前解释器环境 range([start,] end [, step] ) 返回 range 对象，其中包含左闭右开区间 [start,end) 内以 step 为步长的整数 函数 功能简要说明 repr(obj) 返回对象 obj 的规范化字符串表示形式，对于大多数对象有 eval (repr (obj))==obj reversed(seq) 返回 seq（可以是列表、元组、字符串、range 以及其他可迭代对象）中所有元素逆序后的迭代器对象 round (x [, 小数位数]) 对 x 进行四舍五入，若不指定小数位数，则返回整数 sorted(iterable, key=None, reverse=False) 返回排序后的列表，其中 iterable 表示要排序的序列或迭代对象，key 用来指定排序规则或依据，reverse 用来指定升序或降序。该函数不改变 iterable 内任何元素的顺序 str(obj) 把对象 obj 直接转换为字符串 sum(x, start=0) 返回序列 x 中所有元素之和，返回 start+sum (x) type(obj) 返回对象 obj 的类型 zip(seq1 [, seq2 […]]) 返回 zip 对象，其中元素为 (seq1 [i], seq2 [i], …) 形式的元组，最终结果中包含的元素个数取决于所有参数序列或可迭代对象中最短的那个 重点： 输入函数：input( )\n・可输入数字、字符串和其它任意类型对象，返回结果都是字符串。\n**输出函数：**print () 函数进行输出。\nbin ()、oct ()、hex () 用来将整数转换为二进制、八进制和十六进制形式，这三个函数都要求参数必须为整数。\neval (\u0026lt;字符串\u0026gt;) 函数能够以 Python 表达式的方式解析并执行字符串，将返回结果输出\nrange**()** 语法格式为 range**([start,] end [, step] )****，返回具有惰性求值特点的**\nrange 对象，其中包含左闭右开区间 [start,end) 内以 step 为步长的整数。\n1 2 3 4 5 6 7 8 \u0026gt;\u0026gt;\u0026gt; range(5) #start默认为0，step默认为1 range(0, 5) \u0026gt;\u0026gt;\u0026gt; list(_) [0, 1, 2, 3, 4] \u0026gt;\u0026gt;\u0026gt; list(range(1, 10, 2)) #指定起始值和步长 [1, 3, 5, 7, 9] \u0026gt;\u0026gt;\u0026gt; list(range(9, 0, -2)) #步长为负数时，start应比end大 [9, 7, 5, 3, 1] ord() 和 chr**()** 是一对功能相反的****函数：ord() 用来返回单个字符的序数或 Unicode 码，而 chr**()** 则用来返回某序数对应的****字符\nstr**()** 则直接将其任意类型参数转换为字符串**。**\nmax ()、min ()、sum () 这三个内置函数分别用于计算列表、元组或其他可迭代对象中所有元素最大值、最小值以及所有元素之和\n内置函数 type () 和 isinstance () 可以判断数据类型。\nsorted () 对列表、元组、字典、集合或其他可迭代对象进行排序并返回新列表。\nzip () 函数用来把多个可迭代对象中的元素压缩到一起，返回一个可迭代的 zip 对象，其中每个元素都是包含原来的多个可迭代对象对应位置上元素的元组，如同拉拉链一样。\nzip 函数用于将可迭代对象作为参数，将对象中对应的元素打包成一个元组，然后返回由这些元组组成的列表。\n1 2 3 \u0026gt;\u0026gt;\u0026gt; x = zip(\u0026#39;abcd\u0026#39;, \u0026#39;1234\u0026#39;) \u0026gt;\u0026gt;\u0026gt; list(x) [(\u0026#39;a\u0026#39;, \u0026#39;1\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;2\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;3\u0026#39;), (\u0026#39;d\u0026#39;, \u0026#39;4\u0026#39;)] zip (*) 是解压\n内置函数 filter () 将一个单参数函数作用到一个序列上，返回该序列中使得该函数返回值为 True 的那些元素组成的 filter 对象，如果指定函数为 None，则返回序列中等价于 True 的元素。\n1 2 3 \u0026gt;\u0026gt;\u0026gt; seq = [\u0026#39;foo\u0026#39;, \u0026#39;x41\u0026#39;, \u0026#39;?!\u0026#39;, \u0026#39;***\u0026#39;] \u0026gt;\u0026gt;\u0026gt; list(filter(str.isalnum, seq)) [\u0026#39;foo\u0026#39;, \u0026#39;x41\u0026#39;] enumerate () 函数用来枚举可迭代对象中的元素，返回可迭代的 enumerate 对象，其中每个元素都是包含索引和值的元组。\nnmap、filter、enumerate、zip 等对象不仅具有惰性求值的特点，还有另外一个特点：访问过的元素不可再次访问。\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; x = map(str, range(10)) \u0026gt;\u0026gt;\u0026gt; list(x) [\u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;] \u0026gt;\u0026gt;\u0026gt; list(x) [] \u0026gt;\u0026gt;\u0026gt; x = map(str, range(10)) \u0026gt;\u0026gt;\u0026gt; \u0026#39;2\u0026#39; in x True \u0026gt;\u0026gt;\u0026gt; \u0026#39;2\u0026#39; in x False 对象的删除 reversed () 对可迭代对象（生成器对象和具有惰性求值特性的 zip、map、filter、enumerate 等类似对象除外）进行翻转（首尾交换）并返回可迭代的 reversed 对象。\nPython **具有自动内存管理功能，**Python 解释器会跟踪所有的值，一旦发现某个值不再有任何变量指向，将会自动删除该值。\n显式释放自己申请的资源是程序员的好习惯之一，也是程序员素养的重要体现之一**。del 命令：显式删除对象并解除与值之间的指向关系。**\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026gt;\u0026gt;\u0026gt; y = 3 \u0026gt;\u0026gt;\u0026gt; z = y \u0026gt;\u0026gt;\u0026gt; print(y) 3 \u0026gt;\u0026gt;\u0026gt; del y #删除对象 \u0026gt;\u0026gt;\u0026gt; print(y) NameError: name \u0026#39;y\u0026#39; is not defined \u0026gt;\u0026gt;\u0026gt; print(z) 3 \u0026gt;\u0026gt;\u0026gt; del z \u0026gt;\u0026gt;\u0026gt; print(z) NameError: name \u0026#39;z\u0026#39; is not defined del 命令无法删除元组或字符串中的元素，只可以删除整个元组或字符串 因为这两者均属于不可变序列。\n主要参考课堂ppt总结，仅供参考，可能有误\n","date":"2024-11-02T00:00:00Z","image":"http://localhost:3515/p/python%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A11/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:3515/p/python%E8%AF%AD%E8%A8%80%E4%B8%8E%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A11/","title":"Python语言与系统设计(1)"},{"content":"动态规划（Dynamic Programming） 动态规划问题的一般形式就是求最值。动态规划其实是运筹学的一种最优化方法，只不过在计算机问题上应用比较多，比如说让你求最长递增子序列呀，最小编辑距离呀等等。\n动态规划的核心思想就是穷举求最值，列出正确的「状态转移方程」，才能正确地穷举。而且，你需要判断算法问题是否具备「最优子结构」，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题存在「重叠子问题」。\n首先，明确「状态」-\u0026gt; 明确「选择」 -\u0026gt; 定义 dp 数组/函数的含义。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # 自顶向下递归的动态规划 def dp(状态1, 状态2, ...): for 选择 in 所有可能的选择: # 此时的状态已经因为做了选择而改变 result = 求最值(result, dp(状态1, 状态2, ...)) return result # 自底向上迭代的动态规划 # 初始化 base case dp[0][0][...] = base case # 进行状态转移 for 状态1 in 状态1的所有取值： for 状态2 in 状态2的所有取值： for ... dp[状态1][状态2][...] = 求最值(选择1，选择2...) 子矩阵的最大和问题 以LeetCode面试题 17.24. 最大子矩阵举例\n给定一个正整数和负整数组成的 N × M 矩阵，编写代码找出元素总和最大的子矩阵。返回一个子矩阵左上角的行号和列号，右下角的行号和列号。若有多个满足条件的子矩阵，返回任意一个均可。\n我们将二维转化为一维，对于矩阵的每一列，我们将其加在一起，成为了一维上的一个数，二维矩阵的和转化为了一维数组的和，如下图。\n转化为求最大子序列和之后，假设给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。我们该如何解决呢？ **1、状态定义：**dp[i]为以nums[i]结尾的最大子序和 **2、状态转移方程：**对于nums[i]有两种情况:一种是和前一个位置的子序列连着$dp[i]=dp[i-1]+nums[i]$。第二种是以自己独立门户，从自己开始$dp[i]=nums[i]$。取其中最大值,可得状态转移方程为$dp[i]=max( dp[i-1] + nums[i] , nums[i] )$ 3、basecase:$dp[0]=nums[0]$\n观察发现，dp[i]只与dp[i-1]和nums[i]有关，所有我们可以将空间复杂度降到O(1) 同时对于$dp[i]=max(dp[i-1]+nums[i],nums[i])$,两种情况都加了nums[i]，只是前面多加了dp[i-1]，所有很容易推出，当dp[i-1]\u0026lt;0时，后者大，反之前者大\n问题迎刃而解，题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 /** * @author: Juncker chan * @date: 2024.10.25 * @details: 子矩阵的最大和问题 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: int getMaxMatrixSum(vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt;\u0026amp; matrix) { int maxsum = INT_MIN; int dp_i; int maxRow = matrix.size(); int maxCol = matrix[0].size(); vector\u0026lt;int\u0026gt; b(maxCol, 0); //记录当前i~j行组成大矩阵的每一列的和，将二维转化为一维 int row,col;//临时记录左上角行列坐标 vector\u0026lt;int\u0026gt; pos(4);//记录左上角和右下角最终坐标 for (int i = 0; i \u0026lt; maxRow; i++) { //以i为上边，从上而下扫描 b.assign(maxCol, 0); //每次更换子矩形上边，就要清空b，重新计算每列的和 //子矩阵的下边往下移动变长，从i到maxROw-1， for (int j = i; j \u0026lt; maxRow; j++) { //已转换为求连续最大子序列和，一下就相当于求一次最大子序列和 dp_i = 0; for (int k = 0; k \u0026lt; maxCol; k++) { b[k] += matrix[j][k]; //我们只是不断增加其高，也就是下移矩阵下边，所有这个矩阵每列的和只需要加上新加的哪一行的元素 if (dp_i \u0026gt; 0) { dp_i += b[k]; } else { dp_i = b[k]; //新起一个点时保存这个点为临时左上角坐标 row=i; col=k; } if(dp_i\u0026gt;maxsum) { maxsum=dp_i; //更新最大子矩阵后更新最终左上角和右下角坐标 pos[0]=row; pos[1]=col; pos[2]=j; pos[3]=k; } } } } cout\u0026lt;\u0026lt;pos[0]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos[1]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos[2]\u0026lt;\u0026lt;\u0026#34; \u0026#34;\u0026lt;\u0026lt;pos[3]\u0026lt;\u0026lt;endl; return maxsum; } }; int main() { vector\u0026lt;vector\u0026lt;int\u0026gt;\u0026gt; matrix = { {0, -2, -7, 0}, {9, 2, -6, 2}, {-4, 1, -4, 1}, {-1, 8, 0, -2} }; Solution sol; int maxSum = sol.getMaxMatrixSum(matrix); cout \u0026lt;\u0026lt; \u0026#34;子矩阵中和的最大值是: \u0026#34; \u0026lt;\u0026lt; maxSum \u0026lt;\u0026lt; endl; return 0; } 回溯算法（DFS） 回溯算法就是个多叉树的遍历问题，关键就是在前序遍历和后序遍历的位置做一些操作，算法框架如下：\n1 2 3 4 5 6 7 8 9 10 result = [] def backtrack(路径, 选择列表): if 满足结束条件: result.add(路径) return for 选择 in 选择列表: 做选择 backtrack(路径, 选择列表) 撤销选择 写 backtrack 函数时，需要维护走过的「路径」和当前可以做的「选择列表」，当触发「结束条件」时，将「路径」记入结果集。\nN皇后 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 /** * @author: Juncker chan * @date: 2024.10.24 * @details: n皇后问题 **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; class Solution { public: vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; res; bool isValid(vector\u0026lt;string\u0026gt; \u0026amp;board, int row, int col) { int n = board.size(); // 检查列是否有皇后互相冲突 for (int i = 0; i \u0026lt;= row; i++) { if (board[i][col] == \u0026#39;Q\u0026#39;) { return false; } } // 检查右上方是否有皇后互相冲突 for (int i = row - 1, j = col + 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026lt; n; i--, j++) { if (board[i][j] == \u0026#39;Q\u0026#39;) { return false; } } // 检查左上方是否有皇后互相冲突 for (int i = row - 1, j = col - 1; i \u0026gt;= 0 \u0026amp;\u0026amp; j \u0026gt;= 0; i--, j--) { if (board[i][j] == \u0026#39;Q\u0026#39;) { return false; } } return true; } // 路径：board 中小于 row 的那些行都已经成功放置了皇后 // 选择列表：第 row 行的所有列都是放置皇后的选择 // 结束条件：row 超过 board 的最后一行 void backTrack(vector\u0026lt;string\u0026gt; \u0026amp;board, int row) { // 触发结束条件 if (row == board.size()) { res.push_back(board); return; } int max_col = board[row].size(); for (int col = 0; col \u0026lt; max_col; col++) { if (!isValid(board, row, col)) continue; // 做选择 board[row][col] = \u0026#39;Q\u0026#39;; backTrack(board, row + 1); board[row][col] = \u0026#39;.\u0026#39;; // 撤销选择 } } vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; solveNQueens(int n) { vector\u0026lt;string\u0026gt; board(n, string(n, \u0026#39;.\u0026#39;)); backTrack(board, 0); return res; } }; int main() { Solution solution; int n; cout \u0026lt;\u0026lt; \u0026#34;输入N: \u0026#34;; cin \u0026gt;\u0026gt; n; vector\u0026lt;vector\u0026lt;string\u0026gt;\u0026gt; results = solution.solveNQueens(n); cout \u0026lt;\u0026lt; \u0026#34;可能解如下:\u0026#34; \u0026lt;\u0026lt; endl; for (vector\u0026lt;string\u0026gt; \u0026amp;arrangement : results) { for (string \u0026amp;row : arrangement) { cout \u0026lt;\u0026lt; row \u0026lt;\u0026lt; endl; } cout \u0026lt;\u0026lt; endl; } return 0; } 动态规划的三个需要明确的点就是「状态」「选择」和「base case」，其实就对应着走过的「路径」，当前的「选择列表」和「结束条件」。\n广搜算法（BFS） 单向BFS BFS问题的本质就是让你在一幅「图」中找到从起点 start 到终点 target 的最近距离。\n这个广义的描述可以有各种变体，比如走迷宫，有的格子是围墙不能走，从起点到终点的最短距离是多少，如果加上这个迷宫带「传送门」可以瞬间传送的条件呢？比如说两个单词，要求你通过某些替换，把其中一个变成另一个，每次只能替换一个字符，最少要替换几次？再比如说连连看游戏，两个方块消除的条件不仅仅是图案相同，还得保证两个方块之间的最短连线不能多于两个拐点。你玩连连看，点击两个坐标，游戏是如何判断它俩的最短连线有几个拐点的？\n本质上看这些问题都没有区别，就是一幅「图」，让你从一个起点，走到终点，问最短路径。这就是 BFS 的本质。\n算法框架如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 int BFS(Node start, Node target) { queue\u0026lt;Node\u0026gt; q; set\u0026lt;Node\u0026gt; visited; q.push(start); visited.insert(start); while (!q.empty()) { int sz = q.size(); for (int i = 0; i \u0026lt; sz; i++) { Node cur = q.front(); q.pop(); if (cur == target) return step; for (Node x : cur.adj()) { if (visited.count(x) == 0) { q.push(x); visited.insert(x); } } } } // 如果走到这里，说明在图中没有找到目标节点 } BFS 的核心数据结构：cur.adj() 泛指 cur 相邻的节点，比如说二维数组中，cur 上下左右四面的位置就是相邻节点；visited 的主要作用是防止走回头路，大部分时候都是必须的，但是像一般的二叉树结构，没有子节点到父节点的指针，不会走回头路就不需要 visited。\n双向BFS 传统的 BFS 框架就是从起点开始向四周扩散，遇到终点时停止；而双向 BFS 则是从起点和终点同时开始扩散，当两边有交集的时候停止。不过双向 BFS 也有局限，因为你必须知道终点在哪里，如下图：\n无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的，只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点。\n解开密码锁的最少次数 LeetCode752.打开转盘锁\n分析题目，首先要思考设计一个算法，穷举所有可能的密码组合，其次才是考虑deadends 和 target 的限制**\n总共有 4 个位置，每个位置可以向上转，也可以向下转，共8种可能。比如说从 \u0026quot;0000\u0026quot; 开始，转一次，可以穷举出 \u0026quot;1000\u0026quot;, \u0026quot;9000\u0026quot;, \u0026quot;0100\u0026quot;, \u0026quot;0900\u0026quot;... 共 8 种密码。然后，再以这 8 种密码作为基础，对每个密码再转一下，穷举出所有可能\u0026hellip;\n这可以抽象成一幅图，每个节点有 8 个相邻的节点，又让你求最短距离，成功转化为BFS问题。\n限制条件呢？只需要两个以哈希表为底层实现的无序集合记录visited和deads就可以了。\n题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 class Solution { public: int openLock(vector\u0026lt;string\u0026gt;\u0026amp; deadends, string target) { // 记录需要跳过的死亡密码 unordered_set\u0026lt;string\u0026gt; deads(deadends.begin(), deadends.end()); // 记录已经穷举过的密码，防止走回头路 unordered_set\u0026lt;string\u0026gt; visited; queue\u0026lt;string\u0026gt; q; // 从起点开始启动广度优先搜索 int step = 0; q.push(\u0026#34;0000\u0026#34;); visited.insert(\u0026#34;0000\u0026#34;); while (!q.empty()) { int sz = q.size(); // 将当前队列中的所有节点向周围扩散 for (int i = 0; i \u0026lt; sz; i++) { string cur = q.front(); q.pop(); // 判断是否到达终点 if (deads.count(cur)) continue; if (cur == target) return step; // 将一个节点的未遍历相邻节点加入队列 for (int j = 0; j \u0026lt; 4; j++) { string up = plusOne(cur, j); if (!visited.count(up)) { q.push(up); visited.insert(up); } string down = minusOne(cur, j); if (!visited.count(down)) { q.push(down); visited.insert(down); } } } // 在这里增加步数 step++; } // 如果穷举完都没找到目标密码，那就是找不到了 return -1; } // 将 s[j] 向上拨动一次 string plusOne(string s, int j) { s[j] = s[j] == \u0026#39;9\u0026#39; ? \u0026#39;0\u0026#39; : s[j] + 1; return s; } // 将 s[i] 向下拨动一次 string minusOne(string s, int j) { s[j] = s[j] == \u0026#39;0\u0026#39; ? \u0026#39;9\u0026#39; : s[j] - 1; return s; } }; BFS 可以找到最短距离，但是空间复杂度高，而 DFS 的空间复杂度较低。\n还是拿刚才我们处理二叉树问题的例子，假设给你的这个二叉树是满二叉树，节点数为 N，对于 DFS 算法来说，空间复杂度无非就是递归堆栈，最坏情况下顶多就是树的高度，也就是 O(logN)O(log**N)。\n但是你想想 BFS 算法，队列中每次都会储存着二叉树一层的节点，这样的话最坏情况下空间复杂度应该是树的最底层节点的数量，也就是 N/2，用 Big O 表示的话也就是 O(N)O(N)。\n由此观之，BFS 还是有代价的，一般来说在找最短路径的时候使用 BFS，其他时候还是 DFS 使用得多一些（主要是递归代码好写）。\n二分查找（BinarySearch） 最常用的二分查找场景：寻找一个数、寻找左侧边界、寻找右侧边界。以下为最基础框架：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 int binarySearch(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size() - 1; while (...) { int mid = left + (right - left) / 2; if (nums[mid] == target) { ... } else if (nums[mid] \u0026lt; target) { left = ... } else if (nums[mid] \u0026gt; target) { right = ... } } } 小细节：$left + (right - left) / 2$ 就和 $(left + right) / 2$ 的结果相同，但是有效防止了 left 和 right 太大，直接相加导致溢出的情况。\n最基本的二分查找算法：\n1 2 3 4 5 6 7 因为我们初始化 right = nums.length - 1 所以决定了我们的「搜索区间」是 [left, right] 所以决定了 while (left \u0026lt;= right) 同时也决定了 left = mid+1 和 right = mid-1 因为我们只需找到一个 target 的索引即可 所以当 nums[mid] == target 时可以立即返回 寻找左侧边界的二分查找：\n1 2 3 4 5 6 7 8 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最左侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧右侧边界以锁定左侧边界 寻找右侧边界的二分查找：\n1 2 3 4 5 6 7 8 9 10 11 因为我们初始化 right = nums.length 所以决定了我们的「搜索区间」是 [left, right) 所以决定了 while (left \u0026lt; right) 同时也决定了 left = mid + 1 和 right = mid 因为我们需找到 target 的最右侧索引 所以当 nums[mid] == target 时不要立即返回 而要收紧左侧边界以锁定右侧边界 又因为收紧左侧边界时必须 left = mid + 1 所以最后无论返回 left 还是 right，必须减一 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 int binary_search(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size()-1; while(left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if(nums[mid] == target) { // 直接返回 return mid; } } // 直接返回 return -1; } int left_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size()-1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定左侧边界 right = mid - 1; } } // 判断 target 是否存在于 nums 中 if (left \u0026lt; 0 || left \u0026gt;= nums.size()) { return -1; } // 判断一下 nums[left] 是不是 target return nums[left] == target ? left : -1; } int right_bound(vector\u0026lt;int\u0026gt;\u0026amp; nums, int target) { int left = 0, right = nums.size()-1; while (left \u0026lt;= right) { int mid = left + (right - left) / 2; if (nums[mid] \u0026lt; target) { left = mid + 1; } else if (nums[mid] \u0026gt; target) { right = mid - 1; } else if (nums[mid] == target) { // 别返回，锁定右侧边界 left = mid + 1; } } // 由于 while 的结束条件是 right == left - 1，且现在在求右边界 // 所以用 right 替代 left - 1 更好记 if (right \u0026lt; 0 || right \u0026gt;= nums.size()) { return -1; } return nums[right] == target ? right : -1; } 模拟与密码类问题 UVA508：Morse Mismatches Problem\n密码题中的模拟题，题目很长其实不算难，使用两个以哈希表为底层的字典存储映射即可，注释很详细。主要流程就是逐个匹配单词计算最小差异，根据最小差异的不同if_else出各种结果就行了。\n题解如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 /** * @author: Juncker chan * @date: 2024.10.28 * @details: Morse Mismatches Problem **/ #include \u0026lt;bits/stdc++.h\u0026gt; using namespace std; map\u0026lt;char, string\u0026gt; morse_map; // 字符到摩尔斯电码的映射 map\u0026lt;string, string\u0026gt; word_dict; // 单词及其摩尔斯电码表示的字典 // 计算两个摩尔斯电码字符串 morse_input 和 morse_code 之间的差异 // 如果它们完全相同，返回0；如果 morse_input 是 morse_code 的前缀，返回长度差异；否则返回 INT_MAX int calculate_diff(string\u0026amp; morse_input, string\u0026amp; morse_code) { if (morse_input == morse_code) return 0; // 完全匹配 if (morse_input.size() \u0026gt; morse_code.size()) return INT_MAX; // 如果 `morse_input` 更长，不可能是前缀 if (morse_input == morse_code.substr(0, morse_input.size())) return morse_code.size() - morse_input.size(); // 前缀匹配 return INT_MAX; // 没有匹配 } // 找到与给定摩尔斯电码 `morse_input` 最接近的匹配单词 string find_best_match(string\u0026amp; morse_input) { string best_match = \u0026#34;\u0026#34;; // 存储最接近的匹配单词 int min_diff = INT_MAX; // 最小差异初始化为 \u0026#34;无穷大\u0026#34; for (map\u0026lt;string, string\u0026gt;::iterator it = word_dict.begin(); it != word_dict.end(); ++it) { int diff = calculate_diff(morse_input, it-\u0026gt;second); // 计算当前摩尔斯电码的差异 // 如果已经发生两次完全匹配，返回 \u0026#34;!\u0026#34; if (diff == 0 \u0026amp;\u0026amp; min_diff == 0 \u0026amp;\u0026amp; best_match.back() != \u0026#39;!\u0026#39;) { best_match += \u0026#34;!\u0026#34;; return best_match; } // 如果找到更接近或相同的匹配，更新 best_match if (diff \u0026lt;= min_diff) best_match = it-\u0026gt;first; min_diff = min(diff, min_diff); // 更新最小差异 } if (min_diff \u0026gt; 0) best_match += \u0026#34;?\u0026#34;; // 如果不是完全匹配，追加 \u0026#34;?\u0026#34; return best_match; } int main() { string morse_code, character; vector\u0026lt;string\u0026gt; results; // 存储结果 // 读取字符到摩尔斯电码的映射 while (cin \u0026gt;\u0026gt; character \u0026amp;\u0026amp; character != \u0026#34;*\u0026#34;) { cin \u0026gt;\u0026gt; morse_code; morse_map[character[0]] = morse_code; // 存储每个字符的摩尔斯电码 } // 构建单词及其摩尔斯电码表示的字典 while (cin \u0026gt;\u0026gt; morse_code \u0026amp;\u0026amp; morse_code != \u0026#34;*\u0026#34;) { for (char ch : morse_code) word_dict[morse_code] += morse_map[ch]; // 将单词中的每个字符转换为摩尔斯电码 } // 读取摩尔斯电码输入并处理，存储结果 while (cin \u0026gt;\u0026gt; morse_code \u0026amp;\u0026amp; morse_code != \u0026#34;*\u0026#34;) { results.push_back(find_best_match(morse_code)); // 存储每个结果 } // 在输入完全读取后打印所有结果 for (string\u0026amp; result : results) { cout \u0026lt;\u0026lt; result \u0026lt;\u0026lt; endl; } return 0; } 仅供参考，可能有误\n","date":"2024-10-26T00:00:00Z","image":"http://localhost:3515/p/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/stl_hu16550555255445278498.png","permalink":"http://localhost:3515/p/%E5%9F%BA%E6%9C%AC%E7%AE%97%E6%B3%95%E6%A1%86%E6%9E%B6/","title":"基本算法框架"},{"content":"相关资料链接: 九月大人的博客\nyikai-blog\nrobocup2D官网\nRoboCup 2D 常用函数简明含义 函数名称 功能说明 dribble(angle, speed) 控制球员带球移动。angle表示带球方向，speed表示带球速度（如DRIBBLE_FAST、DRIBBLE_SLOW等）。 kickTo(targetPosition, speed) 球员向目标位置（targetPosition）踢球，speed指定踢球的速度。 leadingPass(teammate, power) 向最近的队友传球，teammate是要传球的目标队友，power表示传球力度。 getNrInSetInCircle(set, circle) 计算指定半径的圆圈内（circle）特定对象集合（set，如对手或队友）的数量。例如用来判断7米范围内是否有对手球员。 getClosestInSetTo(set, position) 获取距离指定位置（position）最近的特定对象集合（set）中的对象，例如找到离当前球员最近的队友或对手。 isOpponentAtAngle(angleMin, angleMax) 判断在给定的角度范围内是否有对方球员。常用于决定是否在某个方向射门或传球。 getGlobalPosition(object) 获取场上某个对象（球员、对手、球等）的全局坐标位置（X, Y坐标）。 getBallPos() 获取球的当前位置坐标。 moveToPos(position, speed) 移动球员到指定的position（坐标位置），并以speed指定的速度执行移动。 isBallKickable() 判断当前球是否在球员的控制范围内（即球员是否可以踢球）。 kickBallCloseToBody(angle) 控制球员以指定的angle（角度）把球围绕身体转动。 intercept(timeout) 尝试在指定时间内抢断球（通常用在防守场景）。 turnNeckToObject(object) 让球员将头（视角）转向指定的object（如球或对方球员），通常用于跟踪球的位置。 getPlayerNumber() 返回当前球员的编号（如2号、10号等），不同球员编号对应不同策略。例如10号通常为前锋，会有更多进攻行为。 getTeammateNumber() 获取指定队友的编号，用于传球决策时判断目标球员是否为特定队友。 getPosOpponentGoal() 获取对方球门的位置，通常用于判断进攻方向或射门目标。 shootToGoalex(object) 指定球员向对方球门射门，通常由接近球门的前锋使用。 getBallSpeedMax() 获取当前球员能踢球的最大速度。 getDirection() 计算某个目标相对于当前球员的方向（角度），例如计算球门方向或队友位置的方向。 isInTheirPenaltyArea(position) 判断某个位置是否位于对方禁区内，常用于决定射门或传球策略。 putCommandInQueue(command) 将指令（command）放入执行队列，确保该操作能够在下一次循环中执行。 Circle(center, radius) 创建一个以center为中心，radius为半径的圆，用于计算范围内的球员数量或球的距离。 Line::makeLineFromPositionAndAngle(position, angle) 根据给定的position和angle生成一条直线，通常用于计算球的运动轨迹或球员的移动路径。 isOffsideUs() 判断是否处于本方越位模式，适用于进攻方的越位规则判断。 isCornerKickUs() 判断是否处于本方角球模式。 isOwnSideOpponentMost() 判断己方半场的对手人数是否多于对方半场的对手人数。常用于判断防守或进攻策略。 getSecondClosestInSetTo(set, object) 获取距离指定object最近的第二个对象（通常是球员），用于策略决策，例如传球或防守。 仅供参考，可能有误\n","date":"2024-10-19T00:00:00Z","image":"http://localhost:3515/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:3515/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","title":"机器人技术(1): 常用函数"},{"content":"相关资料链接: 决策树-维基百科\n深入浅出理解决策树算法（一）-核心思想\n深入浅出理解决策树算法（二）-ID3算法与C4.5算法\n深刻理解决策树-动手计算ID3算法\n机器学习——使用ID3算法从原理到实际举例理解决策树\n基于信息论的三种决策树算法 划分数据集的最大原则是：使无序的数据变的有序。 如果一个训练数据中有20个特征，那么选取哪个做划分依据？这就必须采用量化的方法来判断，量化划分方法有多重，其中一项就是“信息论度量信息分类”。基于信息论的决策树算法有ID3 、C4.5和 CART等算法，其中C4.5和CART两种算法从ID3算法中衍生而来。此处仅记录ID3算法。\nID3算法（Iterative Dichotomiser 3 迭代二叉树3代）是一个由Ross Quinlan发明的用于决策树的算法。\n这个算法是建立在奥卡姆剃刀的基础上：越是小型的决策树越优于大的决策树（简单理论）。尽管如此，该算法也不是总是生成最小的树形结构。而是一个启发式算法。\n这个ID3算法可以归纳为以下几点：\n使用所有没有使用的属性并计算与之相关的样本熵值 选取其中熵值最小的属性 生成包含该属性的节点 理论公式 某个分类的信息 $$ l(x_i) = -\\log_2 P(x_i) $$这里\\(p(x_i)\\)是选择该分类的概率。\n熵 在信息论与概率统计中，熵是表示随机变量不确定性的度量。熵定义为信息的期望值，因此熵的计算方法如下：\n$$ H = -\\sum_{i=1}^{n} P(x_i) \\log_2 P(x_i) $$ 这里 \\( n \\) 是分类的数目。\n经验熵 熵中的概率由数据估计（特别是最大似然估计）得到。在 \\( |D| \\) 样本容量（样本个数）下，设有 \\( K \\) 个类 \\( C_k \\), \\( k = 1,2,3,…,K \\)，\\( |C_k| \\) 为属于类 \\( C_k \\) 的样本个数，得到其表达式如下：\n$$ H(D) = -\\sum_{k=1}^{K} \\frac{|C_k|}{|D|} \\log_2 \\frac{|C_k|}{|D|} $$条件熵 在已知随机变量 \\( X \\) 的条件下随机变量 \\( Y \\) 的不确定性，即在随机变量 \\( X \\) 给定的条件下随机变量 \\( Y \\) 的条件熵 \\( H(Y|X) \\)，定义为 \\( X \\) 给定条件下 \\( Y \\) 的条件概率分布的熵对 \\( X \\) 的数学期望：\n$$ H(Y|X) = \\sum_{i=1}^{n} p_i H(Y|X=x_i) $$信息增益 集合 \\( D \\) 的经验熵 \\( H(D) \\) 与特征 \\( A \\) 给定条件下 \\( D \\) 的经验条件熵 \\( H(D|A) \\) 之差：\n$$ g(D,A) = H(D) - H(D|A) $$实战(第四次作业题) 序号 是否有其他选择 饿否 价格 餐馆类型 餐馆顾客人数 等待时间 (分钟) 决策：是否等待 1 是 是 $$$ 法式 有人 0-10 是 2 是 是 $ 中餐 客满 30-60 否 3 否 否 $ 快餐 有人 0-10 是 4 是 是 $ 中餐 客满 10-30 是 5 是 否 $$$ 法式 客满 \u0026gt;60 否 6 否 是 $$ 意大利式 有人 0-10 是 7 否 否 $ 快餐 无人 0-10 否 8 否 是 $$ 中餐 有人 0-10 是 9 否 否 $ 快餐 客满 \u0026gt;60 否 10 是 是 $$$ 意大利式 客满 10-30 否 11 是 否 $ 中餐 无人 0-10 否 12 否 是 $ 快餐 客满 30-60 是 算法步骤 计算数据集中决策属性“是否等待”的熵（Entropy）。 对每个特征计算其信息增益（Information Gain），选择信息增益最大的特征作为根节点。 对选中的特征划分子数据集，递归地对每个子数据集继续构造子树，直到每个子集中的样本都属于同一类别，或者没有更多特征可以用来分裂。 生成最终的决策树。 第一层计算实例 我们首先要计算整体数据集的熵，然后逐个计算每个特征的信息增益：\n整体数据集经验熵计算： 有6个样例决策为是，6个样例决策为否。\n标签 YES NO 汇总 样本数 6 6 12 概率值 6/12 6/12 12/12 $$ Entropy(S) = -\\left(\\frac{6}{12}\\log_2\\frac{6}{12}\\right) - \\left(\\frac{6}{12}\\log_2\\frac{6}{12}\\right) = 1 $$经验熵计算完了，现在，我们要计算每个特征的条件熵，以及对应的信息增益，并对信息增益进行排序，选择增益最大的特征作为第一个分裂点进行分裂。\n1.特征“是否有其他选择”的信息增益： 这个特征包含两个属性取值，是和否\n是否有其他选择 YES NO 样本数 是 2 4 6 否 4 2 6 $$ Entropy(S_{是}) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$$$ Entropy(S_{否}) = -\\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.780 $$信息增益计算： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{6}{12} \\times 0.918 + \\frac{6}{12} \\times 0.780\\right) ≈ 0.151 $$ “是否有其他选择”这个特征的信息增益计算结束了，现在，我们需要对其他特征应用相同的计算方法，计算出剩余每个特征的信息增益。\n2.特征“饿否”的信息增益： 这个特征包含两个属性取值，是和否\n饿否 YES NO 样本数 是 5 2 7 否 1 4 5 $$ Entropy(S_{是}) = -\\left(\\frac{5}{7}\\log_2\\frac{5}{7}\\right) - \\left(\\frac{2}{7}\\log_2\\frac{2}{7}\\right) ≈ 0.863 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{5}\\log_2\\frac{1}{5}\\right) - \\left(\\frac{4}{5}\\log_2\\frac{4}{5}\\right) ≈ 0.722 $$信息增益计算： $$ Gain(Decision, 饿否) = 1 - \\left(\\frac{7}{12} \\times 0.863 + \\frac{5}{12} \\times 0.722\\right) ≈ 0.1958 $$ 3.特征\u0026quot;价格”的信息增益： 这个特征包含三个属性取值，$和$$和$$$\n价格 YES NO 样本数 $ 3 4 7 $$ 2 0 2 $$$ 1 2 3 $$ Entropy(S_{\\$}) = -\\left(\\frac{3}{7}\\log_2\\frac{3}{7}\\right) - \\left(\\frac{4}{7}\\log_2\\frac{4}{7}\\right) ≈ 0.985 $$$$ Entropy(S_{\\$$}) = -\\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) - \\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) = 0 $$\n如果类的实例数为0，而实例总数为n，则需要计算*-(0/n) .log2(0/n)，*定义0*log2*0=0，熵只依赖于X的分布，与X的取值无关。这里，log(0）将等于-∞, 我们不能计算0次∞。这是决策树应用程序中经常出现的一种特殊情况。 $$ Entropy(S_{\\$$$}) = -\\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) ≈ 0.918 $$ 信息增益计算： $$ Gain(Decision, 价格) = 1 - \\left(\\frac{7}{12} \\times 0.985 + \\frac{2}{12} \\times 0+\\frac{3}{12} \\times 0.918\\right) ≈ 0.1959 $$\n4.特征“餐馆类型”的信息增益： 这个特征包含四个属性取值，法式和中餐和快餐和意大利式。\n餐馆类型 YES NO 样本数 法式 1 1 2 中餐 1 3 4 快餐 2 2 4 意大利式 1 1 2 $$ Entropy(S_{法}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{中}) = -\\left(\\frac{1}{4}\\log_2\\frac{1}{4}\\right) - \\left(\\frac{3}{4}\\log_2\\frac{3}{4}\\right) ≈ 0.811 $$$$ Entropy(S_{快}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{意}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$信息增益计算： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{2}{12} \\times 1 + \\frac{4}{12} \\times 0.811 + \\frac{4}{12} \\times 1+ \\frac{2}{12} \\times 1\\right) ≈ 0.063 $$ 5.特征“餐馆顾客人数”的信息增益： 这个特征包含三个属性取值，无人和有人和客满。\n餐馆顾客人数 YES NO 样本数 无人 0 2 2 有人 4 0 4 客满 2 4 6 $$ Entropy(S_{无人}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$$$ Entropy(S_{有人}) = -\\left(\\frac{4}{4}\\log_2\\frac{4}{4}\\right) - \\left(\\frac{0}{4}\\log_2\\frac{0}{4}\\right) = 0 $$$$ Entropy(S_{客满}) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$信息增益计算： $$ Gain(Decision, 餐馆顾客人数) = 1 - \\left(\\frac{2}{12} \\times 0 + \\frac{4}{12} \\times 0+\\frac{6}{12} \\times 0.918\\right) ≈ 0.541 $$ 6.特征“等待时间(分钟)”的信息增益： 这个特征包含四个属性取值，0-10和10-30和30-60和\u0026gt;60。\n等待时间(分钟) YES NO 样本数 0-10 4 2 6 10-30 1 1 2 30-60 1 1 2 \u0026gt;60 0 2 2 $$ Entropy(S_{0-10}) = -\\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) - \\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) ≈ 0.918 $$$$ Entropy(S_{10-30}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{\u003e60}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$信息增益计算： $$ Gain(Decision, 等待时间) = 1 - \\left(\\frac{6}{12} \\times 0.918 + \\frac{2}{12} \\times 1 + \\frac{2}{12} \\times 1+ \\frac{2}{12} \\times 0\\right) ≈ 0.2077 $$ 第二层分裂决策 Feature Gain 排名 餐馆顾客人数 0.541 1 等待时间(分钟) 0.2077 2 价格 0.1959 3 饿否 0.1958 4 是否有其他选择 0.1951 5 餐馆类型 0.063 6 第一层分裂的特征确定后就要根据分裂的结果，进行第二层的分裂，同第一层，也是需要计算每个子集的经验熵 + 条件熵。\n数据集第一步被餐馆顾客人数这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。\n通过对所有特征的信息增益进行比较，选择信息增益最高的特征作为决策节点，继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-无人(有人) 分支 在无人这个分支上，标签全部是no，也就是已经彻底的完成了分裂了，这个就可以作为叶子节点，无需继续分裂。在有人这个分支上，标签全部是yes，这个也可以作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 客满 是 否 $$$ 法式 \u0026gt;60 否 客满 否 否 $ 快餐 \u0026gt;60 否 客满 是 是 $$$ 意大利式 10-30 否 客满 否 是 $ 快餐 30-60 是 该子集中有 2 个样例决策为是，4 个样例决策为否。\n1.整体数据集经验熵计算： $$ Entropy(S) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$现在我们对剩下的特征重新计算信息增益。\n1. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 3 4 否 1 1 2 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{4}\\log_2\\frac{1}{4}\\right) - \\left(\\frac{3}{4}\\log_2\\frac{3}{4}\\right) ≈ 0.811 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$信息增益： $$ Gain(Decision, 是否有其他选择) = 0.918 - \\left(\\frac{4}{6} \\times 0.811 + \\frac{2}{6} \\times 1\\right) ≈ 0.0207 $$2. 特征“饿否”的信息增益 饿否 YES NO 样本数 是 2 2 4 否 0 2 2 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{否}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$信息增益： $$ Gain(Decision, 饿否) = 0.918 - \\left(\\frac{4}{6} \\times 1 + \\frac{2}{6} \\times 0\\right) ≈ 0.2513 $$3. 特征“价格”的信息增益 价格 YES NO 样本数 $ 2 2 4 $$$ 0 2 2 计算条件熵： $$ Entropy(S_{\\$}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{\\$$$}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$\n信息增益： $$ Gain(Decision, 价格) = 0.918 - \\left(\\frac{4}{6} \\times 1 + \\frac{2}{6} \\times 0\\right) ≈ 0.2513 $$4. 特征“餐馆类型”的信息增益 餐馆类型 YES NO 样本数 中餐 1 1 2 快餐 1 1 2 法式 0 1 1 意大利式 0 1 1 计算条件熵： $$ Entropy(S_{中餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{快餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{法式})=Entropy(S_{意大利式})=0 $$信息增益： $$ Gain(Decision, 餐馆类型) = 0.918 - \\left(\\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 1 + \\frac{1}{6} \\times 0 + \\frac{1}{6} \\times 0\\right)≈ 0.2511 $$5. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 1 2 30-60 1 1 2 \u0026gt;60 0 2 2 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{\u003e60}) = 0 $$信息增益： $$ Gain(Decision, 等待时间) = 0.918 - \\left(\\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 0 \\right) ≈ 0.2513 $$ 第三层分裂决策 Feature Gain 排名 饿否 0.2513 1 等待时间(分钟) 0.2513 1 价格 0.2513 1 餐馆类型 0.2511 4 是否有其他选择 0.0207 5 第三层也是需要计算每个子集的经验熵 + 条件熵。此时前三的信息增益一致，选任意一个即可。\n数据集第一步被餐馆饿否这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。\n通过对所有特征的信息增益进行比较，选择信息增益最高的特征作为决策节点，继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-否 分支 在否这个分支上，标签全部是no，也就是已经彻底的完成了分裂了，非常纯，这个就可以作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满|饿否-是 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 客满 是 是 $$$ 意大利式 10-30 否 客满 否 是 $ 快餐 30-60 是 此子集中有 2 个样例决策为是，2 个样例决策为否。\n1.整体数据集经验熵计算： 该子集的经验熵为： $$ Entropy(S) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$ 现在我们对剩余特征重新计算信息增益。\n2. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 2 3 否 1 0 1 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) ≈ 0.918 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{1}\\log_2\\frac{1}{1}\\right) = 0 $$信息增益： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{3}{4} \\times 0.918 + \\frac{1}{4} \\times 0\\right) ≈ 0.311 $$2. 特征“价格”的信息增益 价格 YES NO 样本数 $ 2 1 3 $$$ 0 1 1 计算条件熵： $$ Entropy(S_{\\$}) = -\\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) - \\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) ≈ 0.918 $$$$ Entropy(S_{\\$$$}) = 0 $$\n信息增益： $$ Gain(Decision, 价格) = 1 - \\left(\\frac{3}{4} \\times 0.918 + \\frac{1}{4} \\times 0\\right) ≈ 0.311 $$3. 特征“餐馆类型”的信息增益 餐馆类型 YES NO 样本数 中餐 1 1 2 快餐 1 0 1 意大利式 0 1 1 计算条件熵： $$ Entropy(S_{中餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{快餐}) = Entropy(S_{意大利式}) = 0 $$信息增益： $$ Gain(Decision, 餐馆类型) = 1 - \\left(\\frac{2}{4} \\times 1 + \\frac{1}{4} \\times 0 + \\frac{1}{4} \\times 0\\right) = 0.5 $$4. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 1 2 30-60 1 1 2 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 信息增益： $$ Gain(Decision, 等待时间) = 1 - 1 = 0 $$ 第四层分裂决策 Feature Gain 排名 餐馆类型 0.5 1 价格 0.311 2 是否有其他选择 0.2513 3 等待时间(分钟) 0 4 数据集第一步被餐馆餐馆类型这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-是|餐馆类型-快餐(意大利式) 分支 在快餐个分支上，标签全部是yes，意大利式分支上全是no，非常纯，作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满|饿否-是|餐馆类型-中餐 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 此分支中有 1 个样例决策为是，1 个样例决策为否。\n1. 整体数据集经验熵计算 该子集的经验熵为： $$ Entropy(S) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 现在我们对剩余特征重新计算信息增益。\n2. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 1 2 否 0 0 0 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 因为是否有其他选择没有有效的分裂，信息增益为0。\n3. 特征“价格”的信息增益 价格 YES NO 样本数 $ 1 1 2 计算条件熵： $$ Entropy(S_{\\$}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 价格也没有带来有效分裂，信息增益为0。\n4. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 0 1 30-60 0 1 1 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = 0 $$ 信息增益： $$ Gain(Decision, 等待时间) = 1 - 0 = 1 $$ 第五层分裂决策 Feature Gain 排名 等待时间(分钟) 1 1 价格 0 2 是否有其他选择 0 2 数据集第一步被餐馆等待时间这个特征分裂成两个节点，现在需要对每个节点计算下一步的分裂特征。继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-是|餐馆类型-中餐|等待时间-1030(3060) 分支 在10-30分支上，标签全部是yes，30-60分支上全是no，非常纯，无需继续分裂。\n至此，最终决策树已构建。\n最终决策树结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . └─顾客人数 ├─客满 │ └─饿否 │ ├─否-\u0026gt;no │ └─是 │ └─餐馆类型 │ ├─中餐 │ │ └─等待时间 │ │ ├─10~30-\u0026gt;yes │ │ └─30~60-\u0026gt;no │ ├─快餐-\u0026gt;yes │ └─意大利式-\u0026gt;no ├─无人-\u0026gt;no └─有人-\u0026gt;yes ![](机器人决策树 P1.png)\n仅供参考，可能有误\n","date":"2024-10-19T00:00:00Z","image":"http://localhost:3515/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF2-%E5%85%B8%E5%9E%8B%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95id3/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:3515/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF2-%E5%85%B8%E5%9E%8B%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95id3/","title":"机器人技术(2): 典型决策树学习算法ID3"},{"content":"#STL常用算法函数及其参数简明含义 供快速回顾（常用函数摘自HFUT ICPC讲义P21） find\n功能：在范围 [first, last) 中查找值为 val 的第一个元素。 参数： InIt first, InIt last：输入迭代器，指定搜索范围。 const T\u0026amp; val：需要查找的值。 find_if\n功能：在范围 [first, last) 中查找第一个满足谓词 pr 的元素。 参数： InIt first, InIt last：输入迭代器。 Pred pr：一元谓词函数，返回布尔值。 count\n功能：计算范围 [first, last) 中等于 val 的元素个数。 参数： InIt first, InIt last：输入迭代器。 const T\u0026amp; val：待计数的值。 count_if\n功能：计算范围 [first, last) 中满足谓词 pr 的元素个数。 参数： InIt first, InIt last：输入迭代器。 Pred pr：一元谓词函数。 copy\n功能：将范围 [first, last) 中的元素复制到 x 开始的位置。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器，复制的目标位置。 swap\n功能：交换两个变量 x 和 y 的值。 参数： T\u0026amp; x, T\u0026amp; y：需要交换的两个变量。 swap_ranges\n功能：交换两个范围 [first, last) 和从 x 开始的元素。 参数： FwdIt1 first, FwdIt1 last：第一个范围的迭代器。 FwdIt2 x：第二个范围的起始迭代器。 replace\n功能：将范围 [first, last) 中等于 vold 的元素替换为 vnew。 参数： FwdIt first, FwdIt last：输入迭代器。 const T\u0026amp; vold, const T\u0026amp; vnew：旧值和新值。 replace_if\n功能：将范围 [first, last) 中满足谓词 pr 的元素替换为 val。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：一元谓词函数。 const T\u0026amp; val：替换的值。 generate\n功能：用生成器 g 生成的值填充范围 [first, last)。 参数： FwdIt first, FwdIt last：输入迭代器。 Gen g：生成器函数。 generate_n\n功能：用生成器 g 生成的值填充从 first 开始的 n 个元素。 参数： OutIt first：输出迭代器。 Dist n：生成元素的数量。 Gen g：生成器函数。 remove\n功能：删除范围 [first, last) 中等于 val 的元素，并返回新范围的末尾迭代器。 参数： FwdIt first, FwdIt last：输入迭代器。 const T\u0026amp; val：需要删除的值。 remove_if\n功能：删除范围 [first, last) 中满足谓词 pr 的元素，并返回新范围的末尾迭代器。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：一元谓词函数。 remove_copy\n功能：将范围 [first, last) 中不等于 val 的元素复制到 x 开始的地方。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器。 const T\u0026amp; val：待删除的值。 remove_copy_if\n功能：将范围 [first, last) 中不满足谓词 pr 的元素复制到 x 开始的位置。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器。 Pred pr：一元谓词函数。 unique\n功能：删除范围 [first, last) 中相邻的重复元素。 参数： FwdIt first, FwdIt last：输入迭代器。 unique (带谓词)\n功能：删除范围 [first, last) 中相邻满足谓词 pr 的重复元素。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：二元谓词函数。 reverse\n功能：反转范围 [first, last) 中的元素。 参数： BidIt first, BidIt last：双向迭代器。 reverse_copy\n功能：将范围 [first, last) 中的元素反转后复制到 x 开始的位置。 参数： BidIt first, BidIt last：双向迭代器。 OutIt x：输出迭代器。 partition\n功能：将范围 [first, last) 中满足谓词 pr 的元素放在不满足谓词的元素之前。 参数： BidIt first, BidIt last：双向迭代器。 Pred pr：一元谓词函数。 stable_partition\n功能：与 partition 类似，但保留相对顺序。 参数： FwdIt first, FwdIt last：前向迭代器。 Pred pr：一元谓词函数。 sort\n功能：对范围 [first, last) 中的元素进行升序排序。 参数： RanIt first, RanIt last：随机访问迭代器。 sort (带谓词)\n功能：按照谓词 pr 对范围 [first, last) 中的元素排序。 参数： RanIt first, RanIt last：随机访问迭代器。 Pred pr：二元谓词函数。 stable_sort\n功能：稳定排序范围 [first, last) 中的元素，保留相等元素的相对顺序。 参数： BidIt first, BidIt last：双向迭代器。 stable_sort (带谓词)\n功能：按照谓词 pr 稳定排序。 参数： BidIt first, BidIt last：双向迭代器。 Pred pr：二元谓词函数。 nth_element\n功能：对范围 [first, last) 进行部分排序，使得 nth 处的元素位于其最终位置。 参数： RanIt first, RanIt nth, RanIt last：随机访问迭代器。 binary_search\n功能：判断范围 [first, last) 中是否存在值 val。 参数： FwdIt first, FwdIt last：前向迭代器。 const T\u0026amp; val：要查找的值。 binary_search (带谓词)\n功能：根据谓词 pr 判断范围 [first, last) 中是否存在值 val。 参数： FwdIt first, FwdIt last：前 向迭代器。 - const T\u0026amp; val：要查找的值。 - Pred pr：二元谓词函数。\nmerge\n功能：将两个已排序的范围合并到一个新的范围中。 参数： InIt1 first1, InIt1 last1：第一个范围的输入迭代器。 InIt2 first2, InIt2 last2：第二个范围的输入迭代器。 OutIt x：输出迭代器。 merge (带谓词)\n功能：根据谓词 pr 将两个已排序范围合并。 参数： InIt1 first1, InIt1 last1：第一个范围的输入迭代器。 InIt2 first2, InIt2 last2：第二个范围的输入迭代器。 OutIt x：输出迭代器。 Pred pr：二元谓词函数。 max\n功能：返回 x 和 y 中较大的那个。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 max (带谓词)\n功能：根据谓词 pr 返回较大的值。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 Pred pr：二元谓词函数。 min\n功能：返回 x 和 y 中较小的那个。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 min (带谓词)\n功能：根据谓词 pr 返回较小的值。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 Pred pr：二元谓词函数。 仅供参考，可能有误\n","date":"2024-10-18T00:00:00Z","image":"http://localhost:3515/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF1-stl/stl_hu16550555255445278498.png","permalink":"http://localhost:3515/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF1-stl/","title":"程序设计艺术(1): STL"},{"content":" 仅供参考，可能有误\n","date":"2024-10-18T00:00:00Z","image":"http://localhost:3515/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF2-%E6%90%9C%E7%B4%A2/stl_hu16550555255445278498.png","permalink":"http://localhost:3515/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF2-%E6%90%9C%E7%B4%A2/","title":"程序设计艺术(2): 搜索"},{"content":"Hugo 是用 Go 实现的博客工具，采用 Markdown 进行文章编辑，自动生成静态站点文件，支持丰富的主题配置，也可以通过 js 嵌入像是评论系统等插件，高度定制化。除了 Hugo 外， 还有 Jekyll(github page默认)、Gatsby、Hexo、Ghost 等选择，实现和使用都差不多，可以根据自己的偏好进行选择。\n安装 Hugo 在ubuntu24.04 LTS环境下到 Hugo Releases 下载对应的deb包(注意安装extend版本，许多第三方主题需要extend依赖)，安装完成后，使用以下命令进行验证：\n1 hugo version 创建 Hugo 网站 通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了，如希望生成到 /path/to/site 路径：\n1 $ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n1 $ cd /path/to/site 站点目录结构：\n1 2 3 4 5 6 7 8 9 . ├── archetypes: default.md是生成博文的模版 ├── assets # 存放被 Hugo Pipes 处理的文件 ├── content # 存放markdown文件作为博文内容 ├── data # 存放 Hugo 处理的数据 ├── layouts # 存放布局文件 ├── static # 存放静态文件 图片 CSS JS文件 ├── themes: 存放不同的主题 └── config.toml: 博客配置文件支持 JSON YAML TOML 三种格式配置文件 创建文章 创建一个 about 页面：\n1 $ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下：\n1 2 3 4 5 6 7 8 +++ date = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;about\u0026#34; +++ 正文内容 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。\n创建第一篇文章，放到 content/post 目录，方便之后生成聚合页面。\n1 $ hugo new post/first.md 打开编辑 content/post/first.md ：\n1 2 3 4 5 6 7 8 9 10 11 --- date: \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; title: \u0026#34;first\u0026#34; --- ### Hello Hugo 1. aaa 1. bbb 1. ccc 注意此项为可选步骤，跳过可直接copy他人主题\n配置主题 当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目的github仓库，一般人气多的主题都会有很详细的安装及配置说明。\n传统方式使用的是将原主题仓库 fork 到自己的账户，并使用 git submodule 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。\n1 2 3 cd cita-site/#进入网站工程根目录 git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack#笔者所用主题为stack，此行与你所选主题有关 然后在根目录下的 config.toml文件中添加新的一行:\n1 theme = \u0026#34;your_theme\u0026#34; 此时大多数主题仓库提供example文件，你可以拷贝至你的工程根目录下，主要是content与config文件，之后就能进行下一步，如有问题建议查看主题提供的参考手册。\n生成网页 为了查看生成的博客的效果，我们在本地编辑调试时可以通过 hugo server 命令进行本地实时调试预览，无须每次都重新生成。在bash中运行以下命令，即我们可以通过浏览器 http://localhost:1313/ 地址访问我们的本地预览网页。\n1 hugo server 但此时只能在本地访问，如果想发布到 Github Pages ， 还需要借助 GithubPages 工具。\nGithub Pages部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io （coderzh替换为你的github用户名）。站点目录config.toml中baseURL要换成自己建立的仓库，如baseURL = “https://cita-777.github.io/\u0026quot;\n在站点根目录执行 Hugo 命令生成最终页面：\n1 $ hugo --theme=hyde --baseURL=\u0026#34;http://coderzh.github.io/\u0026#34; 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。\n1 2 3 4 5 6 $ cd public $ git init $ git remote add origin https://github.com/coderzh/coderzh.github.io.git $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master 浏览器里访问：http://coderzh.github.io/\n注意必须只上传public中的所有文件，若无法使用密钥则使用ssh鉴定身份(git remote set-url origin git@github.com:cita-777/cita-777.github.io.git)，目前github默认主分支为main，建议设置里改为master\n后续修改网页 对content和config进行自行随意修改后需要重新上传至github仓库同步更新。切记不要随意手动删除public文件让Hugo重新生成再尝试push，因为这会将public内的.git一起删除，你将需要重新配置git并且链接至远程仓库，当你使用hugo server命令在本地生存并预览网站后，Hugo会自动生成新的public文件，包含你对网站所作的所有新更改，而且你在static文件管理资源时所进行的增加与删除，public中只会进行增加而不会删除，本意是很好的，这是一种非破坏性修改。所以如果你有用不上的资源，记得在public文件内手动删除来减少空间占用，所以你只需要朴实无华的push即可，参考命令如下：\n1 2 3 4 5 6 hugo server -D ctrl + c #关闭本地server cd public #进入public文件内 git add -A #提交all变动 git commit -m \u0026#34;修改/更新了xxx\u0026#34; git push -u origin master #push到远程仓库 (进阶)Github Action 自动发布 通过前面的操作我们可以手动发布我们的静态文件，但还是有以下弊端：\n发布步骤还是比较繁琐，本地调试后还需要切换到 public/ 目录进行上传 无法对博客 .md 源文件进行备份与版本管理 因此，我们需要简单顺滑的方式来进行博客发布，首先我们初始化博客源文件的仓库，如我的仓库为 pseudoyu/yu-blog。\n因为我们的博客基于 GitHub 与 GitHub Pages，可以通过官方提供的 GitHub Action 进行 CI 自动发布，下面我会进行详细讲解。GitHub Action 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。\n配置在仓库目录 .github/workflows 下，以 .yml 为后缀。我的 GitHub Action 配置为 pseudoyu/yu-blog deploy.yml，自动发布示例配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: pseudoyu/pseudoyu.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} on 表示 GitHub Action 触发条件，我设置了 push、workflow_dispatch 和 schedule 三个条件：\npush，当这个项目仓库发生推送动作后，执行 GitHub Action workflow_dispatch，可以在 GitHub 项目仓库的 Action 工具栏进行手动调用 schedule，定时执行 GitHub Action，如我的设置为北京时间每天早上执行，主要是使用一些自动化统计 CI 来自动更新我博客的关于页面，如本周编码时间，影音记录等，如果你不需要定时功能，可以删除这个条件 jobs 表示 GitHub Action 中的任务，我们设置了一个 build 任务，runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。我们的 build 任务包含了 Checkout、Setup Hugo、Build Web 和 Deploy Web 四个主要步骤，其中 run 是执行的命令，uses 是 GitHub Action 中的一个插件，我们使用了 peaceiris/actions-hugo@v2 和 peaceiris/actions-gh-pages@v3 这两个插件。其中 Checkout 步骤中 with 中配置 submodules 值为 true 可以同步博客源仓库的子模块，即我们的主题模块。\n首先需要将上述 deploy.yml 中的 EXTERNAL_REPOSITORY 改为自己的 GitHub Pages 仓库，如我的设置为 pseudoyu/pseudoyu.github.io。\n因为我们需要从博客仓库推送到外部 GitHub Pages 仓库，需要特定权限，要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。\n","date":"2024-10-06T00:00:00Z","image":"http://localhost:3515/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu9262121530157302112.jpg","permalink":"http://localhost:3515/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/","title":"Hugo+Github Pages搭建静态网站作为个人博客(1)"},{"content":"上一篇博客中重点于Hugo的使用，这一篇着重于以Stack主题为例进行博客撰写。\nStack is a simple card-style Hugo theme designed for Bloggers. Here are some of the features: Stack 是一个简单的卡片式 Hugo 主题，专为 Blogger 设计。以下是一些功能：\nResponsive images support 响应式图像支持 Lazy load images 延迟加载图像 Dark mode 深色模式 Local search 本地搜索 PhotoSwipe integration 照片滑动集成 Archive page template 存档页面模板 Full native JavaScript, no jQuery or any other frameworks are used 完全原生 JavaScript，不使用 jQuery 或任何其他框架 No CSS framework, keep it simple and minimal 没有 CSS 框架，保持简单和最小化 Properly cropped thumbnails 正确裁剪的缩略图 Subsection support 分段支持 Table of contents 目录 Hugo网站文件结构 网站根目录下面的文件夹目录树一般如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 . ├── archetypes │ └── default.md ├── hugo.yaml # 网站配置文件 ├── content # 站点内的内容都在这里 │ ├── categories # “分类”页面的首页 │ │ └── Test # “分类”页面下的一个分类页面 │ ├── page # 显示在网站主页左侧边栏菜单的选项 │ │ ├── about # 左侧边栏菜单中的“关于”页面 │ │ ├── archives # 左侧边栏菜单中的“归档”页面 │ │ ├── links # 左侧边栏菜单中的“链接”页面 │ │ └── search # 左侧边栏菜单中的“搜索”页面 │ └── post # 用户写的帖子都放在这里，每个子文件夹对应一个帖子 │ ├── chinese-test │ ├── emoji-support │ ├── markdown-syntax │ ├── math-typesetting │ ├── placeholder-text │ └── rich-content ├── data ├── layouts ├── LICENSE ├── README.md ├── resources │ └── _gen │ ├── assets │ └── images ├── static # 放用户自定义字体、用户头像、网站小图标等 └── themes # 放各种主题 └── hugo-theme-stack # stack主题 ├── archetypes ├── assets #里面有个img存放头像图片位置 ├── config.yaml #stack主题的配置文件，优先级低于上面的网站配置文件 ├── data ├── debug.sh ├── exampleSite ├── go.mod ├── i18n #多语言支持包 ├── images #网站示例的截图存放位置 ├── layouts ├── LICENSE ├── netlify.toml ├── README.md └── theme.toml 主要修改主题内和网站内的config.yaml，具体含义可见官方手册。\n此外，上面没有显示的是网站根目录下的private文件夹和public文件夹。\npublic文件夹会在运行hugo -D部署网站时生成，是暴露给外界的文件夹，网站上页面的HTML文件都会由Hugo生成并放在public文件夹下。public文件夹内不要放置任何包含用户信息的敏感文件！ private文件夹可以由用户创建，这里我们用它来存放网站的SSL证书。 关于网站根目录下各文件夹，更详细的说明可参见Hugo官方文档。\n配置文件夹config Hugo支持两种配置方式：\n一种是直接在网站根目录的.config文件中配置 另一种是在网站根目录下创建config文件夹，配置放在config文件夹内 第二种配置方式支持将不同的配置项分开放在不同的文件中，相比第一种配置方式可以让配置项的条理更加清晰，因此我们这里选择第二种配置方式。参考配置目录结构如下所示：\n1 2 3 4 5 6 7 8 config └── _default ├── config.yaml ├── languages.yaml ├── menu.en.yaml ├── menu.zh-cn.yaml ├── params.en.yaml └── params.zh-cn.yaml 关于Hugo的配置，更详细的说明可参考官方文档。\n[附录1]主题内config.yaml各参数简明含义 Module (模块设置)\nhugoVersion\n: 定义Hugo版本要求。\nextended: 设置为true表示需要Hugo的扩展版本（支持SCSS和其他高级功能）。 min: 需要的最低Hugo版本为0.87.0。 Params (参数设置)\nmainSections: 定义主要的内容部分，这里是post，也就是文章部分。 featuredImageField: 文章中用于展示特色图片的字段名称，默认为image。 rssFullContent: RSS中是否提供文章的完整内容，true表示是。 Favicon (网站图标)\nfavicon: 设置网站的favicon路径，如果有一个favicon.ico，可以设置为/favicon.ico。 Footer (页脚)\nsince: 页脚中显示的年份（通常是网站开始的年份），这个字段为空，可以填入年份，如“2024”。 customText: 页脚自定义文本，当前为空，可以填写你想显示的内容。 Date Format (日期格式)\npublished: 发布日期的显示格式，这里格式为Jan 02, 2006。 lastUpdated: 最后更新日期的显示格式，这里包括日期和时间。 Sidebar (侧边栏)\ncompact: 是否使用紧凑布局，false表示不使用紧凑布局。\nemoji: 表情符号，可以为空或者自定义一个表情符号显示在侧边栏上。\nsubtitle: 侧边栏的副标题，当前为空，可以添加文字。\navatar\n: 头像设置。\nenabled: 是否显示头像，true表示显示。 local: true表示头像从本地文件加载。 src: 头像的路径为img/avatar.png。 Article (文章设置)\nheadingAnchor: 设置是否在标题旁边显示锚点，false表示不显示。\nmath: 是否支持数学公式，false表示不支持。\ntoc: 目录设置，true表示显示文章目录。\nreadingTime: 是否显示阅读时间，true表示显示。\nlicense\n: 文章版权设置。\nenabled: 是否启用版权声明，false表示不启用。 default: 默认的版权声明，当前设置为“Creative Commons BY-NC-SA 4.0”，但没有启用。 Comments (评论系统)\nenabled: 是否启用评论，false表示不启用。 provider: 默认评论提供者是disqus。 配置了多个评论系统，包括disqusjs, utterances, beaudar, remark42, vssue等。每个评论系统都有自己的设置项，例如Disqus、GitHub Issues（通过utterances）、Beaudar等。这些可以根据需要选择，并填入相关参数，如API密钥、仓库名称等。 Widgets (小工具)\nhomepage: 主页上的小工具列表，当前为空，也就是说默认没有显示任何小工具。 page: 页面上的小工具列表，当前为空。 OpenGraph (社交分享卡片)\ntwitter\n: 配置Twitter分享卡片。\nsite: 填写你的Twitter用户名。 card: 卡片类型，这里是summary_large_image，表示大图片的分享卡片。 DefaultImage (默认图片)\nopengraph\n: 配置默认图片的设置。\nenabled: 是否启用OpenGraph图片，false表示不启用。 local: 图片是否为本地图片，false表示不是本地图片。 src: 默认图片的路径。 ColorScheme (颜色主题)\ntoggle: 是否允许用户切换颜色主题（比如暗黑模式），true表示启用切换功能。 default: 默认颜色主题，这里是auto，表示根据用户系统的设置自动切换。 ImageProcessing (图片处理)\ncover: 是否启用封面图片处理，true表示启用。 content: 是否启用内容图片处理，true表示启用。 [附录2]官方示例提供的根目录内hugo.yaml各参数简明含义 基本信息\nbaseurl: 网站的基础URL。 languageCode: 默认语言代码，例如en-us表示英语（美国）。 theme: 使用的主题，在这里是hugo-theme-stack。 title: 网站的标题。 copyright: 网站的版权声明。 语言支持\nDefaultContentLanguage: 设置默认的语言为英语（en）。 hasCJKLanguage: 如果网站主要使用中文、日文或韩文等CJK（中日韩）语言，这个值应设为true，用于正确处理文章摘要和字数统计。 languages: 你可以为网站配置多语言支持。在这个例子中，网站支持英语（en）、中文简体（zh-cn）和阿拉伯语（ar）。每种语言可以有独立的标题和描述。 服务设置\ndisqus: 用于网站评论的服务，Disqus是一个流行的评论系统。如果要启用评论，需要更改为你自己的网站短名称。 googleAnalytics: 如果你使用Google Analytics（谷歌分析）进行流量统计，可以在这里填入你的追踪ID。 分页和永久链接\npagination: 设置分页大小为3，也就是说每页显示3篇文章。 permalinks: 自定义文章和页面的永久链接结构。例如，文章会显示为/p/:slug/。 页面参数\nparams: 包含各种网站布局、显示和功能的配置。比如文章是否显示数学公式、阅读时间、许可信息等。 评论功能\ncomments: 你可以选择不同的评论提供者（如Disqus、Utterances、Gitalk等），通过填入相关的配置信息来启用评论。 菜单和小工具\nmenu: 自定义网站菜单和社交链接。这里包括GitHub和Twitter的社交图标链接。 widgets: 配置主页和页面上的小工具，例如搜索栏、文章归档、标签云等。 其他配置\nopengraph: 配置网站在社交平台（如Twitter）的分享卡片。 colorScheme: 配置网站的颜色模式（自动、浅色或深色）。 imageProcessing: 图片处理选项，例如封面图片和内容图片。 相关内容\nrelated: 配置文章之间的相关性推荐，基于标签和分类等条件。 Markdown 渲染\nmarkup: 配置如何处理Markdown内容，例如表格、代码高亮、目录等。 两篇附录仅供参考，可能有错误\n","date":"2024-10-06T00:00:00Z","image":"http://localhost:3515/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu9262121530157302112.jpg","permalink":"http://localhost:3515/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/","title":"Hugo+Github Pages搭建静态网站作为个人博客(2)"},{"content":"长沙 宣城 合肥 桂林 ","date":"2024-10-06T00:00:00Z","image":"http://localhost:3515/p/tim-cnt-1/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:3515/p/tim-cnt-1/","title":"TIM -\u003e CNT= -1"}]