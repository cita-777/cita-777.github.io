[{"content":"相关资料链接: 九月大人的博客\nyikai-blog\nrobocup2D官网\nRoboCup 2D 常用函数简明含义 函数名称 功能说明 dribble(angle, speed) 控制球员带球移动。angle表示带球方向，speed表示带球速度（如DRIBBLE_FAST、DRIBBLE_SLOW等）。 kickTo(targetPosition, speed) 球员向目标位置（targetPosition）踢球，speed指定踢球的速度。 leadingPass(teammate, power) 向最近的队友传球，teammate是要传球的目标队友，power表示传球力度。 getNrInSetInCircle(set, circle) 计算指定半径的圆圈内（circle）特定对象集合（set，如对手或队友）的数量。例如用来判断7米范围内是否有对手球员。 getClosestInSetTo(set, position) 获取距离指定位置（position）最近的特定对象集合（set）中的对象，例如找到离当前球员最近的队友或对手。 isOpponentAtAngle(angleMin, angleMax) 判断在给定的角度范围内是否有对方球员。常用于决定是否在某个方向射门或传球。 getGlobalPosition(object) 获取场上某个对象（球员、对手、球等）的全局坐标位置（X, Y坐标）。 getBallPos() 获取球的当前位置坐标。 moveToPos(position, speed) 移动球员到指定的position（坐标位置），并以speed指定的速度执行移动。 isBallKickable() 判断当前球是否在球员的控制范围内（即球员是否可以踢球）。 kickBallCloseToBody(angle) 控制球员以指定的angle（角度）把球围绕身体转动。 intercept(timeout) 尝试在指定时间内抢断球（通常用在防守场景）。 turnNeckToObject(object) 让球员将头（视角）转向指定的object（如球或对方球员），通常用于跟踪球的位置。 getPlayerNumber() 返回当前球员的编号（如2号、10号等），不同球员编号对应不同策略。例如10号通常为前锋，会有更多进攻行为。 getTeammateNumber() 获取指定队友的编号，用于传球决策时判断目标球员是否为特定队友。 getPosOpponentGoal() 获取对方球门的位置，通常用于判断进攻方向或射门目标。 shootToGoalex(object) 指定球员向对方球门射门，通常由接近球门的前锋使用。 getBallSpeedMax() 获取当前球员能踢球的最大速度。 getDirection() 计算某个目标相对于当前球员的方向（角度），例如计算球门方向或队友位置的方向。 isInTheirPenaltyArea(position) 判断某个位置是否位于对方禁区内，常用于决定射门或传球策略。 putCommandInQueue(command) 将指令（command）放入执行队列，确保该操作能够在下一次循环中执行。 Circle(center, radius) 创建一个以center为中心，radius为半径的圆，用于计算范围内的球员数量或球的距离。 Line::makeLineFromPositionAndAngle(position, angle) 根据给定的position和angle生成一条直线，通常用于计算球的运动轨迹或球员的移动路径。 isOffsideUs() 判断是否处于本方越位模式，适用于进攻方的越位规则判断。 isCornerKickUs() 判断是否处于本方角球模式。 isOwnSideOpponentMost() 判断己方半场的对手人数是否多于对方半场的对手人数。常用于判断防守或进攻策略。 getSecondClosestInSetTo(set, object) 获取距离指定object最近的第二个对象（通常是球员），用于策略决策，例如传球或防守。 仅供参考，可能有误\n","date":"2024-10-19T00:00:00Z","image":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF1-%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/","title":"机器人技术(1): 常用函数"},{"content":"相关资料链接: 决策树-维基百科\n深入浅出理解决策树算法（一）-核心思想\n深入浅出理解决策树算法（二）-ID3算法与C4.5算法\n深刻理解决策树-动手计算ID3算法\n机器学习——使用ID3算法从原理到实际举例理解决策树\n基于信息论的三种决策树算法 划分数据集的最大原则是：使无序的数据变的有序。 如果一个训练数据中有20个特征，那么选取哪个做划分依据？这就必须采用量化的方法来判断，量化划分方法有多重，其中一项就是“信息论度量信息分类”。基于信息论的决策树算法有ID3 、C4.5和 CART等算法，其中C4.5和CART两种算法从ID3算法中衍生而来。此处仅记录ID3算法。\nID3算法（Iterative Dichotomiser 3 迭代二叉树3代）是一个由Ross Quinlan发明的用于决策树的算法。\n这个算法是建立在奥卡姆剃刀的基础上：越是小型的决策树越优于大的决策树（简单理论）。尽管如此，该算法也不是总是生成最小的树形结构。而是一个启发式算法。\n这个ID3算法可以归纳为以下几点：\n使用所有没有使用的属性并计算与之相关的样本熵值 选取其中熵值最小的属性 生成包含该属性的节点 理论公式 某个分类的信息 $$ l(x_i) = -\\log_2 P(x_i) $$这里\\(p(x_i)\\)是选择该分类的概率。\n熵 在信息论与概率统计中，熵是表示随机变量不确定性的度量。熵定义为信息的期望值，因此熵的计算方法如下：\n$$ H = -\\sum_{i=1}^{n} P(x_i) \\log_2 P(x_i) $$ 这里 \\( n \\) 是分类的数目。\n经验熵 熵中的概率由数据估计（特别是最大似然估计）得到。在 \\( |D| \\) 样本容量（样本个数）下，设有 \\( K \\) 个类 \\( C_k \\), \\( k = 1,2,3,…,K \\)，\\( |C_k| \\) 为属于类 \\( C_k \\) 的样本个数，得到其表达式如下：\n$$ H(D) = -\\sum_{k=1}^{K} \\frac{|C_k|}{|D|} \\log_2 \\frac{|C_k|}{|D|} $$条件熵 在已知随机变量 \\( X \\) 的条件下随机变量 \\( Y \\) 的不确定性，即在随机变量 \\( X \\) 给定的条件下随机变量 \\( Y \\) 的条件熵 \\( H(Y|X) \\)，定义为 \\( X \\) 给定条件下 \\( Y \\) 的条件概率分布的熵对 \\( X \\) 的数学期望：\n$$ H(Y|X) = \\sum_{i=1}^{n} p_i H(Y|X=x_i) $$信息增益 集合 \\( D \\) 的经验熵 \\( H(D) \\) 与特征 \\( A \\) 给定条件下 \\( D \\) 的经验条件熵 \\( H(D|A) \\) 之差：\n$$ g(D,A) = H(D) - H(D|A) $$实战(第四次作业题) 序号 是否有其他选择 饿否 价格 餐馆类型 餐馆顾客人数 等待时间 (分钟) 决策：是否等待 1 是 是 $$$ 法式 有人 0-10 是 2 是 是 $ 中餐 客满 30-60 否 3 否 否 $ 快餐 有人 0-10 是 4 是 是 $ 中餐 客满 10-30 是 5 是 否 $$$ 法式 客满 \u0026gt;60 否 6 否 是 $$ 意大利式 有人 0-10 是 7 否 否 $ 快餐 无人 0-10 否 8 否 是 $$ 中餐 有人 0-10 是 9 否 否 $ 快餐 客满 \u0026gt;60 否 10 是 是 $$$ 意大利式 客满 10-30 否 11 是 否 $ 中餐 无人 0-10 否 12 否 是 $ 快餐 客满 30-60 是 算法步骤 计算数据集中决策属性“是否等待”的熵（Entropy）。 对每个特征计算其信息增益（Information Gain），选择信息增益最大的特征作为根节点。 对选中的特征划分子数据集，递归地对每个子数据集继续构造子树，直到每个子集中的样本都属于同一类别，或者没有更多特征可以用来分裂。 生成最终的决策树。 第一层计算实例 我们首先要计算整体数据集的熵，然后逐个计算每个特征的信息增益：\n整体数据集经验熵计算： 有6个样例决策为是，6个样例决策为否。\n标签 YES NO 汇总 样本数 6 6 12 概率值 6/12 6/12 12/12 $$ Entropy(S) = -\\left(\\frac{6}{12}\\log_2\\frac{6}{12}\\right) - \\left(\\frac{6}{12}\\log_2\\frac{6}{12}\\right) = 1 $$经验熵计算完了，现在，我们要计算每个特征的条件熵，以及对应的信息增益，并对信息增益进行排序，选择增益最大的特征作为第一个分裂点进行分裂。\n1.特征“是否有其他选择”的信息增益： 这个特征包含两个属性取值，是和否\n是否有其他选择 YES NO 样本数 是 2 4 6 否 4 2 6 $$ Entropy(S_{是}) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$$$ Entropy(S_{否}) = -\\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.780 $$信息增益计算： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{6}{12} \\times 0.918 + \\frac{6}{12} \\times 0.780\\right) ≈ 0.151 $$ “是否有其他选择”这个特征的信息增益计算结束了，现在，我们需要对其他特征应用相同的计算方法，计算出剩余每个特征的风险增益。\n2.特征“饿否”的信息增益： 这个特征包含两个属性取值，是和否\n饿否 YES NO 样本数 是 5 2 7 否 1 4 5 $$ Entropy(S_{是}) = -\\left(\\frac{5}{7}\\log_2\\frac{5}{7}\\right) - \\left(\\frac{2}{7}\\log_2\\frac{2}{7}\\right) ≈ 0.863 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{5}\\log_2\\frac{1}{5}\\right) - \\left(\\frac{4}{5}\\log_2\\frac{4}{5}\\right) ≈ 0.722 $$信息增益计算： $$ Gain(Decision, 饿否) = 1 - \\left(\\frac{7}{12} \\times 0.863 + \\frac{5}{12} \\times 0.722\\right) ≈ 0.1958 $$ 3.特征\u0026quot;价格”的信息增益： 这个特征包含三个属性取值，$和$$和$$$\n价格 YES NO 样本数 $ 3 4 7 $$ 2 0 2 $$$ 1 2 3 $$ Entropy(S_{￥}) = -\\left(\\frac{3}{7}\\log_2\\frac{3}{7}\\right) - \\left(\\frac{4}{7}\\log_2\\frac{4}{7}\\right) ≈ 0.985 $$$$ Entropy(S_{￥￥}) = -\\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) - \\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) = 0 $$如果类的实例数为0，而实例总数为n，则需要计算*-(0/n) .log2(0/n)，*定义0*log2*0=0，熵只依赖于X的分布，与X的取值无关。这里，log(0）将等于-∞, 我们不能计算0次∞。这是决策树应用程序中经常出现的一种特殊情况。 $$ Entropy(S_{￥￥￥}) = -\\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) ≈ 0.918 $$ 信息增益计算： $$ Gain(Decision, 价格) = 1 - \\left(\\frac{7}{12} \\times 0.985 + \\frac{2}{12} \\times 0+\\frac{3}{12} \\times 0.918\\right) ≈ 0.1959 $$ 4.特征“餐馆类型”的信息增益： 这个特征包含四个属性取值，法式和中餐和快餐和意大利式。\n餐馆类型 YES NO 样本数 法式 1 1 2 中餐 1 3 4 快餐 2 2 4 意大利式 1 1 2 $$ Entropy(S_{法}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{中}) = -\\left(\\frac{1}{4}\\log_2\\frac{1}{4}\\right) - \\left(\\frac{3}{4}\\log_2\\frac{3}{4}\\right) ≈ 0.811 $$$$ Entropy(S_{快}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{意}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$信息增益计算： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{2}{12} \\times 1 + \\frac{4}{12} \\times 0.811 + \\frac{4}{12} \\times 1+ \\frac{2}{12} \\times 1\\right) ≈ 0.063 $$ 5.特征“餐馆顾客人数”的信息增益： 这个特征包含三个属性取值，无人和有人和客满。\n餐馆顾客人数 YES NO 样本数 无人 0 2 2 有人 4 0 4 客满 2 4 6 $$ Entropy(S_{无人}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$$$ Entropy(S_{有人}) = -\\left(\\frac{4}{4}\\log_2\\frac{4}{4}\\right) - \\left(\\frac{0}{4}\\log_2\\frac{0}{4}\\right) = 0 $$$$ Entropy(S_{客满}) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$信息增益计算： $$ Gain(Decision, 餐馆顾客人数) = 1 - \\left(\\frac{2}{12} \\times 0 + \\frac{4}{12} \\times 0+\\frac{6}{12} \\times 0.918\\right) ≈ 0.541 $$ 6.特征“等待时间(分钟)”的信息增益： 这个特征包含四个属性取值，0-10和10-30和30-60和\u0026gt;60。\n等待时间(分钟) YES NO 样本数 0-10 4 2 6 10-30 1 1 2 30-60 1 1 2 \u0026gt;60 0 2 2 $$ Entropy(S_{0-10}) = -\\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) - \\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) ≈ 0.918 $$$$ Entropy(S_{10-30}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{\u003e60}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$信息增益计算： $$ Gain(Decision, 等待时间) = 1 - \\left(\\frac{6}{12} \\times 0.918 + \\frac{2}{12} \\times 1 + \\frac{2}{12} \\times 1+ \\frac{2}{12} \\times 0\\right) ≈ 0.2077 $$ 第二层分裂决策 Feature Gain 排名 餐馆顾客人数 0.541 1 等待时间(分钟) 0.2077 2 价格 0.1959 3 饿否 0.1958 4 是否有其他选择 0.1951 5 餐馆类型 0.063 6 第一层分裂的特征确定后就要根据分裂的结果，进行第二层的分裂，同第一层，也是需要计算每个子集的经验熵 + 条件熵。\n数据集第一步被餐馆顾客人数这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。\n通过对所有特征的信息增益进行比较，选择信息增益最高的特征作为决策节点，继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-无人(有人) 分支 在无人这个分支上，标签全部是no，也就是已经彻底的完成了分裂了，这个就可以作为叶子节点，无需继续分裂。在有人这个分支上，标签全部是yes，这个也可以作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 客满 是 否 $$$ 法式 \u0026gt;60 否 客满 否 否 $ 快餐 \u0026gt;60 否 客满 是 是 $$$ 意大利式 10-30 否 客满 否 是 $ 快餐 30-60 是 该子集中有 2 个样例决策为是，4 个样例决策为否。\n1.整体数据集经验熵计算： $$ Entropy(S) = -\\left(\\frac{2}{6}\\log_2\\frac{2}{6}\\right) - \\left(\\frac{4}{6}\\log_2\\frac{4}{6}\\right) ≈ 0.918 $$现在我们对剩下的特征重新计算信息增益。\n1. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 3 4 否 1 1 2 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{4}\\log_2\\frac{1}{4}\\right) - \\left(\\frac{3}{4}\\log_2\\frac{3}{4}\\right) ≈ 0.811 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$信息增益： $$ Gain(Decision, 是否有其他选择) = 0.918 - \\left(\\frac{4}{6} \\times 0.811 + \\frac{2}{6} \\times 1\\right) ≈ 0.0207 $$2. 特征“饿否”的信息增益 饿否 YES NO 样本数 是 2 2 4 否 0 2 2 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{否}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$信息增益： $$ Gain(Decision, 饿否) = 0.918 - \\left(\\frac{4}{6} \\times 1 + \\frac{2}{6} \\times 0\\right) ≈ 0.2513 $$3. 特征“价格”的信息增益 价格 YES NO 样本数 $ 2 2 4 $$$ 0 2 2 计算条件熵： $$ Entropy(S_{￥}) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$$$ Entropy(S_{￥￥￥}) = -\\left(\\frac{0}{2}\\log_2\\frac{0}{2}\\right) - \\left(\\frac{2}{2}\\log_2\\frac{2}{2}\\right) = 0 $$信息增益： $$ Gain(Decision, 价格) = 0.918 - \\left(\\frac{4}{6} \\times 1 + \\frac{2}{6} \\times 0\\right) ≈ 0.2513 $$4. 特征“餐馆类型”的信息增益 餐馆类型 YES NO 样本数 中餐 1 1 2 快餐 1 1 2 法式 0 1 1 意大利式 0 1 1 计算条件熵： $$ Entropy(S_{中餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{快餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{法式})=Entropy(S_{意大利式})=0 $$信息增益： $$ Gain(Decision, 餐馆类型) = 0.918 - \\left(\\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 1 + \\frac{1}{6} \\times 0 + \\frac{1}{6} \\times 0\\right)≈ 0.2511 $$5. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 1 2 30-60 1 1 2 \u0026gt;60 0 2 2 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{\u003e60}) = 0 $$信息增益： $$ Gain(Decision, 等待时间) = 0.918 - \\left(\\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 1 + \\frac{2}{6} \\times 0 \\right) ≈ 0.2513 $$ 第三层分裂决策 Feature Gain 排名 饿否 0.2513 1 等待时间(分钟) 0.2513 1 价格 0.2513 1 餐馆类型 0.2511 4 是否有其他选择 0.0207 5 第三层也是需要计算每个子集的经验熵 + 条件熵。此时前三的信息增益一致，选任意一个即可。\n数据集第一步被餐馆饿否这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。\n通过对所有特征的信息增益进行比较，选择信息增益最高的特征作为决策节点，继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-否 分支 在否这个分支上，标签全部是no，也就是已经彻底的完成了分裂了，非常纯，这个就可以作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满|饿否-是 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 客满 是 是 $$$ 意大利式 10-30 否 客满 否 是 $ 快餐 30-60 是 此子集中有 2 个样例决策为是，2 个样例决策为否。\n1.整体数据集经验熵计算： 该子集的经验熵为： $$ Entropy(S) = -\\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) - \\left(\\frac{2}{4}\\log_2\\frac{2}{4}\\right) = 1 $$ 现在我们对剩余特征重新计算信息增益。\n2. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 2 3 否 1 0 1 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) - \\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) ≈ 0.918 $$$$ Entropy(S_{否}) = -\\left(\\frac{1}{1}\\log_2\\frac{1}{1}\\right) = 0 $$信息增益： $$ Gain(Decision, 是否有其他选择) = 1 - \\left(\\frac{3}{4} \\times 0.918 + \\frac{1}{4} \\times 0\\right) ≈ 0.311 $$2. 特征“价格”的信息增益 价格 YES NO 样本数 $ 2 1 3 $$$ 0 1 1 计算条件熵： $$ Entropy(S_{￥}) = -\\left(\\frac{2}{3}\\log_2\\frac{2}{3}\\right) - \\left(\\frac{1}{3}\\log_2\\frac{1}{3}\\right) ≈ 0.918 $$$$ Entropy(S_{￥￥￥}) = 0 $$信息增益： $$ Gain(Decision, 价格) = 1 - \\left(\\frac{3}{4} \\times 0.918 + \\frac{1}{4} \\times 0\\right) ≈ 0.311 $$3. 特征“餐馆类型”的信息增益 餐馆类型 YES NO 样本数 中餐 1 1 2 快餐 1 0 1 意大利式 0 1 1 计算条件熵： $$ Entropy(S_{中餐}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$$$ Entropy(S_{快餐}) = Entropy(S_{意大利式}) = 0 $$信息增益： $$ Gain(Decision, 餐馆类型) = 1 - \\left(\\frac{2}{4} \\times 1 + \\frac{1}{4} \\times 0 + \\frac{1}{4} \\times 0\\right) = 0.5 $$4. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 1 2 30-60 1 1 2 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 信息增益： $$ Gain(Decision, 等待时间) = 1 - 1 = 0 $$ 第四层分裂决策 Feature Gain 排名 餐馆类型 0.5 1 价格 0.311 2 是否有其他选择 0.2513 3 等待时间(分钟) 0 4 数据集第一步被餐馆餐馆类型这个特征分裂成三个节点，现在需要对每个节点计算下一步的分裂特征。继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-是|餐馆类型-快餐(意大利式) 分支 在快餐个分支上，标签全部是yes，意大利式分支上全是no，非常纯，作为叶子节点，无需继续分裂。\n餐馆顾客人数-客满|饿否-是|餐馆类型-中餐 分支 这个分支包含以下数据集：\n餐馆顾客人数 是否有其他选择 饿否 价格 餐馆类型 等待时间 (分钟) 决策：是否等待 客满 是 是 $ 中餐 30-60 否 客满 是 是 $ 中餐 10-30 是 此分支中有 1 个样例决策为是，1 个样例决策为否。\n1. 整体数据集经验熵计算 该子集的经验熵为： $$ Entropy(S) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 现在我们对剩余特征重新计算信息增益。\n2. 特征“是否有其他选择”的信息增益 是否有其他选择 YES NO 样本数 是 1 1 2 否 0 0 0 计算条件熵： $$ Entropy(S_{是}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 因为是否有其他选择没有有效的分裂，信息增益为0。\n3. 特征“价格”的信息增益 价格 YES NO 样本数 $ 1 1 2 计算条件熵： $$ Entropy(S_{￥}) = -\\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) - \\left(\\frac{1}{2}\\log_2\\frac{1}{2}\\right) = 1 $$ 价格也没有带来有效分裂，信息增益为0。\n4. 特征“等待时间(分钟)”的信息增益 等待时间(分钟) YES NO 样本数 10-30 1 0 1 30-60 0 1 1 计算条件熵： $$ Entropy(S_{10-30}) = Entropy(S_{30-60}) = 0 $$ 信息增益： $$ Gain(Decision, 等待时间) = 1 - 0 = 1 $$ 第五层分裂决策 Feature Gain 排名 等待时间(分钟) 1 1 价格 0 2 是否有其他选择 0 2 数据集第一步被餐馆等待时间这个特征分裂成两个节点，现在需要对每个节点计算下一步的分裂特征。继续对数据集进行划分，直到生成完整的决策树。\n餐馆顾客人数-客满|饿否-是|餐馆类型-中餐|等待时间-1030(3060) 分支 在10-30分支上，标签全部是yes，30-60分支上全是no，非常纯，无需继续分裂。\n至此，最终决策树已构建。\n最终决策树结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . └─顾客人数 ├─客满 │ └─饿否 │ ├─否-\u0026gt;no │ └─是 │ └─餐馆类型 │ ├─中餐 │ │ └─等待时间 │ │ ├─10~30-\u0026gt;yes │ │ └─30~60-\u0026gt;no │ ├─快餐-\u0026gt;yes │ └─意大利式-\u0026gt;no ├─无人-\u0026gt;no └─有人-\u0026gt;yes 仅供参考，可能有误\n","date":"2024-10-19T00:00:00Z","image":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF2-%E5%85%B8%E5%9E%8B%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95id3/%E5%B1%8F%E5%B9%95%E6%88%AA%E5%9B%BE%202024-10-19%20102252_hu13349180579781095972.png","permalink":"http://localhost:1313/p/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%8A%80%E6%9C%AF2-%E5%85%B8%E5%9E%8B%E5%86%B3%E7%AD%96%E6%A0%91%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95id3/","title":"机器人技术(2): 典型决策树学习算法ID3"},{"content":"#STL常用算法函数及其参数简明含义 供快速回顾（常用函数摘自HFUT ICPC讲义P21） find\n功能：在范围 [first, last) 中查找值为 val 的第一个元素。 参数： InIt first, InIt last：输入迭代器，指定搜索范围。 const T\u0026amp; val：需要查找的值。 find_if\n功能：在范围 [first, last) 中查找第一个满足谓词 pr 的元素。 参数： InIt first, InIt last：输入迭代器。 Pred pr：一元谓词函数，返回布尔值。 count\n功能：计算范围 [first, last) 中等于 val 的元素个数。 参数： InIt first, InIt last：输入迭代器。 const T\u0026amp; val：待计数的值。 count_if\n功能：计算范围 [first, last) 中满足谓词 pr 的元素个数。 参数： InIt first, InIt last：输入迭代器。 Pred pr：一元谓词函数。 copy\n功能：将范围 [first, last) 中的元素复制到 x 开始的位置。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器，复制的目标位置。 swap\n功能：交换两个变量 x 和 y 的值。 参数： T\u0026amp; x, T\u0026amp; y：需要交换的两个变量。 swap_ranges\n功能：交换两个范围 [first, last) 和从 x 开始的元素。 参数： FwdIt1 first, FwdIt1 last：第一个范围的迭代器。 FwdIt2 x：第二个范围的起始迭代器。 replace\n功能：将范围 [first, last) 中等于 vold 的元素替换为 vnew。 参数： FwdIt first, FwdIt last：输入迭代器。 const T\u0026amp; vold, const T\u0026amp; vnew：旧值和新值。 replace_if\n功能：将范围 [first, last) 中满足谓词 pr 的元素替换为 val。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：一元谓词函数。 const T\u0026amp; val：替换的值。 generate\n功能：用生成器 g 生成的值填充范围 [first, last)。 参数： FwdIt first, FwdIt last：输入迭代器。 Gen g：生成器函数。 generate_n\n功能：用生成器 g 生成的值填充从 first 开始的 n 个元素。 参数： OutIt first：输出迭代器。 Dist n：生成元素的数量。 Gen g：生成器函数。 remove\n功能：删除范围 [first, last) 中等于 val 的元素，并返回新范围的末尾迭代器。 参数： FwdIt first, FwdIt last：输入迭代器。 const T\u0026amp; val：需要删除的值。 remove_if\n功能：删除范围 [first, last) 中满足谓词 pr 的元素，并返回新范围的末尾迭代器。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：一元谓词函数。 remove_copy\n功能：将范围 [first, last) 中不等于 val 的元素复制到 x 开始的地方。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器。 const T\u0026amp; val：待删除的值。 remove_copy_if\n功能：将范围 [first, last) 中不满足谓词 pr 的元素复制到 x 开始的位置。 参数： InIt first, InIt last：输入迭代器。 OutIt x：输出迭代器。 Pred pr：一元谓词函数。 unique\n功能：删除范围 [first, last) 中相邻的重复元素。 参数： FwdIt first, FwdIt last：输入迭代器。 unique (带谓词)\n功能：删除范围 [first, last) 中相邻满足谓词 pr 的重复元素。 参数： FwdIt first, FwdIt last：输入迭代器。 Pred pr：二元谓词函数。 reverse\n功能：反转范围 [first, last) 中的元素。 参数： BidIt first, BidIt last：双向迭代器。 reverse_copy\n功能：将范围 [first, last) 中的元素反转后复制到 x 开始的位置。 参数： BidIt first, BidIt last：双向迭代器。 OutIt x：输出迭代器。 partition\n功能：将范围 [first, last) 中满足谓词 pr 的元素放在不满足谓词的元素之前。 参数： BidIt first, BidIt last：双向迭代器。 Pred pr：一元谓词函数。 stable_partition\n功能：与 partition 类似，但保留相对顺序。 参数： FwdIt first, FwdIt last：前向迭代器。 Pred pr：一元谓词函数。 sort\n功能：对范围 [first, last) 中的元素进行升序排序。 参数： RanIt first, RanIt last：随机访问迭代器。 sort (带谓词)\n功能：按照谓词 pr 对范围 [first, last) 中的元素排序。 参数： RanIt first, RanIt last：随机访问迭代器。 Pred pr：二元谓词函数。 stable_sort\n功能：稳定排序范围 [first, last) 中的元素，保留相等元素的相对顺序。 参数： BidIt first, BidIt last：双向迭代器。 stable_sort (带谓词)\n功能：按照谓词 pr 稳定排序。 参数： BidIt first, BidIt last：双向迭代器。 Pred pr：二元谓词函数。 nth_element\n功能：对范围 [first, last) 进行部分排序，使得 nth 处的元素位于其最终位置。 参数： RanIt first, RanIt nth, RanIt last：随机访问迭代器。 binary_search\n功能：判断范围 [first, last) 中是否存在值 val。 参数： FwdIt first, FwdIt last：前向迭代器。 const T\u0026amp; val：要查找的值。 binary_search (带谓词)\n功能：根据谓词 pr 判断范围 [first, last) 中是否存在值 val。 参数： FwdIt first, FwdIt last：前 向迭代器。 - const T\u0026amp; val：要查找的值。 - Pred pr：二元谓词函数。\nmerge\n功能：将两个已排序的范围合并到一个新的范围中。 参数： InIt1 first1, InIt1 last1：第一个范围的输入迭代器。 InIt2 first2, InIt2 last2：第二个范围的输入迭代器。 OutIt x：输出迭代器。 merge (带谓词)\n功能：根据谓词 pr 将两个已排序范围合并。 参数： InIt1 first1, InIt1 last1：第一个范围的输入迭代器。 InIt2 first2, InIt2 last2：第二个范围的输入迭代器。 OutIt x：输出迭代器。 Pred pr：二元谓词函数。 max\n功能：返回 x 和 y 中较大的那个。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 max (带谓词)\n功能：根据谓词 pr 返回较大的值。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 Pred pr：二元谓词函数。 min\n功能：返回 x 和 y 中较小的那个。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 min (带谓词)\n功能：根据谓词 pr 返回较小的值。 参数： const T\u0026amp; x, const T\u0026amp; y：两个待比较的值。 Pred pr：二元谓词函数。 仅供参考，可能有误\n","date":"2024-10-18T00:00:00Z","image":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF1-stl/stl_hu16550555255445278498.png","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF1-stl/","title":"程序设计艺术(1): STL"},{"content":" 仅供参考，可能有误\n","date":"2024-10-18T00:00:00Z","image":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF2-%E6%90%9C%E7%B4%A2/stl_hu16550555255445278498.png","permalink":"http://localhost:1313/p/%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E8%89%BA%E6%9C%AF2-%E6%90%9C%E7%B4%A2/","title":"程序设计艺术(2): 搜索"},{"content":"Hugo 是用 Go 实现的博客工具，采用 Markdown 进行文章编辑，自动生成静态站点文件，支持丰富的主题配置，也可以通过 js 嵌入像是评论系统等插件，高度定制化。除了 Hugo 外， 还有 Jekyll(github page默认)、Gatsby、Hexo、Ghost 等选择，实现和使用都差不多，可以根据自己的偏好进行选择。\n安装 Hugo 在ubuntu24.04 LTS环境下到 Hugo Releases 下载对应的deb包(注意安装extend版本，许多第三方主题需要extend依赖)，安装完成后，使用以下命令进行验证：\n1 hugo version 创建 Hugo 网站 通过上述命令安装 hugo 程序后，就可以通过 hugo new site 命令进行网站创建、配置与本地调试了，如希望生成到 /path/to/site 路径：\n1 $ hugo new site /path/to/site 这样就在 /path/to/site 目录里生成了初始站点，进去目录：\n1 $ cd /path/to/site 站点目录结构：\n1 2 3 4 5 6 7 8 9 . ├── archetypes: default.md是生成博文的模版 ├── assets # 存放被 Hugo Pipes 处理的文件 ├── content # 存放markdown文件作为博文内容 ├── data # 存放 Hugo 处理的数据 ├── layouts # 存放布局文件 ├── static # 存放静态文件 图片 CSS JS文件 ├── themes: 存放不同的主题 └── config.toml: 博客配置文件支持 JSON YAML TOML 三种格式配置文件 创建文章 创建一个 about 页面：\n1 $ hugo new about.md about.md 自动生成到了 content/about.md ，打开 about.md 看下：\n1 2 3 4 5 6 7 8 +++ date = \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; draft = true title = \u0026#34;about\u0026#34; +++ 正文内容 内容是 Markdown 格式的，+++ 之间的内容是 TOML 格式的，根据你的喜好，你可以换成 YAML 格式（使用 --- 标记）或者 JSON 格式。\n创建第一篇文章，放到 content/post 目录，方便之后生成聚合页面。\n1 $ hugo new post/first.md 打开编辑 content/post/first.md ：\n1 2 3 4 5 6 7 8 9 10 11 --- date: \u0026#34;2015-10-25T08:36:54-07:00\u0026#34; title: \u0026#34;first\u0026#34; --- ### Hello Hugo 1. aaa 1. bbb 1. ccc 注意此项为可选步骤，跳过可直接copy他人主题\n配置主题 当通过上文命令创建我们的站点后，需要进行主题配置，Hugo 社区有了很丰富的主题，可以通过官网 Themes 菜单选择自己喜欢的风格，查看预览效果，选择后可以进入主题项目的github仓库，一般人气多的主题都会有很详细的安装及配置说明。\n传统方式使用的是将原主题仓库 fork 到自己的账户，并使用 git submodule 方式进行仓库链接，这样后续可以对主题的修改进行单独维护。\n1 2 3 cd cita-site/#进入网站工程根目录 git init git submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack#笔者所用主题为stack，此行与你所选主题有关 然后在根目录下的 config.toml文件中添加新的一行:\n1 theme = \u0026#34;your_theme\u0026#34; 此时大多数主题仓库提供example文件，你可以拷贝至你的工程根目录下，主要是content与config文件，之后就能进行下一步，如有问题建议查看主题提供的参考手册。\n生成网页 为了查看生成的博客的效果，我们在本地编辑调试时可以通过 hugo server 命令进行本地实时调试预览，无须每次都重新生成。在bash中运行以下命令，即我们可以通过浏览器 http://localhost:1313/ 地址访问我们的本地预览网页。\n1 hugo server 但此时只能在本地访问，如果想发布到 Github Pages ， 还需要借助 GithubPages 工具。\nGithub Pages部署 假设你需要部署在 GitHub Pages 上，首先在GitHub上创建一个Repository，命名为：coderzh.github.io （coderzh替换为你的github用户名）。站点目录config.toml中baseURL要换成自己建立的仓库，如baseURL = “https://cita-777.github.io/\u0026quot;\n在站点根目录执行 Hugo 命令生成最终页面：\n1 $ hugo --theme=hyde --baseURL=\u0026#34;http://coderzh.github.io/\u0026#34; 如果一切顺利，所有静态页面都会生成到 public 目录，将pubilc目录里所有文件 push 到刚创建的Repository的 master 分支。\n1 2 3 4 5 6 $ cd public $ git init $ git remote add origin https://github.com/coderzh/coderzh.github.io.git $ git add -A $ git commit -m \u0026#34;first commit\u0026#34; $ git push -u origin master 浏览器里访问：http://coderzh.github.io/\n注意必须只上传public中的所有文件，若无法使用密钥则使用ssh鉴定身份(git remote set-url origin git@github.com:cita-777/cita-777.github.io.git)，目前github默认主分支为main，建议设置里改为master\n后续修改网页 对content和config进行自行随意修改后需要重新上传至github仓库同步更新。切记不要随意手动删除public文件让Hugo重新生成再尝试push，因为这会将public内的.git一起删除，你将需要重新配置git并且链接至远程仓库，当你使用hugo server命令在本地生存并预览网站后，Hugo会自动生成新的public文件，包含你对网站所作的所有新更改，而且你在static文件管理资源时所进行的增加与删除，public中只会进行增加而不会删除，本意是很好的，这是一种非破坏性修改。所以如果你有用不上的资源，记得在public文件内手动删除来减少空间占用，所以你只需要朴实无华的push即可，参考命令如下：\n1 2 3 4 5 6 hugo server -D ctrl + c #关闭本地server cd public #进入public文件内 git add -A #提交all变动 git commit -m \u0026#34;修改/更新了xxx\u0026#34; git push -u origin master #push到远程仓库 (进阶)Github Action 自动发布 通过前面的操作我们可以手动发布我们的静态文件，但还是有以下弊端：\n发布步骤还是比较繁琐，本地调试后还需要切换到 public/ 目录进行上传 无法对博客 .md 源文件进行备份与版本管理 因此，我们需要简单顺滑的方式来进行博客发布，首先我们初始化博客源文件的仓库，如我的仓库为 pseudoyu/yu-blog。\n因为我们的博客基于 GitHub 与 GitHub Pages，可以通过官方提供的 GitHub Action 进行 CI 自动发布，下面我会进行详细讲解。GitHub Action 是一个持续集成和持续交付(CI/CD) 平台，可用于自动执行构建、测试和部署管道，目前已经有很多开发好的工作流，可以通过简单的配置即可直接使用。\n配置在仓库目录 .github/workflows 下，以 .yml 为后缀。我的 GitHub Action 配置为 pseudoyu/yu-blog deploy.yml，自动发布示例配置如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 name: deploy on: push: workflow_dispatch: schedule: # Runs everyday at 8:00 AM - cron: \u0026#34;0 0 * * *\u0026#34; jobs: build: runs-on: ubuntu-latest steps: - name: Checkout uses: actions/checkout@v2 with: submodules: true fetch-depth: 0 - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#34;latest\u0026#34; - name: Build Web run: hugo - name: Deploy Web uses: peaceiris/actions-gh-pages@v3 with: PERSONAL_TOKEN: ${{ secrets.PERSONAL_TOKEN }} EXTERNAL_REPOSITORY: pseudoyu/pseudoyu.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public commit_message: ${{ github.event.head_commit.message }} on 表示 GitHub Action 触发条件，我设置了 push、workflow_dispatch 和 schedule 三个条件：\npush，当这个项目仓库发生推送动作后，执行 GitHub Action workflow_dispatch，可以在 GitHub 项目仓库的 Action 工具栏进行手动调用 schedule，定时执行 GitHub Action，如我的设置为北京时间每天早上执行，主要是使用一些自动化统计 CI 来自动更新我博客的关于页面，如本周编码时间，影音记录等，如果你不需要定时功能，可以删除这个条件 jobs 表示 GitHub Action 中的任务，我们设置了一个 build 任务，runs-on 表示 GitHub Action 运行环境，我们选择了 ubuntu-latest。我们的 build 任务包含了 Checkout、Setup Hugo、Build Web 和 Deploy Web 四个主要步骤，其中 run 是执行的命令，uses 是 GitHub Action 中的一个插件，我们使用了 peaceiris/actions-hugo@v2 和 peaceiris/actions-gh-pages@v3 这两个插件。其中 Checkout 步骤中 with 中配置 submodules 值为 true 可以同步博客源仓库的子模块，即我们的主题模块。\n首先需要将上述 deploy.yml 中的 EXTERNAL_REPOSITORY 改为自己的 GitHub Pages 仓库，如我的设置为 pseudoyu/pseudoyu.github.io。\n因为我们需要从博客仓库推送到外部 GitHub Pages 仓库，需要特定权限，要在 GitHub 账户下 Setting - Developer setting - Personal access tokens 下创建一个 Token。\n","date":"2024-10-06T00:00:00Z","image":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu9262121530157302112.jpg","permalink":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A21/","title":"Hugo+Github Pages搭建静态网站作为个人博客(1)"},{"content":"上一篇博客中重点于Hugo的使用，这一篇着重于以Stack主题为例进行博客撰写。\nStack is a simple card-style Hugo theme designed for Bloggers. Here are some of the features: Stack 是一个简单的卡片式 Hugo 主题，专为 Blogger 设计。以下是一些功能：\nResponsive images support 响应式图像支持 Lazy load images 延迟加载图像 Dark mode 深色模式 Local search 本地搜索 PhotoSwipe integration 照片滑动集成 Archive page template 存档页面模板 Full native JavaScript, no jQuery or any other frameworks are used 完全原生 JavaScript，不使用 jQuery 或任何其他框架 No CSS framework, keep it simple and minimal 没有 CSS 框架，保持简单和最小化 Properly cropped thumbnails 正确裁剪的缩略图 Subsection support 分段支持 Table of contents 目录 Hugo网站文件结构 网站根目录下面的文件夹目录树一般如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 . ├── archetypes │ └── default.md ├── hugo.yaml # 网站配置文件 ├── content # 站点内的内容都在这里 │ ├── categories # “分类”页面的首页 │ │ └── Test # “分类”页面下的一个分类页面 │ ├── page # 显示在网站主页左侧边栏菜单的选项 │ │ ├── about # 左侧边栏菜单中的“关于”页面 │ │ ├── archives # 左侧边栏菜单中的“归档”页面 │ │ ├── links # 左侧边栏菜单中的“链接”页面 │ │ └── search # 左侧边栏菜单中的“搜索”页面 │ └── post # 用户写的帖子都放在这里，每个子文件夹对应一个帖子 │ ├── chinese-test │ ├── emoji-support │ ├── markdown-syntax │ ├── math-typesetting │ ├── placeholder-text │ └── rich-content ├── data ├── layouts ├── LICENSE ├── README.md ├── resources │ └── _gen │ ├── assets │ └── images ├── static # 放用户自定义字体、用户头像、网站小图标等 └── themes # 放各种主题 └── hugo-theme-stack # stack主题 ├── archetypes ├── assets #里面有个img存放头像图片位置 ├── config.yaml #stack主题的配置文件，优先级低于上面的网站配置文件 ├── data ├── debug.sh ├── exampleSite ├── go.mod ├── i18n #多语言支持包 ├── images #网站示例的截图存放位置 ├── layouts ├── LICENSE ├── netlify.toml ├── README.md └── theme.toml 主要修改主题内和网站内的config.yaml，具体含义可见官方手册。\n此外，上面没有显示的是网站根目录下的private文件夹和public文件夹。\npublic文件夹会在运行hugo -D部署网站时生成，是暴露给外界的文件夹，网站上页面的HTML文件都会由Hugo生成并放在public文件夹下。public文件夹内不要放置任何包含用户信息的敏感文件！ private文件夹可以由用户创建，这里我们用它来存放网站的SSL证书。 关于网站根目录下各文件夹，更详细的说明可参见Hugo官方文档。\n配置文件夹config Hugo支持两种配置方式：\n一种是直接在网站根目录的.config文件中配置 另一种是在网站根目录下创建config文件夹，配置放在config文件夹内 第二种配置方式支持将不同的配置项分开放在不同的文件中，相比第一种配置方式可以让配置项的条理更加清晰，因此我们这里选择第二种配置方式。参考配置目录结构如下所示：\n1 2 3 4 5 6 7 8 config └── _default ├── config.yaml ├── languages.yaml ├── menu.en.yaml ├── menu.zh-cn.yaml ├── params.en.yaml └── params.zh-cn.yaml 关于Hugo的配置，更详细的说明可参考官方文档。\n[附录1]主题内config.yaml各参数简明含义 Module (模块设置)\nhugoVersion\n: 定义Hugo版本要求。\nextended: 设置为true表示需要Hugo的扩展版本（支持SCSS和其他高级功能）。 min: 需要的最低Hugo版本为0.87.0。 Params (参数设置)\nmainSections: 定义主要的内容部分，这里是post，也就是文章部分。 featuredImageField: 文章中用于展示特色图片的字段名称，默认为image。 rssFullContent: RSS中是否提供文章的完整内容，true表示是。 Favicon (网站图标)\nfavicon: 设置网站的favicon路径，如果有一个favicon.ico，可以设置为/favicon.ico。 Footer (页脚)\nsince: 页脚中显示的年份（通常是网站开始的年份），这个字段为空，可以填入年份，如“2024”。 customText: 页脚自定义文本，当前为空，可以填写你想显示的内容。 Date Format (日期格式)\npublished: 发布日期的显示格式，这里格式为Jan 02, 2006。 lastUpdated: 最后更新日期的显示格式，这里包括日期和时间。 Sidebar (侧边栏)\ncompact: 是否使用紧凑布局，false表示不使用紧凑布局。\nemoji: 表情符号，可以为空或者自定义一个表情符号显示在侧边栏上。\nsubtitle: 侧边栏的副标题，当前为空，可以添加文字。\navatar\n: 头像设置。\nenabled: 是否显示头像，true表示显示。 local: true表示头像从本地文件加载。 src: 头像的路径为img/avatar.png。 Article (文章设置)\nheadingAnchor: 设置是否在标题旁边显示锚点，false表示不显示。\nmath: 是否支持数学公式，false表示不支持。\ntoc: 目录设置，true表示显示文章目录。\nreadingTime: 是否显示阅读时间，true表示显示。\nlicense\n: 文章版权设置。\nenabled: 是否启用版权声明，false表示不启用。 default: 默认的版权声明，当前设置为“Creative Commons BY-NC-SA 4.0”，但没有启用。 Comments (评论系统)\nenabled: 是否启用评论，false表示不启用。 provider: 默认评论提供者是disqus。 配置了多个评论系统，包括disqusjs, utterances, beaudar, remark42, vssue等。每个评论系统都有自己的设置项，例如Disqus、GitHub Issues（通过utterances）、Beaudar等。这些可以根据需要选择，并填入相关参数，如API密钥、仓库名称等。 Widgets (小工具)\nhomepage: 主页上的小工具列表，当前为空，也就是说默认没有显示任何小工具。 page: 页面上的小工具列表，当前为空。 OpenGraph (社交分享卡片)\ntwitter\n: 配置Twitter分享卡片。\nsite: 填写你的Twitter用户名。 card: 卡片类型，这里是summary_large_image，表示大图片的分享卡片。 DefaultImage (默认图片)\nopengraph\n: 配置默认图片的设置。\nenabled: 是否启用OpenGraph图片，false表示不启用。 local: 图片是否为本地图片，false表示不是本地图片。 src: 默认图片的路径。 ColorScheme (颜色主题)\ntoggle: 是否允许用户切换颜色主题（比如暗黑模式），true表示启用切换功能。 default: 默认颜色主题，这里是auto，表示根据用户系统的设置自动切换。 ImageProcessing (图片处理)\ncover: 是否启用封面图片处理，true表示启用。 content: 是否启用内容图片处理，true表示启用。 [附录2]官方示例提供的根目录内hugo.yaml各参数简明含义 基本信息\nbaseurl: 网站的基础URL。 languageCode: 默认语言代码，例如en-us表示英语（美国）。 theme: 使用的主题，在这里是hugo-theme-stack。 title: 网站的标题。 copyright: 网站的版权声明。 语言支持\nDefaultContentLanguage: 设置默认的语言为英语（en）。 hasCJKLanguage: 如果网站主要使用中文、日文或韩文等CJK（中日韩）语言，这个值应设为true，用于正确处理文章摘要和字数统计。 languages: 你可以为网站配置多语言支持。在这个例子中，网站支持英语（en）、中文简体（zh-cn）和阿拉伯语（ar）。每种语言可以有独立的标题和描述。 服务设置\ndisqus: 用于网站评论的服务，Disqus是一个流行的评论系统。如果要启用评论，需要更改为你自己的网站短名称。 googleAnalytics: 如果你使用Google Analytics（谷歌分析）进行流量统计，可以在这里填入你的追踪ID。 分页和永久链接\npagination: 设置分页大小为3，也就是说每页显示3篇文章。 permalinks: 自定义文章和页面的永久链接结构。例如，文章会显示为/p/:slug/。 页面参数\nparams: 包含各种网站布局、显示和功能的配置。比如文章是否显示数学公式、阅读时间、许可信息等。 评论功能\ncomments: 你可以选择不同的评论提供者（如Disqus、Utterances、Gitalk等），通过填入相关的配置信息来启用评论。 菜单和小工具\nmenu: 自定义网站菜单和社交链接。这里包括GitHub和Twitter的社交图标链接。 widgets: 配置主页和页面上的小工具，例如搜索栏、文章归档、标签云等。 其他配置\nopengraph: 配置网站在社交平台（如Twitter）的分享卡片。 colorScheme: 配置网站的颜色模式（自动、浅色或深色）。 imageProcessing: 图片处理选项，例如封面图片和内容图片。 相关内容\nrelated: 配置文章之间的相关性推荐，基于标签和分类等条件。 Markdown 渲染\nmarkup: 配置如何处理Markdown内容，例如表格、代码高亮、目录等。 两篇附录仅供参考，可能有错误\n","date":"2024-10-06T00:00:00Z","image":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu9262121530157302112.jpg","permalink":"http://localhost:1313/p/hugo-github-pages%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E4%BD%9C%E4%B8%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A22/","title":"Hugo+Github Pages搭建静态网站作为个人博客(2)"},{"content":"长沙 宣城 合肥 桂林 ","date":"2024-10-06T00:00:00Z","image":"http://localhost:1313/p/tim-cnt-1/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"http://localhost:1313/p/tim-cnt-1/","title":"TIM -\u003e CNT= -1"}]